// Code generated from ./ApexParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // ApexParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ApexParser struct {
	*antlr.BaseParser
}

var ApexParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func apexparserParserInit() {
	staticData := &ApexParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'('", "')'",
		"'{'", "'}'", "'['", "']'", "';'", "','", "'.'", "'='", "'>'", "'<'",
		"'!'", "'~'", "'?.'", "'?'", "':'", "'=='", "'==='", "'!='", "'<>'",
		"'!=='", "'&&'", "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", "'/'",
		"'&'", "'|'", "'^'", "'%'", "'=>'", "'+='", "'-='", "'*='", "'/='",
		"'&='", "'|='", "'^='", "'%='", "'<<='", "'>>='", "'>>>='", "'@'",
	}
	staticData.SymbolicNames = []string{
		"", "ABSTRACT", "AFTER", "BEFORE", "BREAK", "CATCH", "CLASS", "CONTINUE",
		"DELETE", "DO", "ELSE", "ENUM", "EXTENDS", "FINAL", "FINALLY", "FOR",
		"GET", "GLOBAL", "IF", "IMPLEMENTS", "INHERITED", "INSERT", "INSTANCEOF",
		"INTERFACE", "MERGE", "NEW", "NULL", "ON", "OVERRIDE", "PRIVATE", "PROTECTED",
		"PUBLIC", "RETURN", "SYSTEMRUNAS", "SET", "SHARING", "STATIC", "SUPER",
		"SWITCH", "TESTMETHOD", "THIS", "THROW", "TRANSIENT", "TRIGGER", "TRY",
		"UNDELETE", "UPDATE", "UPSERT", "VIRTUAL", "VOID", "WEBSERVICE", "WHEN",
		"WHILE", "WITH", "WITHOUT", "LIST", "MAP", "SELECT", "COUNT", "FROM",
		"AS", "USING", "SCOPE", "WHERE", "ORDER", "BY", "LIMIT", "SOQLAND",
		"SOQLOR", "NOT", "AVG", "COUNT_DISTINCT", "MIN", "MAX", "SUM", "TYPEOF",
		"END", "THEN", "LIKE", "IN", "INCLUDES", "EXCLUDES", "ASC", "DESC",
		"NULLS", "FIRST", "LAST", "GROUP", "ALL", "ROWS", "VIEW", "HAVING",
		"ROLLUP", "TOLABEL", "OFFSET", "DATA", "CATEGORY", "AT", "ABOVE", "BELOW",
		"ABOVE_OR_BELOW", "SECURITY_ENFORCED", "REFERENCE", "CUBE", "FORMAT",
		"TRACKING", "VIEWSTAT", "CUSTOM", "STANDARD", "CALENDAR_MONTH", "CALENDAR_QUARTER",
		"CALENDAR_YEAR", "DAY_IN_MONTH", "DAY_IN_WEEK", "DAY_IN_YEAR", "DAY_ONLY",
		"FISCAL_MONTH", "FISCAL_QUARTER", "FISCAL_YEAR", "HOUR_IN_DAY", "WEEK_IN_MONTH",
		"WEEK_IN_YEAR", "CONVERT_TIMEZONE", "YESTERDAY", "TODAY", "TOMORROW",
		"LAST_WEEK", "THIS_WEEK", "NEXT_WEEK", "LAST_MONTH", "THIS_MONTH", "NEXT_MONTH",
		"LAST_90_DAYS", "NEXT_90_DAYS", "LAST_N_DAYS_N", "NEXT_N_DAYS_N", "NEXT_N_WEEKS_N",
		"LAST_N_WEEKS_N", "NEXT_N_MONTHS_N", "LAST_N_MONTHS_N", "THIS_QUARTER",
		"LAST_QUARTER", "NEXT_QUARTER", "NEXT_N_QUARTERS_N", "LAST_N_QUARTERS_N",
		"THIS_YEAR", "LAST_YEAR", "NEXT_YEAR", "NEXT_N_YEARS_N", "LAST_N_YEARS_N",
		"THIS_FISCAL_QUARTER", "LAST_FISCAL_QUARTER", "NEXT_FISCAL_QUARTER",
		"NEXT_N_FISCAL_QUARTERS_N", "LAST_N_FISCAL_QUARTERS_N", "THIS_FISCAL_YEAR",
		"LAST_FISCAL_YEAR", "NEXT_FISCAL_YEAR", "NEXT_N_FISCAL_YEARS_N", "LAST_N_FISCAL_YEARS_N",
		"DateLiteral", "DateTimeLiteral", "IntegralCurrencyLiteral", "FIND",
		"EMAIL", "NAME", "PHONE", "SIDEBAR", "FIELDS", "METADATA", "PRICEBOOKID",
		"NETWORK", "SNIPPET", "TARGET_LENGTH", "DIVISION", "RETURNING", "LISTVIEW",
		"FindLiteral", "FindLiteralAlt", "IntegerLiteral", "LongLiteral", "NumberLiteral",
		"BooleanLiteral", "StringLiteral", "NullLiteral", "LPAREN", "RPAREN",
		"LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", "COMMA", "DOT", "ASSIGN",
		"GT", "LT", "BANG", "TILDE", "QUESTIONDOT", "QUESTION", "COLON", "EQUAL",
		"TRIPLEEQUAL", "NOTEQUAL", "LESSANDGREATER", "TRIPLENOTEQUAL", "AND",
		"OR", "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", "CARET",
		"MOD", "MAPTO", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN",
		"AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN",
		"RSHIFT_ASSIGN", "URSHIFT_ASSIGN", "ATSIGN", "Identifier", "WS", "DOC_COMMENT",
		"COMMENT", "LINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"triggerUnit", "triggerCase", "compilationUnit", "typeDeclaration",
		"classDeclaration", "enumDeclaration", "enumConstants", "interfaceDeclaration",
		"typeList", "classBody", "interfaceBody", "classBodyDeclaration", "modifier",
		"memberDeclaration", "methodDeclaration", "constructorDeclaration",
		"fieldDeclaration", "propertyDeclaration", "interfaceMethodDeclaration",
		"variableDeclarators", "variableDeclarator", "arrayInitializer", "typeRef",
		"arraySubscripts", "typeName", "typeArguments", "formalParameters",
		"formalParameterList", "formalParameter", "qualifiedName", "literal",
		"annotation", "elementValuePairs", "delimitedElementValuePair", "elementValuePair",
		"elementValue", "elementValueArrayInitializer", "trailingComma", "block",
		"localVariableDeclarationStatement", "localVariableDeclaration", "statement",
		"ifStatement", "switchStatement", "whenControl", "whenValue", "whenLiteral",
		"forStatement", "whileStatement", "doWhileStatement", "tryStatement",
		"returnStatement", "throwStatement", "breakStatement", "continueStatement",
		"insertStatement", "updateStatement", "deleteStatement", "undeleteStatement",
		"upsertStatement", "mergeStatement", "runAsStatement", "expressionStatement",
		"propertyBlock", "getter", "setter", "catchClause", "finallyBlock",
		"forControl", "forInit", "enhancedForControl", "forUpdate", "parExpression",
		"expressionList", "expression", "primary", "methodCall", "dotMethodCall",
		"creator", "createdName", "idCreatedNamePair", "noRest", "classCreatorRest",
		"arrayCreatorRest", "mapCreatorRest", "mapCreatorRestPair", "setCreatorRest",
		"arguments", "soqlLiteral", "query", "subQuery", "selectList", "selectEntry",
		"fieldName", "fromNameList", "fieldNameAlias", "subFieldList", "subFieldEntry",
		"soqlFieldsParameter", "soqlFunction", "dateFieldName", "typeOf", "whenClause",
		"elseClause", "fieldNameList", "usingScope", "whereClause", "logicalExpression",
		"conditionalExpression", "fieldExpression", "comparisonOperator", "value",
		"valueList", "signedNumber", "withClause", "filteringExpression", "dataCategorySelection",
		"dataCategoryName", "filteringSelector", "groupByClause", "orderByClause",
		"fieldOrderList", "fieldOrder", "limitClause", "offsetClause", "allRowsClause",
		"forClauses", "boundExpression", "dateFormula", "signedInteger", "soqlId",
		"soslLiteral", "soslLiteralAlt", "soslClauses", "searchGroup", "fieldSpecList",
		"fieldSpec", "fieldList", "updateList", "updateType", "networkList",
		"soslId", "id", "anyId",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 236, 1817, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 1, 0, 1, 0,
		1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 297, 8, 0, 10, 0, 12, 0, 300,
		9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3,
		5, 3, 313, 8, 3, 10, 3, 12, 3, 316, 9, 3, 1, 3, 1, 3, 5, 3, 320, 8, 3,
		10, 3, 12, 3, 323, 9, 3, 1, 3, 1, 3, 5, 3, 327, 8, 3, 10, 3, 12, 3, 330,
		9, 3, 1, 3, 3, 3, 333, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 339, 8, 4, 1,
		4, 1, 4, 3, 4, 343, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 351,
		8, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 5, 6, 358, 8, 6, 10, 6, 12, 6, 361,
		9, 6, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 367, 8, 7, 1, 7, 1, 7, 1, 8, 1, 8,
		1, 8, 5, 8, 374, 8, 8, 10, 8, 12, 8, 377, 9, 8, 1, 9, 1, 9, 5, 9, 381,
		8, 9, 10, 9, 12, 9, 384, 9, 9, 1, 9, 1, 9, 1, 10, 1, 10, 5, 10, 390, 8,
		10, 10, 10, 12, 10, 393, 9, 10, 1, 10, 1, 10, 1, 11, 1, 11, 3, 11, 399,
		8, 11, 1, 11, 1, 11, 5, 11, 403, 8, 11, 10, 11, 12, 11, 406, 9, 11, 1,
		11, 3, 11, 409, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 3, 12, 430, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 3, 13, 439, 8, 13, 1, 14, 1, 14, 3, 14, 443, 8, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 3, 14, 449, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 463, 8, 17, 10, 17,
		12, 17, 466, 9, 17, 1, 17, 1, 17, 1, 18, 5, 18, 471, 8, 18, 10, 18, 12,
		18, 474, 9, 18, 1, 18, 1, 18, 3, 18, 478, 8, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 19, 1, 19, 1, 19, 5, 19, 487, 8, 19, 10, 19, 12, 19, 490, 9, 19,
		1, 20, 1, 20, 1, 20, 3, 20, 495, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 5,
		21, 501, 8, 21, 10, 21, 12, 21, 504, 9, 21, 1, 21, 3, 21, 507, 8, 21, 3,
		21, 509, 8, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 5, 22, 516, 8, 22, 10,
		22, 12, 22, 519, 9, 22, 1, 22, 1, 22, 1, 23, 1, 23, 5, 23, 525, 8, 23,
		10, 23, 12, 23, 528, 9, 23, 1, 24, 1, 24, 3, 24, 532, 8, 24, 1, 24, 1,
		24, 3, 24, 536, 8, 24, 1, 24, 1, 24, 3, 24, 540, 8, 24, 1, 24, 1, 24, 3,
		24, 544, 8, 24, 3, 24, 546, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1,
		26, 3, 26, 554, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 5, 27, 561, 8,
		27, 10, 27, 12, 27, 564, 9, 27, 1, 28, 5, 28, 567, 8, 28, 10, 28, 12, 28,
		570, 9, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 5, 29, 578, 8, 29,
		10, 29, 12, 29, 581, 9, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 3, 31, 590, 8, 31, 1, 31, 3, 31, 593, 8, 31, 1, 32, 1, 32, 5, 32, 597,
		8, 32, 10, 32, 12, 32, 600, 9, 32, 1, 33, 3, 33, 603, 8, 33, 1, 33, 1,
		33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 3, 35, 614, 8, 35,
		1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 620, 8, 36, 10, 36, 12, 36, 623, 9,
		36, 3, 36, 625, 8, 36, 1, 36, 3, 36, 628, 8, 36, 1, 36, 1, 36, 1, 37, 1,
		37, 1, 38, 1, 38, 5, 38, 636, 8, 38, 10, 38, 12, 38, 639, 9, 38, 1, 38,
		1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 5, 40, 647, 8, 40, 10, 40, 12, 40, 650,
		9, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 3, 41, 675, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 3, 42, 682, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 4, 43, 689, 8,
		43, 11, 43, 12, 43, 690, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45,
		1, 45, 1, 45, 1, 45, 5, 45, 703, 8, 45, 10, 45, 12, 45, 706, 9, 45, 1,
		45, 1, 45, 1, 45, 3, 45, 711, 8, 45, 1, 46, 3, 46, 714, 8, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 725, 8, 46,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 733, 8, 47, 1, 48, 1,
		48, 1, 48, 1, 48, 3, 48, 739, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 50, 1, 50, 1, 50, 4, 50, 750, 8, 50, 11, 50, 12, 50, 751, 1,
		50, 3, 50, 755, 8, 50, 1, 50, 3, 50, 758, 8, 50, 1, 51, 1, 51, 3, 51, 762,
		8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1,
		54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1,
		59, 3, 59, 795, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		1, 61, 1, 61, 1, 61, 3, 61, 807, 8, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1,
		62, 1, 62, 1, 63, 5, 63, 816, 8, 63, 10, 63, 12, 63, 819, 9, 63, 1, 63,
		1, 63, 3, 63, 823, 8, 63, 1, 64, 1, 64, 1, 64, 3, 64, 828, 8, 64, 1, 65,
		1, 65, 1, 65, 3, 65, 833, 8, 65, 1, 66, 1, 66, 1, 66, 5, 66, 838, 8, 66,
		10, 66, 12, 66, 841, 9, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1,
		67, 1, 67, 1, 68, 1, 68, 3, 68, 853, 8, 68, 1, 68, 1, 68, 3, 68, 857, 8,
		68, 1, 68, 1, 68, 3, 68, 861, 8, 68, 3, 68, 863, 8, 68, 1, 69, 1, 69, 3,
		69, 867, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 5, 73, 883, 8, 73, 10, 73, 12,
		73, 886, 9, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3,
		74, 906, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 922, 8, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 3, 74, 928, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 962, 8, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 5, 74, 974,
		8, 74, 10, 74, 12, 74, 977, 9, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 989, 8, 75, 1, 76, 1, 76, 1, 76,
		3, 76, 994, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1001, 8, 76,
		1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1007, 8, 76, 1, 76, 3, 76, 1010, 8,
		76, 1, 77, 1, 77, 1, 77, 3, 77, 1015, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1025, 8, 78, 1, 79, 1, 79, 1, 79, 5,
		79, 1030, 8, 79, 10, 79, 12, 79, 1033, 9, 79, 1, 80, 1, 80, 1, 80, 1, 80,
		1, 80, 3, 80, 1040, 8, 80, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1054, 8, 83, 3, 83, 1056,
		8, 83, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1062, 8, 84, 10, 84, 12, 84,
		1065, 9, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1,
		86, 1, 86, 5, 86, 1077, 8, 86, 10, 86, 12, 86, 1080, 9, 86, 1, 86, 1, 86,
		1, 87, 1, 87, 3, 87, 1086, 8, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1,
		88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1099, 8, 89, 1, 89, 3, 89,
		1102, 8, 89, 1, 89, 3, 89, 1105, 8, 89, 1, 89, 3, 89, 1108, 8, 89, 1, 89,
		3, 89, 1111, 8, 89, 1, 89, 3, 89, 1114, 8, 89, 1, 89, 3, 89, 1117, 8, 89,
		1, 89, 3, 89, 1120, 8, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1125, 8, 89, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1132, 8, 90, 1, 90, 3, 90, 1135,
		8, 90, 1, 90, 3, 90, 1138, 8, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1143, 8,
		90, 1, 91, 1, 91, 1, 91, 5, 91, 1148, 8, 91, 10, 91, 12, 91, 1151, 9, 91,
		1, 92, 1, 92, 3, 92, 1155, 8, 92, 1, 92, 1, 92, 3, 92, 1159, 8, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 3, 92, 1165, 8, 92, 1, 92, 3, 92, 1168, 8, 92,
		1, 93, 1, 93, 1, 93, 5, 93, 1173, 8, 93, 10, 93, 12, 93, 1176, 9, 93, 1,
		94, 1, 94, 1, 94, 5, 94, 1181, 8, 94, 10, 94, 12, 94, 1184, 9, 94, 1, 95,
		1, 95, 3, 95, 1188, 8, 95, 1, 96, 1, 96, 1, 96, 5, 96, 1193, 8, 96, 10,
		96, 12, 96, 1196, 9, 96, 1, 97, 1, 97, 3, 97, 1200, 8, 97, 1, 97, 1, 97,
		3, 97, 1204, 8, 97, 1, 97, 3, 97, 1207, 8, 97, 1, 98, 1, 98, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1324, 8, 99, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1332, 8, 100, 1, 101, 1,
		101, 1, 101, 4, 101, 1337, 8, 101, 11, 101, 12, 101, 1338, 1, 101, 3, 101,
		1342, 8, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1,
		103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 5, 104, 1357, 8, 104, 10,
		104, 12, 104, 1360, 9, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1,
		106, 1, 106, 1, 107, 1, 107, 1, 107, 5, 107, 1372, 8, 107, 10, 107, 12,
		107, 1375, 9, 107, 1, 107, 1, 107, 1, 107, 5, 107, 1380, 8, 107, 10, 107,
		12, 107, 1383, 9, 107, 1, 107, 1, 107, 3, 107, 1387, 8, 107, 1, 108, 1,
		108, 1, 108, 1, 108, 1, 108, 3, 108, 1394, 8, 108, 1, 109, 1, 109, 1, 109,
		1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1404, 8, 109, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 1421, 8, 110, 1, 111, 1, 111,
		1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 3, 111,
		1433, 8, 111, 3, 111, 1435, 8, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1,
		111, 1, 111, 3, 111, 1443, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 5, 112,
		1449, 8, 112, 10, 112, 12, 112, 1452, 9, 112, 1, 112, 1, 112, 1, 113, 3,
		113, 1457, 8, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114,
		1, 114, 1, 114, 1, 114, 3, 114, 1469, 8, 114, 1, 115, 1, 115, 1, 115, 5,
		115, 1474, 8, 115, 10, 115, 12, 115, 1477, 9, 115, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 5, 117, 1488, 8, 117, 10,
		117, 12, 117, 1491, 9, 117, 1, 117, 1, 117, 3, 117, 1495, 8, 117, 1, 118,
		1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1504, 8, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 5, 119, 1513, 8, 119,
		10, 119, 12, 119, 1516, 9, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 5, 119, 1527, 8, 119, 10, 119, 12, 119,
		1530, 9, 119, 1, 119, 1, 119, 3, 119, 1534, 8, 119, 1, 120, 1, 120, 1,
		120, 1, 120, 1, 121, 1, 121, 1, 121, 5, 121, 1543, 8, 121, 10, 121, 12,
		121, 1546, 9, 121, 1, 122, 1, 122, 3, 122, 1550, 8, 122, 1, 122, 1, 122,
		3, 122, 1554, 8, 122, 1, 122, 1, 122, 3, 122, 1558, 8, 122, 1, 122, 1,
		122, 3, 122, 1562, 8, 122, 3, 122, 1564, 8, 122, 1, 123, 1, 123, 1, 123,
		1, 123, 3, 123, 1570, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1576,
		8, 124, 1, 125, 1, 125, 1, 125, 1, 126, 1, 126, 5, 126, 1583, 8, 126, 10,
		126, 12, 126, 1586, 9, 126, 1, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3,
		128, 1656, 8, 128, 1, 129, 3, 129, 1659, 8, 129, 1, 129, 1, 129, 1, 130,
		1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 3, 131, 1675, 8, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1,
		133, 1, 133, 3, 133, 1683, 8, 133, 1, 133, 1, 133, 3, 133, 1687, 8, 133,
		1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1693, 8, 133, 1, 133, 1, 133, 1,
		133, 1, 133, 3, 133, 1699, 8, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133,
		1, 133, 1, 133, 3, 133, 1708, 8, 133, 3, 133, 1710, 8, 133, 1, 133, 1,
		133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1719, 8, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 3, 133, 1725, 8, 133, 1, 133, 1, 133, 1, 133, 1,
		133, 3, 133, 1731, 8, 133, 1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1737,
		8, 133, 1, 133, 3, 133, 1740, 8, 133, 1, 133, 1, 133, 3, 133, 1744, 8,
		133, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 5, 135, 1752, 8, 135,
		10, 135, 12, 135, 1755, 9, 135, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136,
		3, 136, 1762, 8, 136, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 1768, 8,
		136, 1, 136, 1, 136, 1, 136, 3, 136, 1773, 8, 136, 1, 136, 3, 136, 1776,
		8, 136, 1, 136, 3, 136, 1779, 8, 136, 1, 136, 1, 136, 3, 136, 1783, 8,
		136, 1, 137, 1, 137, 1, 137, 5, 137, 1788, 8, 137, 10, 137, 12, 137, 1791,
		9, 137, 1, 138, 1, 138, 1, 138, 3, 138, 1796, 8, 138, 1, 139, 1, 139, 1,
		140, 1, 140, 1, 140, 3, 140, 1803, 8, 140, 1, 141, 1, 141, 1, 141, 5, 141,
		1808, 8, 141, 10, 141, 12, 141, 1811, 9, 141, 1, 142, 1, 142, 1, 143, 1,
		143, 1, 143, 0, 1, 148, 144, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
		24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
		60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
		96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
		126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
		156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
		186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214,
		216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244,
		246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274,
		276, 278, 280, 282, 284, 286, 0, 22, 1, 0, 2, 3, 3, 0, 8, 8, 21, 21, 45,
		46, 2, 0, 26, 26, 179, 183, 1, 0, 209, 212, 1, 0, 197, 198, 2, 0, 213,
		214, 218, 218, 1, 0, 211, 212, 1, 0, 195, 196, 1, 0, 202, 206, 2, 0, 194,
		194, 220, 230, 2, 0, 193, 193, 199, 199, 1, 0, 209, 210, 2, 0, 88, 88,
		107, 108, 2, 0, 179, 179, 181, 181, 1, 0, 97, 100, 1, 0, 82, 83, 1, 0,
		85, 86, 3, 0, 46, 46, 90, 90, 102, 102, 2, 0, 88, 88, 164, 167, 1, 0, 105,
		106, 12, 0, 2, 3, 16, 16, 20, 20, 22, 22, 34, 35, 38, 38, 42, 43, 51, 51,
		53, 54, 57, 159, 162, 176, 232, 232, 5, 0, 1, 32, 34, 48, 50, 159, 162,
		176, 232, 232, 2009, 0, 288, 1, 0, 0, 0, 2, 305, 1, 0, 0, 0, 4, 308, 1,
		0, 0, 0, 6, 332, 1, 0, 0, 0, 8, 334, 1, 0, 0, 0, 10, 346, 1, 0, 0, 0, 12,
		354, 1, 0, 0, 0, 14, 362, 1, 0, 0, 0, 16, 370, 1, 0, 0, 0, 18, 378, 1,
		0, 0, 0, 20, 387, 1, 0, 0, 0, 22, 408, 1, 0, 0, 0, 24, 429, 1, 0, 0, 0,
		26, 438, 1, 0, 0, 0, 28, 442, 1, 0, 0, 0, 30, 450, 1, 0, 0, 0, 32, 454,
		1, 0, 0, 0, 34, 458, 1, 0, 0, 0, 36, 472, 1, 0, 0, 0, 38, 483, 1, 0, 0,
		0, 40, 491, 1, 0, 0, 0, 42, 496, 1, 0, 0, 0, 44, 512, 1, 0, 0, 0, 46, 526,
		1, 0, 0, 0, 48, 545, 1, 0, 0, 0, 50, 547, 1, 0, 0, 0, 52, 551, 1, 0, 0,
		0, 54, 557, 1, 0, 0, 0, 56, 568, 1, 0, 0, 0, 58, 574, 1, 0, 0, 0, 60, 582,
		1, 0, 0, 0, 62, 584, 1, 0, 0, 0, 64, 594, 1, 0, 0, 0, 66, 602, 1, 0, 0,
		0, 68, 606, 1, 0, 0, 0, 70, 613, 1, 0, 0, 0, 72, 615, 1, 0, 0, 0, 74, 631,
		1, 0, 0, 0, 76, 633, 1, 0, 0, 0, 78, 642, 1, 0, 0, 0, 80, 648, 1, 0, 0,
		0, 82, 674, 1, 0, 0, 0, 84, 676, 1, 0, 0, 0, 86, 683, 1, 0, 0, 0, 88, 694,
		1, 0, 0, 0, 90, 710, 1, 0, 0, 0, 92, 724, 1, 0, 0, 0, 94, 726, 1, 0, 0,
		0, 96, 734, 1, 0, 0, 0, 98, 740, 1, 0, 0, 0, 100, 746, 1, 0, 0, 0, 102,
		759, 1, 0, 0, 0, 104, 765, 1, 0, 0, 0, 106, 769, 1, 0, 0, 0, 108, 772,
		1, 0, 0, 0, 110, 775, 1, 0, 0, 0, 112, 779, 1, 0, 0, 0, 114, 783, 1, 0,
		0, 0, 116, 787, 1, 0, 0, 0, 118, 791, 1, 0, 0, 0, 120, 798, 1, 0, 0, 0,
		122, 803, 1, 0, 0, 0, 124, 811, 1, 0, 0, 0, 126, 817, 1, 0, 0, 0, 128,
		824, 1, 0, 0, 0, 130, 829, 1, 0, 0, 0, 132, 834, 1, 0, 0, 0, 134, 847,
		1, 0, 0, 0, 136, 862, 1, 0, 0, 0, 138, 866, 1, 0, 0, 0, 140, 868, 1, 0,
		0, 0, 142, 873, 1, 0, 0, 0, 144, 875, 1, 0, 0, 0, 146, 879, 1, 0, 0, 0,
		148, 905, 1, 0, 0, 0, 150, 988, 1, 0, 0, 0, 152, 1009, 1, 0, 0, 0, 154,
		1011, 1, 0, 0, 0, 156, 1018, 1, 0, 0, 0, 158, 1026, 1, 0, 0, 0, 160, 1034,
		1, 0, 0, 0, 162, 1041, 1, 0, 0, 0, 164, 1044, 1, 0, 0, 0, 166, 1055, 1,
		0, 0, 0, 168, 1057, 1, 0, 0, 0, 170, 1068, 1, 0, 0, 0, 172, 1072, 1, 0,
		0, 0, 174, 1083, 1, 0, 0, 0, 176, 1089, 1, 0, 0, 0, 178, 1093, 1, 0, 0,
		0, 180, 1126, 1, 0, 0, 0, 182, 1144, 1, 0, 0, 0, 184, 1167, 1, 0, 0, 0,
		186, 1169, 1, 0, 0, 0, 188, 1177, 1, 0, 0, 0, 190, 1185, 1, 0, 0, 0, 192,
		1189, 1, 0, 0, 0, 194, 1206, 1, 0, 0, 0, 196, 1208, 1, 0, 0, 0, 198, 1323,
		1, 0, 0, 0, 200, 1331, 1, 0, 0, 0, 202, 1333, 1, 0, 0, 0, 204, 1345, 1,
		0, 0, 0, 206, 1350, 1, 0, 0, 0, 208, 1353, 1, 0, 0, 0, 210, 1361, 1, 0,
		0, 0, 212, 1365, 1, 0, 0, 0, 214, 1386, 1, 0, 0, 0, 216, 1393, 1, 0, 0,
		0, 218, 1403, 1, 0, 0, 0, 220, 1420, 1, 0, 0, 0, 222, 1442, 1, 0, 0, 0,
		224, 1444, 1, 0, 0, 0, 226, 1456, 1, 0, 0, 0, 228, 1468, 1, 0, 0, 0, 230,
		1470, 1, 0, 0, 0, 232, 1478, 1, 0, 0, 0, 234, 1494, 1, 0, 0, 0, 236, 1496,
		1, 0, 0, 0, 238, 1533, 1, 0, 0, 0, 240, 1535, 1, 0, 0, 0, 242, 1539, 1,
		0, 0, 0, 244, 1563, 1, 0, 0, 0, 246, 1569, 1, 0, 0, 0, 248, 1575, 1, 0,
		0, 0, 250, 1577, 1, 0, 0, 0, 252, 1584, 1, 0, 0, 0, 254, 1587, 1, 0, 0,
		0, 256, 1655, 1, 0, 0, 0, 258, 1658, 1, 0, 0, 0, 260, 1662, 1, 0, 0, 0,
		262, 1674, 1, 0, 0, 0, 264, 1676, 1, 0, 0, 0, 266, 1682, 1, 0, 0, 0, 268,
		1745, 1, 0, 0, 0, 270, 1748, 1, 0, 0, 0, 272, 1756, 1, 0, 0, 0, 274, 1784,
		1, 0, 0, 0, 276, 1792, 1, 0, 0, 0, 278, 1797, 1, 0, 0, 0, 280, 1799, 1,
		0, 0, 0, 282, 1804, 1, 0, 0, 0, 284, 1812, 1, 0, 0, 0, 286, 1814, 1, 0,
		0, 0, 288, 289, 5, 43, 0, 0, 289, 290, 3, 284, 142, 0, 290, 291, 5, 27,
		0, 0, 291, 292, 3, 284, 142, 0, 292, 293, 5, 185, 0, 0, 293, 298, 3, 2,
		1, 0, 294, 295, 5, 192, 0, 0, 295, 297, 3, 2, 1, 0, 296, 294, 1, 0, 0,
		0, 297, 300, 1, 0, 0, 0, 298, 296, 1, 0, 0, 0, 298, 299, 1, 0, 0, 0, 299,
		301, 1, 0, 0, 0, 300, 298, 1, 0, 0, 0, 301, 302, 5, 186, 0, 0, 302, 303,
		3, 76, 38, 0, 303, 304, 5, 0, 0, 1, 304, 1, 1, 0, 0, 0, 305, 306, 7, 0,
		0, 0, 306, 307, 7, 1, 0, 0, 307, 3, 1, 0, 0, 0, 308, 309, 3, 6, 3, 0, 309,
		310, 5, 0, 0, 1, 310, 5, 1, 0, 0, 0, 311, 313, 3, 24, 12, 0, 312, 311,
		1, 0, 0, 0, 313, 316, 1, 0, 0, 0, 314, 312, 1, 0, 0, 0, 314, 315, 1, 0,
		0, 0, 315, 317, 1, 0, 0, 0, 316, 314, 1, 0, 0, 0, 317, 333, 3, 8, 4, 0,
		318, 320, 3, 24, 12, 0, 319, 318, 1, 0, 0, 0, 320, 323, 1, 0, 0, 0, 321,
		319, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 324, 1, 0, 0, 0, 323, 321,
		1, 0, 0, 0, 324, 333, 3, 10, 5, 0, 325, 327, 3, 24, 12, 0, 326, 325, 1,
		0, 0, 0, 327, 330, 1, 0, 0, 0, 328, 326, 1, 0, 0, 0, 328, 329, 1, 0, 0,
		0, 329, 331, 1, 0, 0, 0, 330, 328, 1, 0, 0, 0, 331, 333, 3, 14, 7, 0, 332,
		314, 1, 0, 0, 0, 332, 321, 1, 0, 0, 0, 332, 328, 1, 0, 0, 0, 333, 7, 1,
		0, 0, 0, 334, 335, 5, 6, 0, 0, 335, 338, 3, 284, 142, 0, 336, 337, 5, 12,
		0, 0, 337, 339, 3, 44, 22, 0, 338, 336, 1, 0, 0, 0, 338, 339, 1, 0, 0,
		0, 339, 342, 1, 0, 0, 0, 340, 341, 5, 19, 0, 0, 341, 343, 3, 16, 8, 0,
		342, 340, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344,
		345, 3, 18, 9, 0, 345, 9, 1, 0, 0, 0, 346, 347, 5, 11, 0, 0, 347, 348,
		3, 284, 142, 0, 348, 350, 5, 187, 0, 0, 349, 351, 3, 12, 6, 0, 350, 349,
		1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 352, 1, 0, 0, 0, 352, 353, 5, 188,
		0, 0, 353, 11, 1, 0, 0, 0, 354, 359, 3, 284, 142, 0, 355, 356, 5, 192,
		0, 0, 356, 358, 3, 284, 142, 0, 357, 355, 1, 0, 0, 0, 358, 361, 1, 0, 0,
		0, 359, 357, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 13, 1, 0, 0, 0, 361,
		359, 1, 0, 0, 0, 362, 363, 5, 23, 0, 0, 363, 366, 3, 284, 142, 0, 364,
		365, 5, 12, 0, 0, 365, 367, 3, 16, 8, 0, 366, 364, 1, 0, 0, 0, 366, 367,
		1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 369, 3, 20, 10, 0, 369, 15, 1, 0,
		0, 0, 370, 375, 3, 44, 22, 0, 371, 372, 5, 192, 0, 0, 372, 374, 3, 44,
		22, 0, 373, 371, 1, 0, 0, 0, 374, 377, 1, 0, 0, 0, 375, 373, 1, 0, 0, 0,
		375, 376, 1, 0, 0, 0, 376, 17, 1, 0, 0, 0, 377, 375, 1, 0, 0, 0, 378, 382,
		5, 187, 0, 0, 379, 381, 3, 22, 11, 0, 380, 379, 1, 0, 0, 0, 381, 384, 1,
		0, 0, 0, 382, 380, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 385, 1, 0, 0,
		0, 384, 382, 1, 0, 0, 0, 385, 386, 5, 188, 0, 0, 386, 19, 1, 0, 0, 0, 387,
		391, 5, 187, 0, 0, 388, 390, 3, 36, 18, 0, 389, 388, 1, 0, 0, 0, 390, 393,
		1, 0, 0, 0, 391, 389, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392, 394, 1, 0,
		0, 0, 393, 391, 1, 0, 0, 0, 394, 395, 5, 188, 0, 0, 395, 21, 1, 0, 0, 0,
		396, 409, 5, 191, 0, 0, 397, 399, 5, 36, 0, 0, 398, 397, 1, 0, 0, 0, 398,
		399, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 409, 3, 76, 38, 0, 401, 403,
		3, 24, 12, 0, 402, 401, 1, 0, 0, 0, 403, 406, 1, 0, 0, 0, 404, 402, 1,
		0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 407, 1, 0, 0, 0, 406, 404, 1, 0, 0,
		0, 407, 409, 3, 26, 13, 0, 408, 396, 1, 0, 0, 0, 408, 398, 1, 0, 0, 0,
		408, 404, 1, 0, 0, 0, 409, 23, 1, 0, 0, 0, 410, 430, 3, 62, 31, 0, 411,
		430, 5, 17, 0, 0, 412, 430, 5, 31, 0, 0, 413, 430, 5, 30, 0, 0, 414, 430,
		5, 29, 0, 0, 415, 430, 5, 42, 0, 0, 416, 430, 5, 36, 0, 0, 417, 430, 5,
		1, 0, 0, 418, 430, 5, 13, 0, 0, 419, 430, 5, 50, 0, 0, 420, 430, 5, 28,
		0, 0, 421, 430, 5, 48, 0, 0, 422, 430, 5, 39, 0, 0, 423, 424, 5, 53, 0,
		0, 424, 430, 5, 35, 0, 0, 425, 426, 5, 54, 0, 0, 426, 430, 5, 35, 0, 0,
		427, 428, 5, 20, 0, 0, 428, 430, 5, 35, 0, 0, 429, 410, 1, 0, 0, 0, 429,
		411, 1, 0, 0, 0, 429, 412, 1, 0, 0, 0, 429, 413, 1, 0, 0, 0, 429, 414,
		1, 0, 0, 0, 429, 415, 1, 0, 0, 0, 429, 416, 1, 0, 0, 0, 429, 417, 1, 0,
		0, 0, 429, 418, 1, 0, 0, 0, 429, 419, 1, 0, 0, 0, 429, 420, 1, 0, 0, 0,
		429, 421, 1, 0, 0, 0, 429, 422, 1, 0, 0, 0, 429, 423, 1, 0, 0, 0, 429,
		425, 1, 0, 0, 0, 429, 427, 1, 0, 0, 0, 430, 25, 1, 0, 0, 0, 431, 439, 3,
		28, 14, 0, 432, 439, 3, 32, 16, 0, 433, 439, 3, 30, 15, 0, 434, 439, 3,
		14, 7, 0, 435, 439, 3, 8, 4, 0, 436, 439, 3, 10, 5, 0, 437, 439, 3, 34,
		17, 0, 438, 431, 1, 0, 0, 0, 438, 432, 1, 0, 0, 0, 438, 433, 1, 0, 0, 0,
		438, 434, 1, 0, 0, 0, 438, 435, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 438,
		437, 1, 0, 0, 0, 439, 27, 1, 0, 0, 0, 440, 443, 3, 44, 22, 0, 441, 443,
		5, 49, 0, 0, 442, 440, 1, 0, 0, 0, 442, 441, 1, 0, 0, 0, 443, 444, 1, 0,
		0, 0, 444, 445, 3, 284, 142, 0, 445, 448, 3, 52, 26, 0, 446, 449, 3, 76,
		38, 0, 447, 449, 5, 191, 0, 0, 448, 446, 1, 0, 0, 0, 448, 447, 1, 0, 0,
		0, 449, 29, 1, 0, 0, 0, 450, 451, 3, 58, 29, 0, 451, 452, 3, 52, 26, 0,
		452, 453, 3, 76, 38, 0, 453, 31, 1, 0, 0, 0, 454, 455, 3, 44, 22, 0, 455,
		456, 3, 38, 19, 0, 456, 457, 5, 191, 0, 0, 457, 33, 1, 0, 0, 0, 458, 459,
		3, 44, 22, 0, 459, 460, 3, 284, 142, 0, 460, 464, 5, 187, 0, 0, 461, 463,
		3, 126, 63, 0, 462, 461, 1, 0, 0, 0, 463, 466, 1, 0, 0, 0, 464, 462, 1,
		0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 467, 1, 0, 0, 0, 466, 464, 1, 0, 0,
		0, 467, 468, 5, 188, 0, 0, 468, 35, 1, 0, 0, 0, 469, 471, 3, 24, 12, 0,
		470, 469, 1, 0, 0, 0, 471, 474, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472,
		473, 1, 0, 0, 0, 473, 477, 1, 0, 0, 0, 474, 472, 1, 0, 0, 0, 475, 478,
		3, 44, 22, 0, 476, 478, 5, 49, 0, 0, 477, 475, 1, 0, 0, 0, 477, 476, 1,
		0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 480, 3, 284, 142, 0, 480, 481, 3, 52,
		26, 0, 481, 482, 5, 191, 0, 0, 482, 37, 1, 0, 0, 0, 483, 488, 3, 40, 20,
		0, 484, 485, 5, 192, 0, 0, 485, 487, 3, 40, 20, 0, 486, 484, 1, 0, 0, 0,
		487, 490, 1, 0, 0, 0, 488, 486, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489,
		39, 1, 0, 0, 0, 490, 488, 1, 0, 0, 0, 491, 494, 3, 284, 142, 0, 492, 493,
		5, 194, 0, 0, 493, 495, 3, 148, 74, 0, 494, 492, 1, 0, 0, 0, 494, 495,
		1, 0, 0, 0, 495, 41, 1, 0, 0, 0, 496, 508, 5, 187, 0, 0, 497, 502, 3, 148,
		74, 0, 498, 499, 5, 192, 0, 0, 499, 501, 3, 148, 74, 0, 500, 498, 1, 0,
		0, 0, 501, 504, 1, 0, 0, 0, 502, 500, 1, 0, 0, 0, 502, 503, 1, 0, 0, 0,
		503, 506, 1, 0, 0, 0, 504, 502, 1, 0, 0, 0, 505, 507, 5, 192, 0, 0, 506,
		505, 1, 0, 0, 0, 506, 507, 1, 0, 0, 0, 507, 509, 1, 0, 0, 0, 508, 497,
		1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509, 510, 1, 0, 0, 0, 510, 511, 5, 188,
		0, 0, 511, 43, 1, 0, 0, 0, 512, 517, 3, 48, 24, 0, 513, 514, 5, 193, 0,
		0, 514, 516, 3, 48, 24, 0, 515, 513, 1, 0, 0, 0, 516, 519, 1, 0, 0, 0,
		517, 515, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 520, 1, 0, 0, 0, 519,
		517, 1, 0, 0, 0, 520, 521, 3, 46, 23, 0, 521, 45, 1, 0, 0, 0, 522, 523,
		5, 189, 0, 0, 523, 525, 5, 190, 0, 0, 524, 522, 1, 0, 0, 0, 525, 528, 1,
		0, 0, 0, 526, 524, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 47, 1, 0, 0,
		0, 528, 526, 1, 0, 0, 0, 529, 531, 5, 55, 0, 0, 530, 532, 3, 50, 25, 0,
		531, 530, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 546, 1, 0, 0, 0, 533,
		535, 5, 34, 0, 0, 534, 536, 3, 50, 25, 0, 535, 534, 1, 0, 0, 0, 535, 536,
		1, 0, 0, 0, 536, 546, 1, 0, 0, 0, 537, 539, 5, 56, 0, 0, 538, 540, 3, 50,
		25, 0, 539, 538, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 546, 1, 0, 0, 0,
		541, 543, 3, 284, 142, 0, 542, 544, 3, 50, 25, 0, 543, 542, 1, 0, 0, 0,
		543, 544, 1, 0, 0, 0, 544, 546, 1, 0, 0, 0, 545, 529, 1, 0, 0, 0, 545,
		533, 1, 0, 0, 0, 545, 537, 1, 0, 0, 0, 545, 541, 1, 0, 0, 0, 546, 49, 1,
		0, 0, 0, 547, 548, 5, 196, 0, 0, 548, 549, 3, 16, 8, 0, 549, 550, 5, 195,
		0, 0, 550, 51, 1, 0, 0, 0, 551, 553, 5, 185, 0, 0, 552, 554, 3, 54, 27,
		0, 553, 552, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555,
		556, 5, 186, 0, 0, 556, 53, 1, 0, 0, 0, 557, 562, 3, 56, 28, 0, 558, 559,
		5, 192, 0, 0, 559, 561, 3, 56, 28, 0, 560, 558, 1, 0, 0, 0, 561, 564, 1,
		0, 0, 0, 562, 560, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 55, 1, 0, 0,
		0, 564, 562, 1, 0, 0, 0, 565, 567, 3, 24, 12, 0, 566, 565, 1, 0, 0, 0,
		567, 570, 1, 0, 0, 0, 568, 566, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569,
		571, 1, 0, 0, 0, 570, 568, 1, 0, 0, 0, 571, 572, 3, 44, 22, 0, 572, 573,
		3, 284, 142, 0, 573, 57, 1, 0, 0, 0, 574, 579, 3, 284, 142, 0, 575, 576,
		5, 193, 0, 0, 576, 578, 3, 284, 142, 0, 577, 575, 1, 0, 0, 0, 578, 581,
		1, 0, 0, 0, 579, 577, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 59, 1, 0,
		0, 0, 581, 579, 1, 0, 0, 0, 582, 583, 7, 2, 0, 0, 583, 61, 1, 0, 0, 0,
		584, 585, 5, 231, 0, 0, 585, 592, 3, 58, 29, 0, 586, 589, 5, 185, 0, 0,
		587, 590, 3, 64, 32, 0, 588, 590, 3, 70, 35, 0, 589, 587, 1, 0, 0, 0, 589,
		588, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 593,
		5, 186, 0, 0, 592, 586, 1, 0, 0, 0, 592, 593, 1, 0, 0, 0, 593, 63, 1, 0,
		0, 0, 594, 598, 3, 68, 34, 0, 595, 597, 3, 66, 33, 0, 596, 595, 1, 0, 0,
		0, 597, 600, 1, 0, 0, 0, 598, 596, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599,
		65, 1, 0, 0, 0, 600, 598, 1, 0, 0, 0, 601, 603, 5, 192, 0, 0, 602, 601,
		1, 0, 0, 0, 602, 603, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 605, 3, 68,
		34, 0, 605, 67, 1, 0, 0, 0, 606, 607, 3, 284, 142, 0, 607, 608, 5, 194,
		0, 0, 608, 609, 3, 70, 35, 0, 609, 69, 1, 0, 0, 0, 610, 614, 3, 148, 74,
		0, 611, 614, 3, 62, 31, 0, 612, 614, 3, 72, 36, 0, 613, 610, 1, 0, 0, 0,
		613, 611, 1, 0, 0, 0, 613, 612, 1, 0, 0, 0, 614, 71, 1, 0, 0, 0, 615, 624,
		5, 187, 0, 0, 616, 621, 3, 70, 35, 0, 617, 618, 5, 192, 0, 0, 618, 620,
		3, 70, 35, 0, 619, 617, 1, 0, 0, 0, 620, 623, 1, 0, 0, 0, 621, 619, 1,
		0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 625, 1, 0, 0, 0, 623, 621, 1, 0, 0,
		0, 624, 616, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 627, 1, 0, 0, 0, 626,
		628, 3, 74, 37, 0, 627, 626, 1, 0, 0, 0, 627, 628, 1, 0, 0, 0, 628, 629,
		1, 0, 0, 0, 629, 630, 5, 188, 0, 0, 630, 73, 1, 0, 0, 0, 631, 632, 5, 192,
		0, 0, 632, 75, 1, 0, 0, 0, 633, 637, 5, 187, 0, 0, 634, 636, 3, 82, 41,
		0, 635, 634, 1, 0, 0, 0, 636, 639, 1, 0, 0, 0, 637, 635, 1, 0, 0, 0, 637,
		638, 1, 0, 0, 0, 638, 640, 1, 0, 0, 0, 639, 637, 1, 0, 0, 0, 640, 641,
		5, 188, 0, 0, 641, 77, 1, 0, 0, 0, 642, 643, 3, 80, 40, 0, 643, 644, 5,
		191, 0, 0, 644, 79, 1, 0, 0, 0, 645, 647, 3, 24, 12, 0, 646, 645, 1, 0,
		0, 0, 647, 650, 1, 0, 0, 0, 648, 646, 1, 0, 0, 0, 648, 649, 1, 0, 0, 0,
		649, 651, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 651, 652, 3, 44, 22, 0, 652,
		653, 3, 38, 19, 0, 653, 81, 1, 0, 0, 0, 654, 675, 3, 76, 38, 0, 655, 675,
		3, 84, 42, 0, 656, 675, 3, 86, 43, 0, 657, 675, 3, 94, 47, 0, 658, 675,
		3, 96, 48, 0, 659, 675, 3, 98, 49, 0, 660, 675, 3, 100, 50, 0, 661, 675,
		3, 102, 51, 0, 662, 675, 3, 104, 52, 0, 663, 675, 3, 106, 53, 0, 664, 675,
		3, 108, 54, 0, 665, 675, 3, 110, 55, 0, 666, 675, 3, 112, 56, 0, 667, 675,
		3, 114, 57, 0, 668, 675, 3, 116, 58, 0, 669, 675, 3, 118, 59, 0, 670, 675,
		3, 120, 60, 0, 671, 675, 3, 122, 61, 0, 672, 675, 3, 78, 39, 0, 673, 675,
		3, 124, 62, 0, 674, 654, 1, 0, 0, 0, 674, 655, 1, 0, 0, 0, 674, 656, 1,
		0, 0, 0, 674, 657, 1, 0, 0, 0, 674, 658, 1, 0, 0, 0, 674, 659, 1, 0, 0,
		0, 674, 660, 1, 0, 0, 0, 674, 661, 1, 0, 0, 0, 674, 662, 1, 0, 0, 0, 674,
		663, 1, 0, 0, 0, 674, 664, 1, 0, 0, 0, 674, 665, 1, 0, 0, 0, 674, 666,
		1, 0, 0, 0, 674, 667, 1, 0, 0, 0, 674, 668, 1, 0, 0, 0, 674, 669, 1, 0,
		0, 0, 674, 670, 1, 0, 0, 0, 674, 671, 1, 0, 0, 0, 674, 672, 1, 0, 0, 0,
		674, 673, 1, 0, 0, 0, 675, 83, 1, 0, 0, 0, 676, 677, 5, 18, 0, 0, 677,
		678, 3, 144, 72, 0, 678, 681, 3, 82, 41, 0, 679, 680, 5, 10, 0, 0, 680,
		682, 3, 82, 41, 0, 681, 679, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 85,
		1, 0, 0, 0, 683, 684, 5, 38, 0, 0, 684, 685, 5, 27, 0, 0, 685, 686, 3,
		148, 74, 0, 686, 688, 5, 187, 0, 0, 687, 689, 3, 88, 44, 0, 688, 687, 1,
		0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 688, 1, 0, 0, 0, 690, 691, 1, 0, 0,
		0, 691, 692, 1, 0, 0, 0, 692, 693, 5, 188, 0, 0, 693, 87, 1, 0, 0, 0, 694,
		695, 5, 51, 0, 0, 695, 696, 3, 90, 45, 0, 696, 697, 3, 76, 38, 0, 697,
		89, 1, 0, 0, 0, 698, 711, 5, 10, 0, 0, 699, 704, 3, 92, 46, 0, 700, 701,
		5, 192, 0, 0, 701, 703, 3, 92, 46, 0, 702, 700, 1, 0, 0, 0, 703, 706, 1,
		0, 0, 0, 704, 702, 1, 0, 0, 0, 704, 705, 1, 0, 0, 0, 705, 711, 1, 0, 0,
		0, 706, 704, 1, 0, 0, 0, 707, 708, 3, 284, 142, 0, 708, 709, 3, 284, 142,
		0, 709, 711, 1, 0, 0, 0, 710, 698, 1, 0, 0, 0, 710, 699, 1, 0, 0, 0, 710,
		707, 1, 0, 0, 0, 711, 91, 1, 0, 0, 0, 712, 714, 5, 212, 0, 0, 713, 712,
		1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 725, 5, 179,
		0, 0, 716, 725, 5, 180, 0, 0, 717, 725, 5, 183, 0, 0, 718, 725, 5, 26,
		0, 0, 719, 725, 3, 284, 142, 0, 720, 721, 5, 185, 0, 0, 721, 722, 3, 92,
		46, 0, 722, 723, 5, 186, 0, 0, 723, 725, 1, 0, 0, 0, 724, 713, 1, 0, 0,
		0, 724, 716, 1, 0, 0, 0, 724, 717, 1, 0, 0, 0, 724, 718, 1, 0, 0, 0, 724,
		719, 1, 0, 0, 0, 724, 720, 1, 0, 0, 0, 725, 93, 1, 0, 0, 0, 726, 727, 5,
		15, 0, 0, 727, 728, 5, 185, 0, 0, 728, 729, 3, 136, 68, 0, 729, 732, 5,
		186, 0, 0, 730, 733, 3, 82, 41, 0, 731, 733, 5, 191, 0, 0, 732, 730, 1,
		0, 0, 0, 732, 731, 1, 0, 0, 0, 733, 95, 1, 0, 0, 0, 734, 735, 5, 52, 0,
		0, 735, 738, 3, 144, 72, 0, 736, 739, 3, 82, 41, 0, 737, 739, 5, 191, 0,
		0, 738, 736, 1, 0, 0, 0, 738, 737, 1, 0, 0, 0, 739, 97, 1, 0, 0, 0, 740,
		741, 5, 9, 0, 0, 741, 742, 3, 82, 41, 0, 742, 743, 5, 52, 0, 0, 743, 744,
		3, 144, 72, 0, 744, 745, 5, 191, 0, 0, 745, 99, 1, 0, 0, 0, 746, 747, 5,
		44, 0, 0, 747, 757, 3, 76, 38, 0, 748, 750, 3, 132, 66, 0, 749, 748, 1,
		0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 749, 1, 0, 0, 0, 751, 752, 1, 0, 0,
		0, 752, 754, 1, 0, 0, 0, 753, 755, 3, 134, 67, 0, 754, 753, 1, 0, 0, 0,
		754, 755, 1, 0, 0, 0, 755, 758, 1, 0, 0, 0, 756, 758, 3, 134, 67, 0, 757,
		749, 1, 0, 0, 0, 757, 756, 1, 0, 0, 0, 758, 101, 1, 0, 0, 0, 759, 761,
		5, 32, 0, 0, 760, 762, 3, 148, 74, 0, 761, 760, 1, 0, 0, 0, 761, 762, 1,
		0, 0, 0, 762, 763, 1, 0, 0, 0, 763, 764, 5, 191, 0, 0, 764, 103, 1, 0,
		0, 0, 765, 766, 5, 41, 0, 0, 766, 767, 3, 148, 74, 0, 767, 768, 5, 191,
		0, 0, 768, 105, 1, 0, 0, 0, 769, 770, 5, 4, 0, 0, 770, 771, 5, 191, 0,
		0, 771, 107, 1, 0, 0, 0, 772, 773, 5, 7, 0, 0, 773, 774, 5, 191, 0, 0,
		774, 109, 1, 0, 0, 0, 775, 776, 5, 21, 0, 0, 776, 777, 3, 148, 74, 0, 777,
		778, 5, 191, 0, 0, 778, 111, 1, 0, 0, 0, 779, 780, 5, 46, 0, 0, 780, 781,
		3, 148, 74, 0, 781, 782, 5, 191, 0, 0, 782, 113, 1, 0, 0, 0, 783, 784,
		5, 8, 0, 0, 784, 785, 3, 148, 74, 0, 785, 786, 5, 191, 0, 0, 786, 115,
		1, 0, 0, 0, 787, 788, 5, 45, 0, 0, 788, 789, 3, 148, 74, 0, 789, 790, 5,
		191, 0, 0, 790, 117, 1, 0, 0, 0, 791, 792, 5, 47, 0, 0, 792, 794, 3, 148,
		74, 0, 793, 795, 3, 58, 29, 0, 794, 793, 1, 0, 0, 0, 794, 795, 1, 0, 0,
		0, 795, 796, 1, 0, 0, 0, 796, 797, 5, 191, 0, 0, 797, 119, 1, 0, 0, 0,
		798, 799, 5, 24, 0, 0, 799, 800, 3, 148, 74, 0, 800, 801, 3, 148, 74, 0,
		801, 802, 5, 191, 0, 0, 802, 121, 1, 0, 0, 0, 803, 804, 5, 33, 0, 0, 804,
		806, 5, 185, 0, 0, 805, 807, 3, 146, 73, 0, 806, 805, 1, 0, 0, 0, 806,
		807, 1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 808, 809, 5, 186, 0, 0, 809, 810,
		3, 76, 38, 0, 810, 123, 1, 0, 0, 0, 811, 812, 3, 148, 74, 0, 812, 813,
		5, 191, 0, 0, 813, 125, 1, 0, 0, 0, 814, 816, 3, 24, 12, 0, 815, 814, 1,
		0, 0, 0, 816, 819, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0, 817, 818, 1, 0, 0,
		0, 818, 822, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 820, 823, 3, 128, 64, 0,
		821, 823, 3, 130, 65, 0, 822, 820, 1, 0, 0, 0, 822, 821, 1, 0, 0, 0, 823,
		127, 1, 0, 0, 0, 824, 827, 5, 16, 0, 0, 825, 828, 5, 191, 0, 0, 826, 828,
		3, 76, 38, 0, 827, 825, 1, 0, 0, 0, 827, 826, 1, 0, 0, 0, 828, 129, 1,
		0, 0, 0, 829, 832, 5, 34, 0, 0, 830, 833, 5, 191, 0, 0, 831, 833, 3, 76,
		38, 0, 832, 830, 1, 0, 0, 0, 832, 831, 1, 0, 0, 0, 833, 131, 1, 0, 0, 0,
		834, 835, 5, 5, 0, 0, 835, 839, 5, 185, 0, 0, 836, 838, 3, 24, 12, 0, 837,
		836, 1, 0, 0, 0, 838, 841, 1, 0, 0, 0, 839, 837, 1, 0, 0, 0, 839, 840,
		1, 0, 0, 0, 840, 842, 1, 0, 0, 0, 841, 839, 1, 0, 0, 0, 842, 843, 3, 58,
		29, 0, 843, 844, 3, 284, 142, 0, 844, 845, 5, 186, 0, 0, 845, 846, 3, 76,
		38, 0, 846, 133, 1, 0, 0, 0, 847, 848, 5, 14, 0, 0, 848, 849, 3, 76, 38,
		0, 849, 135, 1, 0, 0, 0, 850, 863, 3, 140, 70, 0, 851, 853, 3, 138, 69,
		0, 852, 851, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854,
		856, 5, 191, 0, 0, 855, 857, 3, 148, 74, 0, 856, 855, 1, 0, 0, 0, 856,
		857, 1, 0, 0, 0, 857, 858, 1, 0, 0, 0, 858, 860, 5, 191, 0, 0, 859, 861,
		3, 142, 71, 0, 860, 859, 1, 0, 0, 0, 860, 861, 1, 0, 0, 0, 861, 863, 1,
		0, 0, 0, 862, 850, 1, 0, 0, 0, 862, 852, 1, 0, 0, 0, 863, 137, 1, 0, 0,
		0, 864, 867, 3, 80, 40, 0, 865, 867, 3, 146, 73, 0, 866, 864, 1, 0, 0,
		0, 866, 865, 1, 0, 0, 0, 867, 139, 1, 0, 0, 0, 868, 869, 3, 44, 22, 0,
		869, 870, 3, 284, 142, 0, 870, 871, 5, 201, 0, 0, 871, 872, 3, 148, 74,
		0, 872, 141, 1, 0, 0, 0, 873, 874, 3, 146, 73, 0, 874, 143, 1, 0, 0, 0,
		875, 876, 5, 185, 0, 0, 876, 877, 3, 148, 74, 0, 877, 878, 5, 186, 0, 0,
		878, 145, 1, 0, 0, 0, 879, 884, 3, 148, 74, 0, 880, 881, 5, 192, 0, 0,
		881, 883, 3, 148, 74, 0, 882, 880, 1, 0, 0, 0, 883, 886, 1, 0, 0, 0, 884,
		882, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885, 147, 1, 0, 0, 0, 886, 884,
		1, 0, 0, 0, 887, 888, 6, 74, -1, 0, 888, 906, 3, 150, 75, 0, 889, 906,
		3, 152, 76, 0, 890, 891, 5, 25, 0, 0, 891, 906, 3, 156, 78, 0, 892, 893,
		5, 185, 0, 0, 893, 894, 3, 44, 22, 0, 894, 895, 5, 186, 0, 0, 895, 896,
		3, 148, 74, 18, 896, 906, 1, 0, 0, 0, 897, 898, 5, 185, 0, 0, 898, 899,
		3, 148, 74, 0, 899, 900, 5, 186, 0, 0, 900, 906, 1, 0, 0, 0, 901, 902,
		7, 3, 0, 0, 902, 906, 3, 148, 74, 15, 903, 904, 7, 4, 0, 0, 904, 906, 3,
		148, 74, 14, 905, 887, 1, 0, 0, 0, 905, 889, 1, 0, 0, 0, 905, 890, 1, 0,
		0, 0, 905, 892, 1, 0, 0, 0, 905, 897, 1, 0, 0, 0, 905, 901, 1, 0, 0, 0,
		905, 903, 1, 0, 0, 0, 906, 975, 1, 0, 0, 0, 907, 908, 10, 13, 0, 0, 908,
		909, 7, 5, 0, 0, 909, 974, 3, 148, 74, 14, 910, 911, 10, 12, 0, 0, 911,
		912, 7, 6, 0, 0, 912, 974, 3, 148, 74, 13, 913, 921, 10, 11, 0, 0, 914,
		915, 5, 196, 0, 0, 915, 922, 5, 196, 0, 0, 916, 917, 5, 195, 0, 0, 917,
		918, 5, 195, 0, 0, 918, 922, 5, 195, 0, 0, 919, 920, 5, 195, 0, 0, 920,
		922, 5, 195, 0, 0, 921, 914, 1, 0, 0, 0, 921, 916, 1, 0, 0, 0, 921, 919,
		1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 974, 3, 148, 74, 12, 924, 925, 10,
		10, 0, 0, 925, 927, 7, 7, 0, 0, 926, 928, 5, 194, 0, 0, 927, 926, 1, 0,
		0, 0, 927, 928, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929, 974, 3, 148, 74,
		11, 930, 931, 10, 8, 0, 0, 931, 932, 7, 8, 0, 0, 932, 974, 3, 148, 74,
		9, 933, 934, 10, 7, 0, 0, 934, 935, 5, 215, 0, 0, 935, 974, 3, 148, 74,
		8, 936, 937, 10, 6, 0, 0, 937, 938, 5, 217, 0, 0, 938, 974, 3, 148, 74,
		7, 939, 940, 10, 5, 0, 0, 940, 941, 5, 216, 0, 0, 941, 974, 3, 148, 74,
		6, 942, 943, 10, 4, 0, 0, 943, 944, 5, 207, 0, 0, 944, 974, 3, 148, 74,
		5, 945, 946, 10, 3, 0, 0, 946, 947, 5, 208, 0, 0, 947, 974, 3, 148, 74,
		4, 948, 949, 10, 2, 0, 0, 949, 950, 5, 200, 0, 0, 950, 951, 3, 148, 74,
		0, 951, 952, 5, 201, 0, 0, 952, 953, 3, 148, 74, 2, 953, 974, 1, 0, 0,
		0, 954, 955, 10, 1, 0, 0, 955, 956, 7, 9, 0, 0, 956, 974, 3, 148, 74, 1,
		957, 958, 10, 22, 0, 0, 958, 961, 7, 10, 0, 0, 959, 962, 3, 154, 77, 0,
		960, 962, 3, 286, 143, 0, 961, 959, 1, 0, 0, 0, 961, 960, 1, 0, 0, 0, 962,
		974, 1, 0, 0, 0, 963, 964, 10, 21, 0, 0, 964, 965, 5, 189, 0, 0, 965, 966,
		3, 148, 74, 0, 966, 967, 5, 190, 0, 0, 967, 974, 1, 0, 0, 0, 968, 969,
		10, 16, 0, 0, 969, 974, 7, 11, 0, 0, 970, 971, 10, 9, 0, 0, 971, 972, 5,
		22, 0, 0, 972, 974, 3, 44, 22, 0, 973, 907, 1, 0, 0, 0, 973, 910, 1, 0,
		0, 0, 973, 913, 1, 0, 0, 0, 973, 924, 1, 0, 0, 0, 973, 930, 1, 0, 0, 0,
		973, 933, 1, 0, 0, 0, 973, 936, 1, 0, 0, 0, 973, 939, 1, 0, 0, 0, 973,
		942, 1, 0, 0, 0, 973, 945, 1, 0, 0, 0, 973, 948, 1, 0, 0, 0, 973, 954,
		1, 0, 0, 0, 973, 957, 1, 0, 0, 0, 973, 963, 1, 0, 0, 0, 973, 968, 1, 0,
		0, 0, 973, 970, 1, 0, 0, 0, 974, 977, 1, 0, 0, 0, 975, 973, 1, 0, 0, 0,
		975, 976, 1, 0, 0, 0, 976, 149, 1, 0, 0, 0, 977, 975, 1, 0, 0, 0, 978,
		989, 5, 40, 0, 0, 979, 989, 5, 37, 0, 0, 980, 989, 3, 60, 30, 0, 981, 982,
		3, 44, 22, 0, 982, 983, 5, 193, 0, 0, 983, 984, 5, 6, 0, 0, 984, 989, 1,
		0, 0, 0, 985, 989, 3, 284, 142, 0, 986, 989, 3, 176, 88, 0, 987, 989, 3,
		262, 131, 0, 988, 978, 1, 0, 0, 0, 988, 979, 1, 0, 0, 0, 988, 980, 1, 0,
		0, 0, 988, 981, 1, 0, 0, 0, 988, 985, 1, 0, 0, 0, 988, 986, 1, 0, 0, 0,
		988, 987, 1, 0, 0, 0, 989, 151, 1, 0, 0, 0, 990, 991, 3, 284, 142, 0, 991,
		993, 5, 185, 0, 0, 992, 994, 3, 146, 73, 0, 993, 992, 1, 0, 0, 0, 993,
		994, 1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995, 996, 5, 186, 0, 0, 996, 1010,
		1, 0, 0, 0, 997, 998, 5, 40, 0, 0, 998, 1000, 5, 185, 0, 0, 999, 1001,
		3, 146, 73, 0, 1000, 999, 1, 0, 0, 0, 1000, 1001, 1, 0, 0, 0, 1001, 1002,
		1, 0, 0, 0, 1002, 1010, 5, 186, 0, 0, 1003, 1004, 5, 37, 0, 0, 1004, 1006,
		5, 185, 0, 0, 1005, 1007, 3, 146, 73, 0, 1006, 1005, 1, 0, 0, 0, 1006,
		1007, 1, 0, 0, 0, 1007, 1008, 1, 0, 0, 0, 1008, 1010, 5, 186, 0, 0, 1009,
		990, 1, 0, 0, 0, 1009, 997, 1, 0, 0, 0, 1009, 1003, 1, 0, 0, 0, 1010, 153,
		1, 0, 0, 0, 1011, 1012, 3, 286, 143, 0, 1012, 1014, 5, 185, 0, 0, 1013,
		1015, 3, 146, 73, 0, 1014, 1013, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015,
		1016, 1, 0, 0, 0, 1016, 1017, 5, 186, 0, 0, 1017, 155, 1, 0, 0, 0, 1018,
		1024, 3, 158, 79, 0, 1019, 1025, 3, 162, 81, 0, 1020, 1025, 3, 164, 82,
		0, 1021, 1025, 3, 166, 83, 0, 1022, 1025, 3, 168, 84, 0, 1023, 1025, 3,
		172, 86, 0, 1024, 1019, 1, 0, 0, 0, 1024, 1020, 1, 0, 0, 0, 1024, 1021,
		1, 0, 0, 0, 1024, 1022, 1, 0, 0, 0, 1024, 1023, 1, 0, 0, 0, 1025, 157,
		1, 0, 0, 0, 1026, 1031, 3, 160, 80, 0, 1027, 1028, 5, 193, 0, 0, 1028,
		1030, 3, 160, 80, 0, 1029, 1027, 1, 0, 0, 0, 1030, 1033, 1, 0, 0, 0, 1031,
		1029, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032, 159, 1, 0, 0, 0, 1033,
		1031, 1, 0, 0, 0, 1034, 1039, 3, 286, 143, 0, 1035, 1036, 5, 196, 0, 0,
		1036, 1037, 3, 16, 8, 0, 1037, 1038, 5, 195, 0, 0, 1038, 1040, 1, 0, 0,
		0, 1039, 1035, 1, 0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 161, 1, 0, 0,
		0, 1041, 1042, 5, 187, 0, 0, 1042, 1043, 5, 188, 0, 0, 1043, 163, 1, 0,
		0, 0, 1044, 1045, 3, 174, 87, 0, 1045, 165, 1, 0, 0, 0, 1046, 1047, 5,
		189, 0, 0, 1047, 1048, 3, 148, 74, 0, 1048, 1049, 5, 190, 0, 0, 1049, 1056,
		1, 0, 0, 0, 1050, 1051, 5, 189, 0, 0, 1051, 1053, 5, 190, 0, 0, 1052, 1054,
		3, 42, 21, 0, 1053, 1052, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1056,
		1, 0, 0, 0, 1055, 1046, 1, 0, 0, 0, 1055, 1050, 1, 0, 0, 0, 1056, 167,
		1, 0, 0, 0, 1057, 1058, 5, 187, 0, 0, 1058, 1063, 3, 170, 85, 0, 1059,
		1060, 5, 192, 0, 0, 1060, 1062, 3, 170, 85, 0, 1061, 1059, 1, 0, 0, 0,
		1062, 1065, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 1063, 1064, 1, 0, 0, 0,
		1064, 1066, 1, 0, 0, 0, 1065, 1063, 1, 0, 0, 0, 1066, 1067, 5, 188, 0,
		0, 1067, 169, 1, 0, 0, 0, 1068, 1069, 3, 148, 74, 0, 1069, 1070, 5, 219,
		0, 0, 1070, 1071, 3, 148, 74, 0, 1071, 171, 1, 0, 0, 0, 1072, 1073, 5,
		187, 0, 0, 1073, 1078, 3, 148, 74, 0, 1074, 1075, 5, 192, 0, 0, 1075, 1077,
		3, 148, 74, 0, 1076, 1074, 1, 0, 0, 0, 1077, 1080, 1, 0, 0, 0, 1078, 1076,
		1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1081, 1, 0, 0, 0, 1080, 1078,
		1, 0, 0, 0, 1081, 1082, 5, 188, 0, 0, 1082, 173, 1, 0, 0, 0, 1083, 1085,
		5, 185, 0, 0, 1084, 1086, 3, 146, 73, 0, 1085, 1084, 1, 0, 0, 0, 1085,
		1086, 1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0, 1087, 1088, 5, 186, 0, 0, 1088,
		175, 1, 0, 0, 0, 1089, 1090, 5, 189, 0, 0, 1090, 1091, 3, 178, 89, 0, 1091,
		1092, 5, 190, 0, 0, 1092, 177, 1, 0, 0, 0, 1093, 1094, 5, 57, 0, 0, 1094,
		1095, 3, 182, 91, 0, 1095, 1096, 5, 59, 0, 0, 1096, 1098, 3, 188, 94, 0,
		1097, 1099, 3, 210, 105, 0, 1098, 1097, 1, 0, 0, 0, 1098, 1099, 1, 0, 0,
		0, 1099, 1101, 1, 0, 0, 0, 1100, 1102, 3, 212, 106, 0, 1101, 1100, 1, 0,
		0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 1104, 1, 0, 0, 0, 1103, 1105, 3, 228,
		114, 0, 1104, 1103, 1, 0, 0, 0, 1104, 1105, 1, 0, 0, 0, 1105, 1107, 1,
		0, 0, 0, 1106, 1108, 3, 238, 119, 0, 1107, 1106, 1, 0, 0, 0, 1107, 1108,
		1, 0, 0, 0, 1108, 1110, 1, 0, 0, 0, 1109, 1111, 3, 240, 120, 0, 1110, 1109,
		1, 0, 0, 0, 1110, 1111, 1, 0, 0, 0, 1111, 1113, 1, 0, 0, 0, 1112, 1114,
		3, 246, 123, 0, 1113, 1112, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114, 1116,
		1, 0, 0, 0, 1115, 1117, 3, 248, 124, 0, 1116, 1115, 1, 0, 0, 0, 1116, 1117,
		1, 0, 0, 0, 1117, 1119, 1, 0, 0, 0, 1118, 1120, 3, 250, 125, 0, 1119, 1118,
		1, 0, 0, 0, 1119, 1120, 1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 1124,
		3, 252, 126, 0, 1122, 1123, 5, 46, 0, 0, 1123, 1125, 3, 276, 138, 0, 1124,
		1122, 1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 179, 1, 0, 0, 0, 1126,
		1127, 5, 57, 0, 0, 1127, 1128, 3, 192, 96, 0, 1128, 1129, 5, 59, 0, 0,
		1129, 1131, 3, 188, 94, 0, 1130, 1132, 3, 212, 106, 0, 1131, 1130, 1, 0,
		0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 1134, 1, 0, 0, 0, 1133, 1135, 3, 240,
		120, 0, 1134, 1133, 1, 0, 0, 0, 1134, 1135, 1, 0, 0, 0, 1135, 1137, 1,
		0, 0, 0, 1136, 1138, 3, 246, 123, 0, 1137, 1136, 1, 0, 0, 0, 1137, 1138,
		1, 0, 0, 0, 1138, 1139, 1, 0, 0, 0, 1139, 1142, 3, 252, 126, 0, 1140, 1141,
		5, 46, 0, 0, 1141, 1143, 3, 276, 138, 0, 1142, 1140, 1, 0, 0, 0, 1142,
		1143, 1, 0, 0, 0, 1143, 181, 1, 0, 0, 0, 1144, 1149, 3, 184, 92, 0, 1145,
		1146, 5, 192, 0, 0, 1146, 1148, 3, 184, 92, 0, 1147, 1145, 1, 0, 0, 0,
		1148, 1151, 1, 0, 0, 0, 1149, 1147, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0,
		1150, 183, 1, 0, 0, 0, 1151, 1149, 1, 0, 0, 0, 1152, 1154, 3, 186, 93,
		0, 1153, 1155, 3, 260, 130, 0, 1154, 1153, 1, 0, 0, 0, 1154, 1155, 1, 0,
		0, 0, 1155, 1168, 1, 0, 0, 0, 1156, 1158, 3, 198, 99, 0, 1157, 1159, 3,
		260, 130, 0, 1158, 1157, 1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1168,
		1, 0, 0, 0, 1160, 1161, 5, 185, 0, 0, 1161, 1162, 3, 180, 90, 0, 1162,
		1164, 5, 186, 0, 0, 1163, 1165, 3, 260, 130, 0, 1164, 1163, 1, 0, 0, 0,
		1164, 1165, 1, 0, 0, 0, 1165, 1168, 1, 0, 0, 0, 1166, 1168, 3, 202, 101,
		0, 1167, 1152, 1, 0, 0, 0, 1167, 1156, 1, 0, 0, 0, 1167, 1160, 1, 0, 0,
		0, 1167, 1166, 1, 0, 0, 0, 1168, 185, 1, 0, 0, 0, 1169, 1174, 3, 260, 130,
		0, 1170, 1171, 5, 193, 0, 0, 1171, 1173, 3, 260, 130, 0, 1172, 1170, 1,
		0, 0, 0, 1173, 1176, 1, 0, 0, 0, 1174, 1172, 1, 0, 0, 0, 1174, 1175, 1,
		0, 0, 0, 1175, 187, 1, 0, 0, 0, 1176, 1174, 1, 0, 0, 0, 1177, 1182, 3,
		190, 95, 0, 1178, 1179, 5, 192, 0, 0, 1179, 1181, 3, 190, 95, 0, 1180,
		1178, 1, 0, 0, 0, 1181, 1184, 1, 0, 0, 0, 1182, 1180, 1, 0, 0, 0, 1182,
		1183, 1, 0, 0, 0, 1183, 189, 1, 0, 0, 0, 1184, 1182, 1, 0, 0, 0, 1185,
		1187, 3, 186, 93, 0, 1186, 1188, 3, 260, 130, 0, 1187, 1186, 1, 0, 0, 0,
		1187, 1188, 1, 0, 0, 0, 1188, 191, 1, 0, 0, 0, 1189, 1194, 3, 194, 97,
		0, 1190, 1191, 5, 192, 0, 0, 1191, 1193, 3, 194, 97, 0, 1192, 1190, 1,
		0, 0, 0, 1193, 1196, 1, 0, 0, 0, 1194, 1192, 1, 0, 0, 0, 1194, 1195, 1,
		0, 0, 0, 1195, 193, 1, 0, 0, 0, 1196, 1194, 1, 0, 0, 0, 1197, 1199, 3,
		186, 93, 0, 1198, 1200, 3, 260, 130, 0, 1199, 1198, 1, 0, 0, 0, 1199, 1200,
		1, 0, 0, 0, 1200, 1207, 1, 0, 0, 0, 1201, 1203, 3, 198, 99, 0, 1202, 1204,
		3, 260, 130, 0, 1203, 1202, 1, 0, 0, 0, 1203, 1204, 1, 0, 0, 0, 1204, 1207,
		1, 0, 0, 0, 1205, 1207, 3, 202, 101, 0, 1206, 1197, 1, 0, 0, 0, 1206, 1201,
		1, 0, 0, 0, 1206, 1205, 1, 0, 0, 0, 1207, 195, 1, 0, 0, 0, 1208, 1209,
		7, 12, 0, 0, 1209, 197, 1, 0, 0, 0, 1210, 1211, 5, 70, 0, 0, 1211, 1212,
		5, 185, 0, 0, 1212, 1213, 3, 186, 93, 0, 1213, 1214, 5, 186, 0, 0, 1214,
		1324, 1, 0, 0, 0, 1215, 1216, 5, 58, 0, 0, 1216, 1217, 5, 185, 0, 0, 1217,
		1324, 5, 186, 0, 0, 1218, 1219, 5, 58, 0, 0, 1219, 1220, 5, 185, 0, 0,
		1220, 1221, 3, 186, 93, 0, 1221, 1222, 5, 186, 0, 0, 1222, 1324, 1, 0,
		0, 0, 1223, 1224, 5, 71, 0, 0, 1224, 1225, 5, 185, 0, 0, 1225, 1226, 3,
		186, 93, 0, 1226, 1227, 5, 186, 0, 0, 1227, 1324, 1, 0, 0, 0, 1228, 1229,
		5, 72, 0, 0, 1229, 1230, 5, 185, 0, 0, 1230, 1231, 3, 186, 93, 0, 1231,
		1232, 5, 186, 0, 0, 1232, 1324, 1, 0, 0, 0, 1233, 1234, 5, 73, 0, 0, 1234,
		1235, 5, 185, 0, 0, 1235, 1236, 3, 186, 93, 0, 1236, 1237, 5, 186, 0, 0,
		1237, 1324, 1, 0, 0, 0, 1238, 1239, 5, 74, 0, 0, 1239, 1240, 5, 185, 0,
		0, 1240, 1241, 3, 186, 93, 0, 1241, 1242, 5, 186, 0, 0, 1242, 1324, 1,
		0, 0, 0, 1243, 1244, 5, 93, 0, 0, 1244, 1245, 5, 185, 0, 0, 1245, 1246,
		3, 186, 93, 0, 1246, 1247, 5, 186, 0, 0, 1247, 1324, 1, 0, 0, 0, 1248,
		1249, 5, 104, 0, 0, 1249, 1250, 5, 185, 0, 0, 1250, 1251, 3, 186, 93, 0,
		1251, 1252, 5, 186, 0, 0, 1252, 1324, 1, 0, 0, 0, 1253, 1254, 5, 109, 0,
		0, 1254, 1255, 5, 185, 0, 0, 1255, 1256, 3, 200, 100, 0, 1256, 1257, 5,
		186, 0, 0, 1257, 1324, 1, 0, 0, 0, 1258, 1259, 5, 110, 0, 0, 1259, 1260,
		5, 185, 0, 0, 1260, 1261, 3, 200, 100, 0, 1261, 1262, 5, 186, 0, 0, 1262,
		1324, 1, 0, 0, 0, 1263, 1264, 5, 111, 0, 0, 1264, 1265, 5, 185, 0, 0, 1265,
		1266, 3, 200, 100, 0, 1266, 1267, 5, 186, 0, 0, 1267, 1324, 1, 0, 0, 0,
		1268, 1269, 5, 112, 0, 0, 1269, 1270, 5, 185, 0, 0, 1270, 1271, 3, 200,
		100, 0, 1271, 1272, 5, 186, 0, 0, 1272, 1324, 1, 0, 0, 0, 1273, 1274, 5,
		113, 0, 0, 1274, 1275, 5, 185, 0, 0, 1275, 1276, 3, 200, 100, 0, 1276,
		1277, 5, 186, 0, 0, 1277, 1324, 1, 0, 0, 0, 1278, 1279, 5, 114, 0, 0, 1279,
		1280, 5, 185, 0, 0, 1280, 1281, 3, 200, 100, 0, 1281, 1282, 5, 186, 0,
		0, 1282, 1324, 1, 0, 0, 0, 1283, 1284, 5, 115, 0, 0, 1284, 1285, 5, 185,
		0, 0, 1285, 1286, 3, 200, 100, 0, 1286, 1287, 5, 186, 0, 0, 1287, 1324,
		1, 0, 0, 0, 1288, 1289, 5, 116, 0, 0, 1289, 1290, 5, 185, 0, 0, 1290, 1291,
		3, 200, 100, 0, 1291, 1292, 5, 186, 0, 0, 1292, 1324, 1, 0, 0, 0, 1293,
		1294, 5, 117, 0, 0, 1294, 1295, 5, 185, 0, 0, 1295, 1296, 3, 200, 100,
		0, 1296, 1297, 5, 186, 0, 0, 1297, 1324, 1, 0, 0, 0, 1298, 1299, 5, 118,
		0, 0, 1299, 1300, 5, 185, 0, 0, 1300, 1301, 3, 200, 100, 0, 1301, 1302,
		5, 186, 0, 0, 1302, 1324, 1, 0, 0, 0, 1303, 1304, 5, 119, 0, 0, 1304, 1305,
		5, 185, 0, 0, 1305, 1306, 3, 200, 100, 0, 1306, 1307, 5, 186, 0, 0, 1307,
		1324, 1, 0, 0, 0, 1308, 1309, 5, 120, 0, 0, 1309, 1310, 5, 185, 0, 0, 1310,
		1311, 3, 200, 100, 0, 1311, 1312, 5, 186, 0, 0, 1312, 1324, 1, 0, 0, 0,
		1313, 1314, 5, 121, 0, 0, 1314, 1315, 5, 185, 0, 0, 1315, 1316, 3, 200,
		100, 0, 1316, 1317, 5, 186, 0, 0, 1317, 1324, 1, 0, 0, 0, 1318, 1319, 5,
		168, 0, 0, 1319, 1320, 5, 185, 0, 0, 1320, 1321, 3, 196, 98, 0, 1321, 1322,
		5, 186, 0, 0, 1322, 1324, 1, 0, 0, 0, 1323, 1210, 1, 0, 0, 0, 1323, 1215,
		1, 0, 0, 0, 1323, 1218, 1, 0, 0, 0, 1323, 1223, 1, 0, 0, 0, 1323, 1228,
		1, 0, 0, 0, 1323, 1233, 1, 0, 0, 0, 1323, 1238, 1, 0, 0, 0, 1323, 1243,
		1, 0, 0, 0, 1323, 1248, 1, 0, 0, 0, 1323, 1253, 1, 0, 0, 0, 1323, 1258,
		1, 0, 0, 0, 1323, 1263, 1, 0, 0, 0, 1323, 1268, 1, 0, 0, 0, 1323, 1273,
		1, 0, 0, 0, 1323, 1278, 1, 0, 0, 0, 1323, 1283, 1, 0, 0, 0, 1323, 1288,
		1, 0, 0, 0, 1323, 1293, 1, 0, 0, 0, 1323, 1298, 1, 0, 0, 0, 1323, 1303,
		1, 0, 0, 0, 1323, 1308, 1, 0, 0, 0, 1323, 1313, 1, 0, 0, 0, 1323, 1318,
		1, 0, 0, 0, 1324, 199, 1, 0, 0, 0, 1325, 1326, 5, 122, 0, 0, 1326, 1327,
		5, 185, 0, 0, 1327, 1328, 3, 186, 93, 0, 1328, 1329, 5, 186, 0, 0, 1329,
		1332, 1, 0, 0, 0, 1330, 1332, 3, 186, 93, 0, 1331, 1325, 1, 0, 0, 0, 1331,
		1330, 1, 0, 0, 0, 1332, 201, 1, 0, 0, 0, 1333, 1334, 5, 75, 0, 0, 1334,
		1336, 3, 186, 93, 0, 1335, 1337, 3, 204, 102, 0, 1336, 1335, 1, 0, 0, 0,
		1337, 1338, 1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1338, 1339, 1, 0, 0, 0,
		1339, 1341, 1, 0, 0, 0, 1340, 1342, 3, 206, 103, 0, 1341, 1340, 1, 0, 0,
		0, 1341, 1342, 1, 0, 0, 0, 1342, 1343, 1, 0, 0, 0, 1343, 1344, 5, 76, 0,
		0, 1344, 203, 1, 0, 0, 0, 1345, 1346, 5, 51, 0, 0, 1346, 1347, 3, 186,
		93, 0, 1347, 1348, 5, 77, 0, 0, 1348, 1349, 3, 208, 104, 0, 1349, 205,
		1, 0, 0, 0, 1350, 1351, 5, 10, 0, 0, 1351, 1352, 3, 208, 104, 0, 1352,
		207, 1, 0, 0, 0, 1353, 1358, 3, 186, 93, 0, 1354, 1355, 5, 192, 0, 0, 1355,
		1357, 3, 186, 93, 0, 1356, 1354, 1, 0, 0, 0, 1357, 1360, 1, 0, 0, 0, 1358,
		1356, 1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0, 1359, 209, 1, 0, 0, 0, 1360,
		1358, 1, 0, 0, 0, 1361, 1362, 5, 61, 0, 0, 1362, 1363, 5, 62, 0, 0, 1363,
		1364, 3, 260, 130, 0, 1364, 211, 1, 0, 0, 0, 1365, 1366, 5, 63, 0, 0, 1366,
		1367, 3, 214, 107, 0, 1367, 213, 1, 0, 0, 0, 1368, 1373, 3, 216, 108, 0,
		1369, 1370, 5, 67, 0, 0, 1370, 1372, 3, 216, 108, 0, 1371, 1369, 1, 0,
		0, 0, 1372, 1375, 1, 0, 0, 0, 1373, 1371, 1, 0, 0, 0, 1373, 1374, 1, 0,
		0, 0, 1374, 1387, 1, 0, 0, 0, 1375, 1373, 1, 0, 0, 0, 1376, 1381, 3, 216,
		108, 0, 1377, 1378, 5, 68, 0, 0, 1378, 1380, 3, 216, 108, 0, 1379, 1377,
		1, 0, 0, 0, 1380, 1383, 1, 0, 0, 0, 1381, 1379, 1, 0, 0, 0, 1381, 1382,
		1, 0, 0, 0, 1382, 1387, 1, 0, 0, 0, 1383, 1381, 1, 0, 0, 0, 1384, 1385,
		5, 69, 0, 0, 1385, 1387, 3, 216, 108, 0, 1386, 1368, 1, 0, 0, 0, 1386,
		1376, 1, 0, 0, 0, 1386, 1384, 1, 0, 0, 0, 1387, 215, 1, 0, 0, 0, 1388,
		1389, 5, 185, 0, 0, 1389, 1390, 3, 214, 107, 0, 1390, 1391, 5, 186, 0,
		0, 1391, 1394, 1, 0, 0, 0, 1392, 1394, 3, 218, 109, 0, 1393, 1388, 1, 0,
		0, 0, 1393, 1392, 1, 0, 0, 0, 1394, 217, 1, 0, 0, 0, 1395, 1396, 3, 186,
		93, 0, 1396, 1397, 3, 220, 110, 0, 1397, 1398, 3, 222, 111, 0, 1398, 1404,
		1, 0, 0, 0, 1399, 1400, 3, 198, 99, 0, 1400, 1401, 3, 220, 110, 0, 1401,
		1402, 3, 222, 111, 0, 1402, 1404, 1, 0, 0, 0, 1403, 1395, 1, 0, 0, 0, 1403,
		1399, 1, 0, 0, 0, 1404, 219, 1, 0, 0, 0, 1405, 1421, 5, 194, 0, 0, 1406,
		1421, 5, 204, 0, 0, 1407, 1421, 5, 196, 0, 0, 1408, 1421, 5, 195, 0, 0,
		1409, 1410, 5, 196, 0, 0, 1410, 1421, 5, 194, 0, 0, 1411, 1412, 5, 195,
		0, 0, 1412, 1421, 5, 194, 0, 0, 1413, 1421, 5, 205, 0, 0, 1414, 1421, 5,
		78, 0, 0, 1415, 1421, 5, 79, 0, 0, 1416, 1417, 5, 69, 0, 0, 1417, 1421,
		5, 79, 0, 0, 1418, 1421, 5, 80, 0, 0, 1419, 1421, 5, 81, 0, 0, 1420, 1405,
		1, 0, 0, 0, 1420, 1406, 1, 0, 0, 0, 1420, 1407, 1, 0, 0, 0, 1420, 1408,
		1, 0, 0, 0, 1420, 1409, 1, 0, 0, 0, 1420, 1411, 1, 0, 0, 0, 1420, 1413,
		1, 0, 0, 0, 1420, 1414, 1, 0, 0, 0, 1420, 1415, 1, 0, 0, 0, 1420, 1416,
		1, 0, 0, 0, 1420, 1418, 1, 0, 0, 0, 1420, 1419, 1, 0, 0, 0, 1421, 221,
		1, 0, 0, 0, 1422, 1443, 5, 26, 0, 0, 1423, 1443, 5, 182, 0, 0, 1424, 1443,
		3, 226, 113, 0, 1425, 1443, 5, 183, 0, 0, 1426, 1443, 5, 160, 0, 0, 1427,
		1443, 5, 161, 0, 0, 1428, 1443, 3, 256, 128, 0, 1429, 1434, 5, 162, 0,
		0, 1430, 1432, 5, 193, 0, 0, 1431, 1433, 5, 179, 0, 0, 1432, 1431, 1, 0,
		0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 1435, 1, 0, 0, 0, 1434, 1430, 1, 0,
		0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1443, 1, 0, 0, 0, 1436, 1437, 5, 185,
		0, 0, 1437, 1438, 3, 180, 90, 0, 1438, 1439, 5, 186, 0, 0, 1439, 1443,
		1, 0, 0, 0, 1440, 1443, 3, 224, 112, 0, 1441, 1443, 3, 254, 127, 0, 1442,
		1422, 1, 0, 0, 0, 1442, 1423, 1, 0, 0, 0, 1442, 1424, 1, 0, 0, 0, 1442,
		1425, 1, 0, 0, 0, 1442, 1426, 1, 0, 0, 0, 1442, 1427, 1, 0, 0, 0, 1442,
		1428, 1, 0, 0, 0, 1442, 1429, 1, 0, 0, 0, 1442, 1436, 1, 0, 0, 0, 1442,
		1440, 1, 0, 0, 0, 1442, 1441, 1, 0, 0, 0, 1443, 223, 1, 0, 0, 0, 1444,
		1445, 5, 185, 0, 0, 1445, 1450, 3, 222, 111, 0, 1446, 1447, 5, 192, 0,
		0, 1447, 1449, 3, 222, 111, 0, 1448, 1446, 1, 0, 0, 0, 1449, 1452, 1, 0,
		0, 0, 1450, 1448, 1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451, 1453, 1, 0,
		0, 0, 1452, 1450, 1, 0, 0, 0, 1453, 1454, 5, 186, 0, 0, 1454, 225, 1, 0,
		0, 0, 1455, 1457, 7, 6, 0, 0, 1456, 1455, 1, 0, 0, 0, 1456, 1457, 1, 0,
		0, 0, 1457, 1458, 1, 0, 0, 0, 1458, 1459, 7, 13, 0, 0, 1459, 227, 1, 0,
		0, 0, 1460, 1461, 5, 53, 0, 0, 1461, 1462, 5, 95, 0, 0, 1462, 1463, 5,
		96, 0, 0, 1463, 1469, 3, 230, 115, 0, 1464, 1465, 5, 53, 0, 0, 1465, 1469,
		5, 101, 0, 0, 1466, 1467, 5, 53, 0, 0, 1467, 1469, 3, 214, 107, 0, 1468,
		1460, 1, 0, 0, 0, 1468, 1464, 1, 0, 0, 0, 1468, 1466, 1, 0, 0, 0, 1469,
		229, 1, 0, 0, 0, 1470, 1475, 3, 232, 116, 0, 1471, 1472, 5, 207, 0, 0,
		1472, 1474, 3, 232, 116, 0, 1473, 1471, 1, 0, 0, 0, 1474, 1477, 1, 0, 0,
		0, 1475, 1473, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476, 231, 1, 0, 0,
		0, 1477, 1475, 1, 0, 0, 0, 1478, 1479, 3, 260, 130, 0, 1479, 1480, 3, 236,
		118, 0, 1480, 1481, 3, 234, 117, 0, 1481, 233, 1, 0, 0, 0, 1482, 1495,
		3, 260, 130, 0, 1483, 1484, 5, 185, 0, 0, 1484, 1489, 3, 260, 130, 0, 1485,
		1486, 5, 192, 0, 0, 1486, 1488, 3, 260, 130, 0, 1487, 1485, 1, 0, 0, 0,
		1488, 1491, 1, 0, 0, 0, 1489, 1487, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0,
		1490, 1492, 1, 0, 0, 0, 1491, 1489, 1, 0, 0, 0, 1492, 1493, 5, 185, 0,
		0, 1493, 1495, 1, 0, 0, 0, 1494, 1482, 1, 0, 0, 0, 1494, 1483, 1, 0, 0,
		0, 1495, 235, 1, 0, 0, 0, 1496, 1497, 7, 14, 0, 0, 1497, 237, 1, 0, 0,
		0, 1498, 1499, 5, 87, 0, 0, 1499, 1500, 5, 65, 0, 0, 1500, 1503, 3, 182,
		91, 0, 1501, 1502, 5, 91, 0, 0, 1502, 1504, 3, 214, 107, 0, 1503, 1501,
		1, 0, 0, 0, 1503, 1504, 1, 0, 0, 0, 1504, 1534, 1, 0, 0, 0, 1505, 1506,
		5, 87, 0, 0, 1506, 1507, 5, 65, 0, 0, 1507, 1508, 5, 92, 0, 0, 1508, 1509,
		5, 185, 0, 0, 1509, 1514, 3, 186, 93, 0, 1510, 1511, 5, 192, 0, 0, 1511,
		1513, 3, 186, 93, 0, 1512, 1510, 1, 0, 0, 0, 1513, 1516, 1, 0, 0, 0, 1514,
		1512, 1, 0, 0, 0, 1514, 1515, 1, 0, 0, 0, 1515, 1517, 1, 0, 0, 0, 1516,
		1514, 1, 0, 0, 0, 1517, 1518, 5, 186, 0, 0, 1518, 1534, 1, 0, 0, 0, 1519,
		1520, 5, 87, 0, 0, 1520, 1521, 5, 65, 0, 0, 1521, 1522, 5, 103, 0, 0, 1522,
		1523, 5, 185, 0, 0, 1523, 1528, 3, 186, 93, 0, 1524, 1525, 5, 192, 0, 0,
		1525, 1527, 3, 186, 93, 0, 1526, 1524, 1, 0, 0, 0, 1527, 1530, 1, 0, 0,
		0, 1528, 1526, 1, 0, 0, 0, 1528, 1529, 1, 0, 0, 0, 1529, 1531, 1, 0, 0,
		0, 1530, 1528, 1, 0, 0, 0, 1531, 1532, 5, 186, 0, 0, 1532, 1534, 1, 0,
		0, 0, 1533, 1498, 1, 0, 0, 0, 1533, 1505, 1, 0, 0, 0, 1533, 1519, 1, 0,
		0, 0, 1534, 239, 1, 0, 0, 0, 1535, 1536, 5, 64, 0, 0, 1536, 1537, 5, 65,
		0, 0, 1537, 1538, 3, 242, 121, 0, 1538, 241, 1, 0, 0, 0, 1539, 1544, 3,
		244, 122, 0, 1540, 1541, 5, 192, 0, 0, 1541, 1543, 3, 244, 122, 0, 1542,
		1540, 1, 0, 0, 0, 1543, 1546, 1, 0, 0, 0, 1544, 1542, 1, 0, 0, 0, 1544,
		1545, 1, 0, 0, 0, 1545, 243, 1, 0, 0, 0, 1546, 1544, 1, 0, 0, 0, 1547,
		1549, 3, 186, 93, 0, 1548, 1550, 7, 15, 0, 0, 1549, 1548, 1, 0, 0, 0, 1549,
		1550, 1, 0, 0, 0, 1550, 1553, 1, 0, 0, 0, 1551, 1552, 5, 84, 0, 0, 1552,
		1554, 7, 16, 0, 0, 1553, 1551, 1, 0, 0, 0, 1553, 1554, 1, 0, 0, 0, 1554,
		1564, 1, 0, 0, 0, 1555, 1557, 3, 198, 99, 0, 1556, 1558, 7, 15, 0, 0, 1557,
		1556, 1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558, 1561, 1, 0, 0, 0, 1559,
		1560, 5, 84, 0, 0, 1560, 1562, 7, 16, 0, 0, 1561, 1559, 1, 0, 0, 0, 1561,
		1562, 1, 0, 0, 0, 1562, 1564, 1, 0, 0, 0, 1563, 1547, 1, 0, 0, 0, 1563,
		1555, 1, 0, 0, 0, 1564, 245, 1, 0, 0, 0, 1565, 1566, 5, 66, 0, 0, 1566,
		1570, 5, 179, 0, 0, 1567, 1568, 5, 66, 0, 0, 1568, 1570, 3, 254, 127, 0,
		1569, 1565, 1, 0, 0, 0, 1569, 1567, 1, 0, 0, 0, 1570, 247, 1, 0, 0, 0,
		1571, 1572, 5, 94, 0, 0, 1572, 1576, 5, 179, 0, 0, 1573, 1574, 5, 94, 0,
		0, 1574, 1576, 3, 254, 127, 0, 1575, 1571, 1, 0, 0, 0, 1575, 1573, 1, 0,
		0, 0, 1576, 249, 1, 0, 0, 0, 1577, 1578, 5, 88, 0, 0, 1578, 1579, 5, 89,
		0, 0, 1579, 251, 1, 0, 0, 0, 1580, 1581, 5, 15, 0, 0, 1581, 1583, 7, 17,
		0, 0, 1582, 1580, 1, 0, 0, 0, 1583, 1586, 1, 0, 0, 0, 1584, 1582, 1, 0,
		0, 0, 1584, 1585, 1, 0, 0, 0, 1585, 253, 1, 0, 0, 0, 1586, 1584, 1, 0,
		0, 0, 1587, 1588, 5, 201, 0, 0, 1588, 1589, 3, 148, 74, 0, 1589, 255, 1,
		0, 0, 0, 1590, 1656, 5, 123, 0, 0, 1591, 1656, 5, 124, 0, 0, 1592, 1656,
		5, 125, 0, 0, 1593, 1656, 5, 126, 0, 0, 1594, 1656, 5, 127, 0, 0, 1595,
		1656, 5, 128, 0, 0, 1596, 1656, 5, 129, 0, 0, 1597, 1656, 5, 130, 0, 0,
		1598, 1656, 5, 131, 0, 0, 1599, 1656, 5, 132, 0, 0, 1600, 1656, 5, 133,
		0, 0, 1601, 1602, 5, 134, 0, 0, 1602, 1603, 5, 201, 0, 0, 1603, 1656, 3,
		258, 129, 0, 1604, 1605, 5, 135, 0, 0, 1605, 1606, 5, 201, 0, 0, 1606,
		1656, 3, 258, 129, 0, 1607, 1608, 5, 136, 0, 0, 1608, 1609, 5, 201, 0,
		0, 1609, 1656, 3, 258, 129, 0, 1610, 1611, 5, 137, 0, 0, 1611, 1612, 5,
		201, 0, 0, 1612, 1656, 3, 258, 129, 0, 1613, 1614, 5, 138, 0, 0, 1614,
		1615, 5, 201, 0, 0, 1615, 1656, 3, 258, 129, 0, 1616, 1617, 5, 139, 0,
		0, 1617, 1618, 5, 201, 0, 0, 1618, 1656, 3, 258, 129, 0, 1619, 1656, 5,
		140, 0, 0, 1620, 1656, 5, 141, 0, 0, 1621, 1656, 5, 142, 0, 0, 1622, 1623,
		5, 143, 0, 0, 1623, 1624, 5, 201, 0, 0, 1624, 1656, 3, 258, 129, 0, 1625,
		1626, 5, 144, 0, 0, 1626, 1627, 5, 201, 0, 0, 1627, 1656, 3, 258, 129,
		0, 1628, 1656, 5, 145, 0, 0, 1629, 1656, 5, 146, 0, 0, 1630, 1656, 5, 147,
		0, 0, 1631, 1632, 5, 148, 0, 0, 1632, 1633, 5, 201, 0, 0, 1633, 1656, 3,
		258, 129, 0, 1634, 1635, 5, 149, 0, 0, 1635, 1636, 5, 201, 0, 0, 1636,
		1656, 3, 258, 129, 0, 1637, 1656, 5, 150, 0, 0, 1638, 1656, 5, 151, 0,
		0, 1639, 1656, 5, 152, 0, 0, 1640, 1641, 5, 153, 0, 0, 1641, 1642, 5, 201,
		0, 0, 1642, 1656, 3, 258, 129, 0, 1643, 1644, 5, 154, 0, 0, 1644, 1645,
		5, 201, 0, 0, 1645, 1656, 3, 258, 129, 0, 1646, 1656, 5, 155, 0, 0, 1647,
		1656, 5, 156, 0, 0, 1648, 1656, 5, 157, 0, 0, 1649, 1650, 5, 158, 0, 0,
		1650, 1651, 5, 201, 0, 0, 1651, 1656, 3, 258, 129, 0, 1652, 1653, 5, 159,
		0, 0, 1653, 1654, 5, 201, 0, 0, 1654, 1656, 3, 258, 129, 0, 1655, 1590,
		1, 0, 0, 0, 1655, 1591, 1, 0, 0, 0, 1655, 1592, 1, 0, 0, 0, 1655, 1593,
		1, 0, 0, 0, 1655, 1594, 1, 0, 0, 0, 1655, 1595, 1, 0, 0, 0, 1655, 1596,
		1, 0, 0, 0, 1655, 1597, 1, 0, 0, 0, 1655, 1598, 1, 0, 0, 0, 1655, 1599,
		1, 0, 0, 0, 1655, 1600, 1, 0, 0, 0, 1655, 1601, 1, 0, 0, 0, 1655, 1604,
		1, 0, 0, 0, 1655, 1607, 1, 0, 0, 0, 1655, 1610, 1, 0, 0, 0, 1655, 1613,
		1, 0, 0, 0, 1655, 1616, 1, 0, 0, 0, 1655, 1619, 1, 0, 0, 0, 1655, 1620,
		1, 0, 0, 0, 1655, 1621, 1, 0, 0, 0, 1655, 1622, 1, 0, 0, 0, 1655, 1625,
		1, 0, 0, 0, 1655, 1628, 1, 0, 0, 0, 1655, 1629, 1, 0, 0, 0, 1655, 1630,
		1, 0, 0, 0, 1655, 1631, 1, 0, 0, 0, 1655, 1634, 1, 0, 0, 0, 1655, 1637,
		1, 0, 0, 0, 1655, 1638, 1, 0, 0, 0, 1655, 1639, 1, 0, 0, 0, 1655, 1640,
		1, 0, 0, 0, 1655, 1643, 1, 0, 0, 0, 1655, 1646, 1, 0, 0, 0, 1655, 1647,
		1, 0, 0, 0, 1655, 1648, 1, 0, 0, 0, 1655, 1649, 1, 0, 0, 0, 1655, 1652,
		1, 0, 0, 0, 1656, 257, 1, 0, 0, 0, 1657, 1659, 7, 6, 0, 0, 1658, 1657,
		1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1661,
		5, 179, 0, 0, 1661, 259, 1, 0, 0, 0, 1662, 1663, 3, 284, 142, 0, 1663,
		261, 1, 0, 0, 0, 1664, 1665, 5, 177, 0, 0, 1665, 1666, 3, 266, 133, 0,
		1666, 1667, 5, 190, 0, 0, 1667, 1675, 1, 0, 0, 0, 1668, 1669, 5, 189, 0,
		0, 1669, 1670, 5, 163, 0, 0, 1670, 1671, 3, 254, 127, 0, 1671, 1672, 3,
		266, 133, 0, 1672, 1673, 5, 190, 0, 0, 1673, 1675, 1, 0, 0, 0, 1674, 1664,
		1, 0, 0, 0, 1674, 1668, 1, 0, 0, 0, 1675, 263, 1, 0, 0, 0, 1676, 1677,
		5, 178, 0, 0, 1677, 1678, 3, 266, 133, 0, 1678, 1679, 5, 190, 0, 0, 1679,
		265, 1, 0, 0, 0, 1680, 1681, 5, 79, 0, 0, 1681, 1683, 3, 268, 134, 0, 1682,
		1680, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1686, 1, 0, 0, 0, 1684,
		1685, 5, 175, 0, 0, 1685, 1687, 3, 270, 135, 0, 1686, 1684, 1, 0, 0, 0,
		1686, 1687, 1, 0, 0, 0, 1687, 1692, 1, 0, 0, 0, 1688, 1689, 5, 53, 0, 0,
		1689, 1690, 5, 174, 0, 0, 1690, 1691, 5, 194, 0, 0, 1691, 1693, 5, 183,
		0, 0, 1692, 1688, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693, 1698, 1, 0,
		0, 0, 1694, 1695, 5, 53, 0, 0, 1695, 1696, 5, 95, 0, 0, 1696, 1697, 5,
		96, 0, 0, 1697, 1699, 3, 230, 115, 0, 1698, 1694, 1, 0, 0, 0, 1698, 1699,
		1, 0, 0, 0, 1699, 1709, 1, 0, 0, 0, 1700, 1701, 5, 53, 0, 0, 1701, 1707,
		5, 172, 0, 0, 1702, 1703, 5, 185, 0, 0, 1703, 1704, 5, 173, 0, 0, 1704,
		1705, 5, 194, 0, 0, 1705, 1706, 5, 179, 0, 0, 1706, 1708, 5, 186, 0, 0,
		1707, 1702, 1, 0, 0, 0, 1707, 1708, 1, 0, 0, 0, 1708, 1710, 1, 0, 0, 0,
		1709, 1700, 1, 0, 0, 0, 1709, 1710, 1, 0, 0, 0, 1710, 1718, 1, 0, 0, 0,
		1711, 1712, 5, 53, 0, 0, 1712, 1713, 5, 171, 0, 0, 1713, 1714, 5, 79, 0,
		0, 1714, 1715, 5, 185, 0, 0, 1715, 1716, 3, 280, 140, 0, 1716, 1717, 5,
		186, 0, 0, 1717, 1719, 1, 0, 0, 0, 1718, 1711, 1, 0, 0, 0, 1718, 1719,
		1, 0, 0, 0, 1719, 1724, 1, 0, 0, 0, 1720, 1721, 5, 53, 0, 0, 1721, 1722,
		5, 171, 0, 0, 1722, 1723, 5, 194, 0, 0, 1723, 1725, 5, 183, 0, 0, 1724,
		1720, 1, 0, 0, 0, 1724, 1725, 1, 0, 0, 0, 1725, 1730, 1, 0, 0, 0, 1726,
		1727, 5, 53, 0, 0, 1727, 1728, 5, 170, 0, 0, 1728, 1729, 5, 194, 0, 0,
		1729, 1731, 5, 183, 0, 0, 1730, 1726, 1, 0, 0, 0, 1730, 1731, 1, 0, 0,
		0, 1731, 1736, 1, 0, 0, 0, 1732, 1733, 5, 53, 0, 0, 1733, 1734, 5, 169,
		0, 0, 1734, 1735, 5, 194, 0, 0, 1735, 1737, 5, 183, 0, 0, 1736, 1732, 1,
		0, 0, 0, 1736, 1737, 1, 0, 0, 0, 1737, 1739, 1, 0, 0, 0, 1738, 1740, 3,
		246, 123, 0, 1739, 1738, 1, 0, 0, 0, 1739, 1740, 1, 0, 0, 0, 1740, 1743,
		1, 0, 0, 0, 1741, 1742, 5, 46, 0, 0, 1742, 1744, 3, 276, 138, 0, 1743,
		1741, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744, 267, 1, 0, 0, 0, 1745,
		1746, 7, 18, 0, 0, 1746, 1747, 5, 168, 0, 0, 1747, 269, 1, 0, 0, 0, 1748,
		1753, 3, 272, 136, 0, 1749, 1750, 5, 192, 0, 0, 1750, 1752, 3, 270, 135,
		0, 1751, 1749, 1, 0, 0, 0, 1752, 1755, 1, 0, 0, 0, 1753, 1751, 1, 0, 0,
		0, 1753, 1754, 1, 0, 0, 0, 1754, 271, 1, 0, 0, 0, 1755, 1753, 1, 0, 0,
		0, 1756, 1782, 3, 282, 141, 0, 1757, 1758, 5, 185, 0, 0, 1758, 1761, 3,
		274, 137, 0, 1759, 1760, 5, 63, 0, 0, 1760, 1762, 3, 214, 107, 0, 1761,
		1759, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762, 1767, 1, 0, 0, 0, 1763,
		1764, 5, 61, 0, 0, 1764, 1765, 5, 176, 0, 0, 1765, 1766, 5, 194, 0, 0,
		1766, 1768, 3, 282, 141, 0, 1767, 1763, 1, 0, 0, 0, 1767, 1768, 1, 0, 0,
		0, 1768, 1772, 1, 0, 0, 0, 1769, 1770, 5, 64, 0, 0, 1770, 1771, 5, 65,
		0, 0, 1771, 1773, 3, 242, 121, 0, 1772, 1769, 1, 0, 0, 0, 1772, 1773, 1,
		0, 0, 0, 1773, 1775, 1, 0, 0, 0, 1774, 1776, 3, 246, 123, 0, 1775, 1774,
		1, 0, 0, 0, 1775, 1776, 1, 0, 0, 0, 1776, 1778, 1, 0, 0, 0, 1777, 1779,
		3, 248, 124, 0, 1778, 1777, 1, 0, 0, 0, 1778, 1779, 1, 0, 0, 0, 1779, 1780,
		1, 0, 0, 0, 1780, 1781, 5, 186, 0, 0, 1781, 1783, 1, 0, 0, 0, 1782, 1757,
		1, 0, 0, 0, 1782, 1783, 1, 0, 0, 0, 1783, 273, 1, 0, 0, 0, 1784, 1789,
		3, 282, 141, 0, 1785, 1786, 5, 192, 0, 0, 1786, 1788, 3, 274, 137, 0, 1787,
		1785, 1, 0, 0, 0, 1788, 1791, 1, 0, 0, 0, 1789, 1787, 1, 0, 0, 0, 1789,
		1790, 1, 0, 0, 0, 1790, 275, 1, 0, 0, 0, 1791, 1789, 1, 0, 0, 0, 1792,
		1795, 3, 278, 139, 0, 1793, 1794, 5, 192, 0, 0, 1794, 1796, 3, 276, 138,
		0, 1795, 1793, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0, 1796, 277, 1, 0, 0,
		0, 1797, 1798, 7, 19, 0, 0, 1798, 279, 1, 0, 0, 0, 1799, 1802, 5, 183,
		0, 0, 1800, 1801, 5, 192, 0, 0, 1801, 1803, 3, 280, 140, 0, 1802, 1800,
		1, 0, 0, 0, 1802, 1803, 1, 0, 0, 0, 1803, 281, 1, 0, 0, 0, 1804, 1809,
		3, 284, 142, 0, 1805, 1806, 5, 193, 0, 0, 1806, 1808, 3, 282, 141, 0, 1807,
		1805, 1, 0, 0, 0, 1808, 1811, 1, 0, 0, 0, 1809, 1807, 1, 0, 0, 0, 1809,
		1810, 1, 0, 0, 0, 1810, 283, 1, 0, 0, 0, 1811, 1809, 1, 0, 0, 0, 1812,
		1813, 7, 20, 0, 0, 1813, 285, 1, 0, 0, 0, 1814, 1815, 7, 21, 0, 0, 1815,
		287, 1, 0, 0, 0, 179, 298, 314, 321, 328, 332, 338, 342, 350, 359, 366,
		375, 382, 391, 398, 404, 408, 429, 438, 442, 448, 464, 472, 477, 488, 494,
		502, 506, 508, 517, 526, 531, 535, 539, 543, 545, 553, 562, 568, 579, 589,
		592, 598, 602, 613, 621, 624, 627, 637, 648, 674, 681, 690, 704, 710, 713,
		724, 732, 738, 751, 754, 757, 761, 794, 806, 817, 822, 827, 832, 839, 852,
		856, 860, 862, 866, 884, 905, 921, 927, 961, 973, 975, 988, 993, 1000,
		1006, 1009, 1014, 1024, 1031, 1039, 1053, 1055, 1063, 1078, 1085, 1098,
		1101, 1104, 1107, 1110, 1113, 1116, 1119, 1124, 1131, 1134, 1137, 1142,
		1149, 1154, 1158, 1164, 1167, 1174, 1182, 1187, 1194, 1199, 1203, 1206,
		1323, 1331, 1338, 1341, 1358, 1373, 1381, 1386, 1393, 1403, 1420, 1432,
		1434, 1442, 1450, 1456, 1468, 1475, 1489, 1494, 1503, 1514, 1528, 1533,
		1544, 1549, 1553, 1557, 1561, 1563, 1569, 1575, 1584, 1655, 1658, 1674,
		1682, 1686, 1692, 1698, 1707, 1709, 1718, 1724, 1730, 1736, 1739, 1743,
		1753, 1761, 1767, 1772, 1775, 1778, 1782, 1789, 1795, 1802, 1809,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ApexParserInit initializes any static state used to implement ApexParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewApexParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ApexParserInit() {
	staticData := &ApexParserParserStaticData
	staticData.once.Do(apexparserParserInit)
}

// NewApexParser produces a new parser instance for the optional input antlr.TokenStream.
func NewApexParser(input antlr.TokenStream) *ApexParser {
	ApexParserInit()
	this := new(ApexParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ApexParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ApexParser.g4"

	return this
}

// ApexParser tokens.
const (
	ApexParserEOF                      = antlr.TokenEOF
	ApexParserABSTRACT                 = 1
	ApexParserAFTER                    = 2
	ApexParserBEFORE                   = 3
	ApexParserBREAK                    = 4
	ApexParserCATCH                    = 5
	ApexParserCLASS                    = 6
	ApexParserCONTINUE                 = 7
	ApexParserDELETE                   = 8
	ApexParserDO                       = 9
	ApexParserELSE                     = 10
	ApexParserENUM                     = 11
	ApexParserEXTENDS                  = 12
	ApexParserFINAL                    = 13
	ApexParserFINALLY                  = 14
	ApexParserFOR                      = 15
	ApexParserGET                      = 16
	ApexParserGLOBAL                   = 17
	ApexParserIF                       = 18
	ApexParserIMPLEMENTS               = 19
	ApexParserINHERITED                = 20
	ApexParserINSERT                   = 21
	ApexParserINSTANCEOF               = 22
	ApexParserINTERFACE                = 23
	ApexParserMERGE                    = 24
	ApexParserNEW                      = 25
	ApexParserNULL                     = 26
	ApexParserON                       = 27
	ApexParserOVERRIDE                 = 28
	ApexParserPRIVATE                  = 29
	ApexParserPROTECTED                = 30
	ApexParserPUBLIC                   = 31
	ApexParserRETURN                   = 32
	ApexParserSYSTEMRUNAS              = 33
	ApexParserSET                      = 34
	ApexParserSHARING                  = 35
	ApexParserSTATIC                   = 36
	ApexParserSUPER                    = 37
	ApexParserSWITCH                   = 38
	ApexParserTESTMETHOD               = 39
	ApexParserTHIS                     = 40
	ApexParserTHROW                    = 41
	ApexParserTRANSIENT                = 42
	ApexParserTRIGGER                  = 43
	ApexParserTRY                      = 44
	ApexParserUNDELETE                 = 45
	ApexParserUPDATE                   = 46
	ApexParserUPSERT                   = 47
	ApexParserVIRTUAL                  = 48
	ApexParserVOID                     = 49
	ApexParserWEBSERVICE               = 50
	ApexParserWHEN                     = 51
	ApexParserWHILE                    = 52
	ApexParserWITH                     = 53
	ApexParserWITHOUT                  = 54
	ApexParserLIST                     = 55
	ApexParserMAP                      = 56
	ApexParserSELECT                   = 57
	ApexParserCOUNT                    = 58
	ApexParserFROM                     = 59
	ApexParserAS                       = 60
	ApexParserUSING                    = 61
	ApexParserSCOPE                    = 62
	ApexParserWHERE                    = 63
	ApexParserORDER                    = 64
	ApexParserBY                       = 65
	ApexParserLIMIT                    = 66
	ApexParserSOQLAND                  = 67
	ApexParserSOQLOR                   = 68
	ApexParserNOT                      = 69
	ApexParserAVG                      = 70
	ApexParserCOUNT_DISTINCT           = 71
	ApexParserMIN                      = 72
	ApexParserMAX                      = 73
	ApexParserSUM                      = 74
	ApexParserTYPEOF                   = 75
	ApexParserEND                      = 76
	ApexParserTHEN                     = 77
	ApexParserLIKE                     = 78
	ApexParserIN                       = 79
	ApexParserINCLUDES                 = 80
	ApexParserEXCLUDES                 = 81
	ApexParserASC                      = 82
	ApexParserDESC                     = 83
	ApexParserNULLS                    = 84
	ApexParserFIRST                    = 85
	ApexParserLAST                     = 86
	ApexParserGROUP                    = 87
	ApexParserALL                      = 88
	ApexParserROWS                     = 89
	ApexParserVIEW                     = 90
	ApexParserHAVING                   = 91
	ApexParserROLLUP                   = 92
	ApexParserTOLABEL                  = 93
	ApexParserOFFSET                   = 94
	ApexParserDATA                     = 95
	ApexParserCATEGORY                 = 96
	ApexParserAT                       = 97
	ApexParserABOVE                    = 98
	ApexParserBELOW                    = 99
	ApexParserABOVE_OR_BELOW           = 100
	ApexParserSECURITY_ENFORCED        = 101
	ApexParserREFERENCE                = 102
	ApexParserCUBE                     = 103
	ApexParserFORMAT                   = 104
	ApexParserTRACKING                 = 105
	ApexParserVIEWSTAT                 = 106
	ApexParserCUSTOM                   = 107
	ApexParserSTANDARD                 = 108
	ApexParserCALENDAR_MONTH           = 109
	ApexParserCALENDAR_QUARTER         = 110
	ApexParserCALENDAR_YEAR            = 111
	ApexParserDAY_IN_MONTH             = 112
	ApexParserDAY_IN_WEEK              = 113
	ApexParserDAY_IN_YEAR              = 114
	ApexParserDAY_ONLY                 = 115
	ApexParserFISCAL_MONTH             = 116
	ApexParserFISCAL_QUARTER           = 117
	ApexParserFISCAL_YEAR              = 118
	ApexParserHOUR_IN_DAY              = 119
	ApexParserWEEK_IN_MONTH            = 120
	ApexParserWEEK_IN_YEAR             = 121
	ApexParserCONVERT_TIMEZONE         = 122
	ApexParserYESTERDAY                = 123
	ApexParserTODAY                    = 124
	ApexParserTOMORROW                 = 125
	ApexParserLAST_WEEK                = 126
	ApexParserTHIS_WEEK                = 127
	ApexParserNEXT_WEEK                = 128
	ApexParserLAST_MONTH               = 129
	ApexParserTHIS_MONTH               = 130
	ApexParserNEXT_MONTH               = 131
	ApexParserLAST_90_DAYS             = 132
	ApexParserNEXT_90_DAYS             = 133
	ApexParserLAST_N_DAYS_N            = 134
	ApexParserNEXT_N_DAYS_N            = 135
	ApexParserNEXT_N_WEEKS_N           = 136
	ApexParserLAST_N_WEEKS_N           = 137
	ApexParserNEXT_N_MONTHS_N          = 138
	ApexParserLAST_N_MONTHS_N          = 139
	ApexParserTHIS_QUARTER             = 140
	ApexParserLAST_QUARTER             = 141
	ApexParserNEXT_QUARTER             = 142
	ApexParserNEXT_N_QUARTERS_N        = 143
	ApexParserLAST_N_QUARTERS_N        = 144
	ApexParserTHIS_YEAR                = 145
	ApexParserLAST_YEAR                = 146
	ApexParserNEXT_YEAR                = 147
	ApexParserNEXT_N_YEARS_N           = 148
	ApexParserLAST_N_YEARS_N           = 149
	ApexParserTHIS_FISCAL_QUARTER      = 150
	ApexParserLAST_FISCAL_QUARTER      = 151
	ApexParserNEXT_FISCAL_QUARTER      = 152
	ApexParserNEXT_N_FISCAL_QUARTERS_N = 153
	ApexParserLAST_N_FISCAL_QUARTERS_N = 154
	ApexParserTHIS_FISCAL_YEAR         = 155
	ApexParserLAST_FISCAL_YEAR         = 156
	ApexParserNEXT_FISCAL_YEAR         = 157
	ApexParserNEXT_N_FISCAL_YEARS_N    = 158
	ApexParserLAST_N_FISCAL_YEARS_N    = 159
	ApexParserDateLiteral              = 160
	ApexParserDateTimeLiteral          = 161
	ApexParserIntegralCurrencyLiteral  = 162
	ApexParserFIND                     = 163
	ApexParserEMAIL                    = 164
	ApexParserNAME                     = 165
	ApexParserPHONE                    = 166
	ApexParserSIDEBAR                  = 167
	ApexParserFIELDS                   = 168
	ApexParserMETADATA                 = 169
	ApexParserPRICEBOOKID              = 170
	ApexParserNETWORK                  = 171
	ApexParserSNIPPET                  = 172
	ApexParserTARGET_LENGTH            = 173
	ApexParserDIVISION                 = 174
	ApexParserRETURNING                = 175
	ApexParserLISTVIEW                 = 176
	ApexParserFindLiteral              = 177
	ApexParserFindLiteralAlt           = 178
	ApexParserIntegerLiteral           = 179
	ApexParserLongLiteral              = 180
	ApexParserNumberLiteral            = 181
	ApexParserBooleanLiteral           = 182
	ApexParserStringLiteral            = 183
	ApexParserNullLiteral              = 184
	ApexParserLPAREN                   = 185
	ApexParserRPAREN                   = 186
	ApexParserLBRACE                   = 187
	ApexParserRBRACE                   = 188
	ApexParserLBRACK                   = 189
	ApexParserRBRACK                   = 190
	ApexParserSEMI                     = 191
	ApexParserCOMMA                    = 192
	ApexParserDOT                      = 193
	ApexParserASSIGN                   = 194
	ApexParserGT                       = 195
	ApexParserLT                       = 196
	ApexParserBANG                     = 197
	ApexParserTILDE                    = 198
	ApexParserQUESTIONDOT              = 199
	ApexParserQUESTION                 = 200
	ApexParserCOLON                    = 201
	ApexParserEQUAL                    = 202
	ApexParserTRIPLEEQUAL              = 203
	ApexParserNOTEQUAL                 = 204
	ApexParserLESSANDGREATER           = 205
	ApexParserTRIPLENOTEQUAL           = 206
	ApexParserAND                      = 207
	ApexParserOR                       = 208
	ApexParserINC                      = 209
	ApexParserDEC                      = 210
	ApexParserADD                      = 211
	ApexParserSUB                      = 212
	ApexParserMUL                      = 213
	ApexParserDIV                      = 214
	ApexParserBITAND                   = 215
	ApexParserBITOR                    = 216
	ApexParserCARET                    = 217
	ApexParserMOD                      = 218
	ApexParserMAPTO                    = 219
	ApexParserADD_ASSIGN               = 220
	ApexParserSUB_ASSIGN               = 221
	ApexParserMUL_ASSIGN               = 222
	ApexParserDIV_ASSIGN               = 223
	ApexParserAND_ASSIGN               = 224
	ApexParserOR_ASSIGN                = 225
	ApexParserXOR_ASSIGN               = 226
	ApexParserMOD_ASSIGN               = 227
	ApexParserLSHIFT_ASSIGN            = 228
	ApexParserRSHIFT_ASSIGN            = 229
	ApexParserURSHIFT_ASSIGN           = 230
	ApexParserATSIGN                   = 231
	ApexParserIdentifier               = 232
	ApexParserWS                       = 233
	ApexParserDOC_COMMENT              = 234
	ApexParserCOMMENT                  = 235
	ApexParserLINE_COMMENT             = 236
)

// ApexParser rules.
const (
	ApexParserRULE_triggerUnit                       = 0
	ApexParserRULE_triggerCase                       = 1
	ApexParserRULE_compilationUnit                   = 2
	ApexParserRULE_typeDeclaration                   = 3
	ApexParserRULE_classDeclaration                  = 4
	ApexParserRULE_enumDeclaration                   = 5
	ApexParserRULE_enumConstants                     = 6
	ApexParserRULE_interfaceDeclaration              = 7
	ApexParserRULE_typeList                          = 8
	ApexParserRULE_classBody                         = 9
	ApexParserRULE_interfaceBody                     = 10
	ApexParserRULE_classBodyDeclaration              = 11
	ApexParserRULE_modifier                          = 12
	ApexParserRULE_memberDeclaration                 = 13
	ApexParserRULE_methodDeclaration                 = 14
	ApexParserRULE_constructorDeclaration            = 15
	ApexParserRULE_fieldDeclaration                  = 16
	ApexParserRULE_propertyDeclaration               = 17
	ApexParserRULE_interfaceMethodDeclaration        = 18
	ApexParserRULE_variableDeclarators               = 19
	ApexParserRULE_variableDeclarator                = 20
	ApexParserRULE_arrayInitializer                  = 21
	ApexParserRULE_typeRef                           = 22
	ApexParserRULE_arraySubscripts                   = 23
	ApexParserRULE_typeName                          = 24
	ApexParserRULE_typeArguments                     = 25
	ApexParserRULE_formalParameters                  = 26
	ApexParserRULE_formalParameterList               = 27
	ApexParserRULE_formalParameter                   = 28
	ApexParserRULE_qualifiedName                     = 29
	ApexParserRULE_literal                           = 30
	ApexParserRULE_annotation                        = 31
	ApexParserRULE_elementValuePairs                 = 32
	ApexParserRULE_delimitedElementValuePair         = 33
	ApexParserRULE_elementValuePair                  = 34
	ApexParserRULE_elementValue                      = 35
	ApexParserRULE_elementValueArrayInitializer      = 36
	ApexParserRULE_trailingComma                     = 37
	ApexParserRULE_block                             = 38
	ApexParserRULE_localVariableDeclarationStatement = 39
	ApexParserRULE_localVariableDeclaration          = 40
	ApexParserRULE_statement                         = 41
	ApexParserRULE_ifStatement                       = 42
	ApexParserRULE_switchStatement                   = 43
	ApexParserRULE_whenControl                       = 44
	ApexParserRULE_whenValue                         = 45
	ApexParserRULE_whenLiteral                       = 46
	ApexParserRULE_forStatement                      = 47
	ApexParserRULE_whileStatement                    = 48
	ApexParserRULE_doWhileStatement                  = 49
	ApexParserRULE_tryStatement                      = 50
	ApexParserRULE_returnStatement                   = 51
	ApexParserRULE_throwStatement                    = 52
	ApexParserRULE_breakStatement                    = 53
	ApexParserRULE_continueStatement                 = 54
	ApexParserRULE_insertStatement                   = 55
	ApexParserRULE_updateStatement                   = 56
	ApexParserRULE_deleteStatement                   = 57
	ApexParserRULE_undeleteStatement                 = 58
	ApexParserRULE_upsertStatement                   = 59
	ApexParserRULE_mergeStatement                    = 60
	ApexParserRULE_runAsStatement                    = 61
	ApexParserRULE_expressionStatement               = 62
	ApexParserRULE_propertyBlock                     = 63
	ApexParserRULE_getter                            = 64
	ApexParserRULE_setter                            = 65
	ApexParserRULE_catchClause                       = 66
	ApexParserRULE_finallyBlock                      = 67
	ApexParserRULE_forControl                        = 68
	ApexParserRULE_forInit                           = 69
	ApexParserRULE_enhancedForControl                = 70
	ApexParserRULE_forUpdate                         = 71
	ApexParserRULE_parExpression                     = 72
	ApexParserRULE_expressionList                    = 73
	ApexParserRULE_expression                        = 74
	ApexParserRULE_primary                           = 75
	ApexParserRULE_methodCall                        = 76
	ApexParserRULE_dotMethodCall                     = 77
	ApexParserRULE_creator                           = 78
	ApexParserRULE_createdName                       = 79
	ApexParserRULE_idCreatedNamePair                 = 80
	ApexParserRULE_noRest                            = 81
	ApexParserRULE_classCreatorRest                  = 82
	ApexParserRULE_arrayCreatorRest                  = 83
	ApexParserRULE_mapCreatorRest                    = 84
	ApexParserRULE_mapCreatorRestPair                = 85
	ApexParserRULE_setCreatorRest                    = 86
	ApexParserRULE_arguments                         = 87
	ApexParserRULE_soqlLiteral                       = 88
	ApexParserRULE_query                             = 89
	ApexParserRULE_subQuery                          = 90
	ApexParserRULE_selectList                        = 91
	ApexParserRULE_selectEntry                       = 92
	ApexParserRULE_fieldName                         = 93
	ApexParserRULE_fromNameList                      = 94
	ApexParserRULE_fieldNameAlias                    = 95
	ApexParserRULE_subFieldList                      = 96
	ApexParserRULE_subFieldEntry                     = 97
	ApexParserRULE_soqlFieldsParameter               = 98
	ApexParserRULE_soqlFunction                      = 99
	ApexParserRULE_dateFieldName                     = 100
	ApexParserRULE_typeOf                            = 101
	ApexParserRULE_whenClause                        = 102
	ApexParserRULE_elseClause                        = 103
	ApexParserRULE_fieldNameList                     = 104
	ApexParserRULE_usingScope                        = 105
	ApexParserRULE_whereClause                       = 106
	ApexParserRULE_logicalExpression                 = 107
	ApexParserRULE_conditionalExpression             = 108
	ApexParserRULE_fieldExpression                   = 109
	ApexParserRULE_comparisonOperator                = 110
	ApexParserRULE_value                             = 111
	ApexParserRULE_valueList                         = 112
	ApexParserRULE_signedNumber                      = 113
	ApexParserRULE_withClause                        = 114
	ApexParserRULE_filteringExpression               = 115
	ApexParserRULE_dataCategorySelection             = 116
	ApexParserRULE_dataCategoryName                  = 117
	ApexParserRULE_filteringSelector                 = 118
	ApexParserRULE_groupByClause                     = 119
	ApexParserRULE_orderByClause                     = 120
	ApexParserRULE_fieldOrderList                    = 121
	ApexParserRULE_fieldOrder                        = 122
	ApexParserRULE_limitClause                       = 123
	ApexParserRULE_offsetClause                      = 124
	ApexParserRULE_allRowsClause                     = 125
	ApexParserRULE_forClauses                        = 126
	ApexParserRULE_boundExpression                   = 127
	ApexParserRULE_dateFormula                       = 128
	ApexParserRULE_signedInteger                     = 129
	ApexParserRULE_soqlId                            = 130
	ApexParserRULE_soslLiteral                       = 131
	ApexParserRULE_soslLiteralAlt                    = 132
	ApexParserRULE_soslClauses                       = 133
	ApexParserRULE_searchGroup                       = 134
	ApexParserRULE_fieldSpecList                     = 135
	ApexParserRULE_fieldSpec                         = 136
	ApexParserRULE_fieldList                         = 137
	ApexParserRULE_updateList                        = 138
	ApexParserRULE_updateType                        = 139
	ApexParserRULE_networkList                       = 140
	ApexParserRULE_soslId                            = 141
	ApexParserRULE_id                                = 142
	ApexParserRULE_anyId                             = 143
)

// ITriggerUnitContext is an interface to support dynamic dispatch.
type ITriggerUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIGGER() antlr.TerminalNode
	AllId() []IIdContext
	Id(i int) IIdContext
	ON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllTriggerCase() []ITriggerCaseContext
	TriggerCase(i int) ITriggerCaseContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	EOF() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTriggerUnitContext differentiates from other interfaces.
	IsTriggerUnitContext()
}

type TriggerUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerUnitContext() *TriggerUnitContext {
	var p = new(TriggerUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerUnit
	return p
}

func InitEmptyTriggerUnitContext(p *TriggerUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerUnit
}

func (*TriggerUnitContext) IsTriggerUnitContext() {}

func NewTriggerUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerUnitContext {
	var p = new(TriggerUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_triggerUnit

	return p
}

func (s *TriggerUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerUnitContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIGGER, 0)
}

func (s *TriggerUnitContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *TriggerUnitContext) Id(i int) IIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *TriggerUnitContext) ON() antlr.TerminalNode {
	return s.GetToken(ApexParserON, 0)
}

func (s *TriggerUnitContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *TriggerUnitContext) AllTriggerCase() []ITriggerCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITriggerCaseContext); ok {
			len++
		}
	}

	tst := make([]ITriggerCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITriggerCaseContext); ok {
			tst[i] = t.(ITriggerCaseContext)
			i++
		}
	}

	return tst
}

func (s *TriggerUnitContext) TriggerCase(i int) ITriggerCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerCaseContext)
}

func (s *TriggerUnitContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *TriggerUnitContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TriggerUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ApexParserEOF, 0)
}

func (s *TriggerUnitContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *TriggerUnitContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *TriggerUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTriggerUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TriggerUnit() (localctx ITriggerUnitContext) {
	localctx = NewTriggerUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ApexParserRULE_triggerUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(288)
		p.Match(ApexParserTRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(289)
		p.Id()
	}
	{
		p.SetState(290)
		p.Match(ApexParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(291)
		p.Id()
	}
	{
		p.SetState(292)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(293)
		p.TriggerCase()
	}
	p.SetState(298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(294)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(295)
			p.TriggerCase()
		}

		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(301)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(302)
		p.Block()
	}
	{
		p.SetState(303)
		p.Match(ApexParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerCaseContext is an interface to support dynamic dispatch.
type ITriggerCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEFORE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	UNDELETE() antlr.TerminalNode

	// IsTriggerCaseContext differentiates from other interfaces.
	IsTriggerCaseContext()
}

type TriggerCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerCaseContext() *TriggerCaseContext {
	var p = new(TriggerCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerCase
	return p
}

func InitEmptyTriggerCaseContext(p *TriggerCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerCase
}

func (*TriggerCaseContext) IsTriggerCaseContext() {}

func NewTriggerCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerCaseContext {
	var p = new(TriggerCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_triggerCase

	return p
}

func (s *TriggerCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerCaseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(ApexParserBEFORE, 0)
}

func (s *TriggerCaseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ApexParserAFTER, 0)
}

func (s *TriggerCaseContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserINSERT, 0)
}

func (s *TriggerCaseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *TriggerCaseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserDELETE, 0)
}

func (s *TriggerCaseContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserUNDELETE, 0)
}

func (s *TriggerCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTriggerCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TriggerCase() (localctx ITriggerCaseContext) {
	localctx = NewTriggerCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ApexParserRULE_triggerCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserAFTER || _la == ApexParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(306)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&105553118363904) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeDeclaration() ITypeDeclarationContext
	EOF() antlr.TerminalNode

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_compilationUnit
	return p
}

func InitEmptyCompilationUnitContext(p *CompilationUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_compilationUnit
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ApexParserEOF, 0)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ApexParserRULE_compilationUnit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(308)
		p.TypeDeclaration()
	}
	{
		p.SetState(309)
		p.Match(ApexParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext
	EnumDeclaration() IEnumDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeDeclaration
	return p
}

func InitEmptyTypeDeclarationContext(p *TypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeDeclaration
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *TypeDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ApexParserRULE_typeDeclaration)
	var _la int

	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&28433993197297666) != 0) || _la == ApexParserATSIGN {
			{
				p.SetState(311)
				p.Modifier()
			}

			p.SetState(316)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(317)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&28433993197297666) != 0) || _la == ApexParserATSIGN {
			{
				p.SetState(318)
				p.Modifier()
			}

			p.SetState(323)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(324)
			p.EnumDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&28433993197297666) != 0) || _la == ApexParserATSIGN {
			{
				p.SetState(325)
				p.Modifier()
			}

			p.SetState(330)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(331)
			p.InterfaceDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	Id() IIdContext
	ClassBody() IClassBodyContext
	EXTENDS() antlr.TerminalNode
	TypeRef() ITypeRefContext
	IMPLEMENTS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ApexParserCLASS, 0)
}

func (s *ClassDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ApexParserEXTENDS, 0)
}

func (s *ClassDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *ClassDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(ApexParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ApexParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.Match(ApexParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(335)
		p.Id()
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserEXTENDS {
		{
			p.SetState(336)
			p.Match(ApexParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(337)
			p.TypeRef()
		}

	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserIMPLEMENTS {
		{
			p.SetState(340)
			p.Match(ApexParserIMPLEMENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(341)
			p.TypeList()
		}

	}
	{
		p.SetState(344)
		p.ClassBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	Id() IIdContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EnumConstants() IEnumConstantsContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(ApexParserENUM, 0)
}

func (s *EnumDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnumDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *EnumDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *EnumDeclarationContext) EnumConstants() IEnumConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ApexParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(ApexParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(347)
		p.Id()
	}
	{
		p.SetState(348)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-114828269935591412) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562937068519423) != 0) || _la == ApexParserIdentifier {
		{
			p.SetState(349)
			p.EnumConstants()
		}

	}
	{
		p.SetState(352)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId() []IIdContext
	Id(i int) IIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumConstants
	return p
}

func InitEmptyEnumConstantsContext(p *EnumConstantsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumConstants
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) Id(i int) IIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnumConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *EnumConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitEnumConstants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) EnumConstants() (localctx IEnumConstantsContext) {
	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ApexParserRULE_enumConstants)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Id()
	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(355)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(356)
			p.Id()
		}

		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	Id() IIdContext
	InterfaceBody() IInterfaceBodyContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ApexParserINTERFACE, 0)
}

func (s *InterfaceDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *InterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *InterfaceDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ApexParserEXTENDS, 0)
}

func (s *InterfaceDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ApexParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.Match(ApexParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(363)
		p.Id()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserEXTENDS {
		{
			p.SetState(364)
			p.Match(ApexParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)
			p.TypeList()
		}

	}
	{
		p.SetState(368)
		p.InterfaceBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeRef() []ITypeRefContext
	TypeRef(i int) ITypeRefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeRef() []ITypeRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeRefContext); ok {
			len++
		}
	}

	tst := make([]ITypeRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeRefContext); ok {
			tst[i] = t.(ITypeRefContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeRef(i int) ITypeRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ApexParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)
		p.TypeRef()
	}
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(371)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(372)
			p.TypeRef()
		}

		p.SetState(377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitClassBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ApexParserRULE_classBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4770931531372466) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-8646348347482832897) != 0) || _la == ApexParserATSIGN || _la == ApexParserIdentifier {
		{
			p.SetState(379)
			p.ClassBodyDeclaration()
		}

		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(385)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllInterfaceMethodDeclaration() []IInterfaceMethodDeclarationContext
	InterfaceMethodDeclaration(i int) IInterfaceMethodDeclarationContext

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceBody
	return p
}

func InitEmptyInterfaceBodyContext(p *InterfaceBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceBody
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *InterfaceBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *InterfaceBodyContext) AllInterfaceMethodDeclaration() []IInterfaceMethodDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			tst[i] = t.(IInterfaceMethodDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceMethodDeclaration(i int) IInterfaceMethodDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitInterfaceBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ApexParserRULE_interfaceBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4770931539763186) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562937068519423) != 0) || _la == ApexParserATSIGN || _la == ApexParserIdentifier {
		{
			p.SetState(388)
			p.InterfaceMethodDeclaration()
		}

		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(394)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	Block() IBlockContext
	STATIC() antlr.TerminalNode
	MemberDeclaration() IMemberDeclarationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBodyDeclaration
	return p
}

func InitEmptyClassBodyDeclarationContext(p *ClassBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBodyDeclaration
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ApexParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitClassBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ApexParserRULE_classBodyDeclaration)
	var _la int

	var _alt int

	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(396)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserSTATIC {
			{
				p.SetState(397)
				p.Match(ApexParserSTATIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(400)
			p.Block()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(401)
					p.Modifier()
				}

			}
			p.SetState(406)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(407)
			p.MemberDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	GLOBAL() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	WEBSERVICE() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	TESTMETHOD() antlr.TerminalNode
	WITH() antlr.TerminalNode
	SHARING() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	INHERITED() antlr.TerminalNode

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_modifier
	return p
}

func InitEmptyModifierContext(p *ModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_modifier
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModifierContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ApexParserGLOBAL, 0)
}

func (s *ModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(ApexParserPUBLIC, 0)
}

func (s *ModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(ApexParserPROTECTED, 0)
}

func (s *ModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(ApexParserPRIVATE, 0)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(ApexParserTRANSIENT, 0)
}

func (s *ModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ApexParserSTATIC, 0)
}

func (s *ModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(ApexParserABSTRACT, 0)
}

func (s *ModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ApexParserFINAL, 0)
}

func (s *ModifierContext) WEBSERVICE() antlr.TerminalNode {
	return s.GetToken(ApexParserWEBSERVICE, 0)
}

func (s *ModifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(ApexParserOVERRIDE, 0)
}

func (s *ModifierContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserVIRTUAL, 0)
}

func (s *ModifierContext) TESTMETHOD() antlr.TerminalNode {
	return s.GetToken(ApexParserTESTMETHOD, 0)
}

func (s *ModifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *ModifierContext) SHARING() antlr.TerminalNode {
	return s.GetToken(ApexParserSHARING, 0)
}

func (s *ModifierContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(ApexParserWITHOUT, 0)
}

func (s *ModifierContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(ApexParserINHERITED, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ApexParserRULE_modifier)
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserATSIGN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(410)
			p.Annotation()
		}

	case ApexParserGLOBAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(411)
			p.Match(ApexParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserPUBLIC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(412)
			p.Match(ApexParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserPROTECTED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(413)
			p.Match(ApexParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserPRIVATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(414)
			p.Match(ApexParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserTRANSIENT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(415)
			p.Match(ApexParserTRANSIENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserSTATIC:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(416)
			p.Match(ApexParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserABSTRACT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(417)
			p.Match(ApexParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserFINAL:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(418)
			p.Match(ApexParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserWEBSERVICE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(419)
			p.Match(ApexParserWEBSERVICE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserOVERRIDE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(420)
			p.Match(ApexParserOVERRIDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserVIRTUAL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(421)
			p.Match(ApexParserVIRTUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserTESTMETHOD:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(422)
			p.Match(ApexParserTESTMETHOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserWITH:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(423)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(424)
			p.Match(ApexParserSHARING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserWITHOUT:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(425)
			p.Match(ApexParserWITHOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(426)
			p.Match(ApexParserSHARING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserINHERITED:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(427)
			p.Match(ApexParserINHERITED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(428)
			p.Match(ApexParserSHARING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodDeclaration() IMethodDeclarationContext
	FieldDeclaration() IFieldDeclarationContext
	ConstructorDeclaration() IConstructorDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	PropertyDeclaration() IPropertyDeclarationContext

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_memberDeclaration
	return p
}

func InitEmptyMemberDeclarationContext(p *MemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_memberDeclaration
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_memberDeclaration

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *MemberDeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) MemberDeclaration() (localctx IMemberDeclarationContext) {
	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ApexParserRULE_memberDeclaration)
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(431)
			p.MethodDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(432)
			p.FieldDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(433)
			p.ConstructorDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(434)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(435)
			p.ClassDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(436)
			p.EnumDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(437)
			p.PropertyDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	FormalParameters() IFormalParametersContext
	TypeRef() ITypeRefContext
	VOID() antlr.TerminalNode
	Block() IBlockContext
	SEMI() antlr.TerminalNode

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodDeclaration
	return p
}

func InitEmptyMethodDeclarationContext(p *MethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodDeclaration
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *MethodDeclarationContext) VOID() antlr.TerminalNode {
	return s.GetToken(ApexParserVOID, 0)
}

func (s *MethodDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ApexParserRULE_methodDeclaration)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		{
			p.SetState(440)
			p.TypeRef()
		}

	case ApexParserVOID:
		{
			p.SetState(441)
			p.Match(ApexParserVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(444)
		p.Id()
	}
	{
		p.SetState(445)
		p.FormalParameters()
	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserLBRACE:
		{
			p.SetState(446)
			p.Block()
		}

	case ApexParserSEMI:
		{
			p.SetState(447)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	FormalParameters() IFormalParametersContext
	Block() IBlockContext

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_constructorDeclaration
	return p
}

func InitEmptyConstructorDeclarationContext(p *ConstructorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_constructorDeclaration
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ConstructorDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *ConstructorDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitConstructorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ApexParserRULE_constructorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(450)
		p.QualifiedName()
	}
	{
		p.SetState(451)
		p.FormalParameters()
	}
	{
		p.SetState(452)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	VariableDeclarators() IVariableDeclaratorsContext
	SEMI() antlr.TerminalNode

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldDeclaration
	return p
}

func InitEmptyFieldDeclarationContext(p *FieldDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldDeclaration
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *FieldDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *FieldDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ApexParserRULE_fieldDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(454)
		p.TypeRef()
	}
	{
		p.SetState(455)
		p.VariableDeclarators()
	}
	{
		p.SetState(456)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	Id() IIdContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllPropertyBlock() []IPropertyBlockContext
	PropertyBlock(i int) IPropertyBlockContext

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *PropertyDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *PropertyDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *PropertyDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *PropertyDeclarationContext) AllPropertyBlock() []IPropertyBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyBlockContext); ok {
			len++
		}
	}

	tst := make([]IPropertyBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyBlockContext); ok {
			tst[i] = t.(IPropertyBlockContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDeclarationContext) PropertyBlock(i int) IPropertyBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyBlockContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ApexParserRULE_propertyDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.TypeRef()
	}
	{
		p.SetState(459)
		p.Id()
	}
	{
		p.SetState(460)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&28434010377232386) != 0) || _la == ApexParserATSIGN {
		{
			p.SetState(461)
			p.PropertyBlock()
		}

		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(467)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	FormalParameters() IFormalParametersContext
	SEMI() antlr.TerminalNode
	TypeRef() ITypeRefContext
	VOID() antlr.TerminalNode
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceMethodDeclaration
	return p
}

func InitEmptyInterfaceMethodDeclarationContext(p *InterfaceMethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceMethodDeclaration
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *InterfaceMethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *InterfaceMethodDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *InterfaceMethodDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *InterfaceMethodDeclarationContext) VOID() antlr.TerminalNode {
	return s.GetToken(ApexParserVOID, 0)
}

func (s *InterfaceMethodDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMethodDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitInterfaceMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ApexParserRULE_interfaceMethodDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(469)
				p.Modifier()
			}

		}
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		{
			p.SetState(475)
			p.TypeRef()
		}

	case ApexParserVOID:
		{
			p.SetState(476)
			p.Match(ApexParserVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(479)
		p.Id()
	}
	{
		p.SetState(480)
		p.FormalParameters()
	}
	{
		p.SetState(481)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclarator() []IVariableDeclaratorContext
	VariableDeclarator(i int) IVariableDeclaratorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarators
	return p
}

func InitEmptyVariableDeclaratorsContext(p *VariableDeclaratorsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarators
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorContext); ok {
			tst[i] = t.(IVariableDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *VariableDeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitVariableDeclarators(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ApexParserRULE_variableDeclarators)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.VariableDeclarator()
	}
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(484)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(485)
			p.VariableDeclarator()
		}

		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarator
	return p
}

func InitEmptyVariableDeclaratorContext(p *VariableDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarator
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitVariableDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ApexParserRULE_variableDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Id()
	}
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserASSIGN {
		{
			p.SetState(492)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(493)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayInitializer
	return p
}

func InitEmptyArrayInitializerContext(p *ArrayInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayInitializer
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *ArrayInitializerContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayInitializerContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ApexParserRULE_arrayInitializer)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
		{
			p.SetState(497)
			p.expression(0)
		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(498)
					p.Match(ApexParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(499)
					p.expression(0)
				}

			}
			p.SetState(504)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserCOMMA {
			{
				p.SetState(505)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(510)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeRefContext is an interface to support dynamic dispatch.
type ITypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeName() []ITypeNameContext
	TypeName(i int) ITypeNameContext
	ArraySubscripts() IArraySubscriptsContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsTypeRefContext differentiates from other interfaces.
	IsTypeRefContext()
}

type TypeRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeRefContext() *TypeRefContext {
	var p = new(TypeRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeRef
	return p
}

func InitEmptyTypeRefContext(p *TypeRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeRef
}

func (*TypeRefContext) IsTypeRefContext() {}

func NewTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeRefContext {
	var p = new(TypeRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeRef

	return p
}

func (s *TypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeRefContext) AllTypeName() []ITypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNameContext); ok {
			len++
		}
	}

	tst := make([]ITypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNameContext); ok {
			tst[i] = t.(ITypeNameContext)
			i++
		}
	}

	return tst
}

func (s *TypeRefContext) TypeName(i int) ITypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeRefContext) ArraySubscripts() IArraySubscriptsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArraySubscriptsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArraySubscriptsContext)
}

func (s *TypeRefContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *TypeRefContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *TypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTypeRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TypeRef() (localctx ITypeRefContext) {
	localctx = NewTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ApexParserRULE_typeRef)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.TypeName()
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(513)
				p.Match(ApexParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(514)
				p.TypeName()
			}

		}
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(520)
		p.ArraySubscripts()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArraySubscriptsContext is an interface to support dynamic dispatch.
type IArraySubscriptsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode

	// IsArraySubscriptsContext differentiates from other interfaces.
	IsArraySubscriptsContext()
}

type ArraySubscriptsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArraySubscriptsContext() *ArraySubscriptsContext {
	var p = new(ArraySubscriptsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arraySubscripts
	return p
}

func InitEmptyArraySubscriptsContext(p *ArraySubscriptsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arraySubscripts
}

func (*ArraySubscriptsContext) IsArraySubscriptsContext() {}

func NewArraySubscriptsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArraySubscriptsContext {
	var p = new(ArraySubscriptsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arraySubscripts

	return p
}

func (s *ArraySubscriptsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArraySubscriptsContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(ApexParserLBRACK)
}

func (s *ArraySubscriptsContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, i)
}

func (s *ArraySubscriptsContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(ApexParserRBRACK)
}

func (s *ArraySubscriptsContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, i)
}

func (s *ArraySubscriptsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySubscriptsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArraySubscriptsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitArraySubscripts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ArraySubscripts() (localctx IArraySubscriptsContext) {
	localctx = NewArraySubscriptsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ApexParserRULE_arraySubscripts)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(522)
				p.Match(ApexParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(523)
				p.Match(ApexParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIST() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext
	SET() antlr.TerminalNode
	MAP() antlr.TerminalNode
	Id() IIdContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) LIST() antlr.TerminalNode {
	return s.GetToken(ApexParserLIST, 0)
}

func (s *TypeNameContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeNameContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *TypeNameContext) MAP() antlr.TerminalNode {
	return s.GetToken(ApexParserMAP, 0)
}

func (s *TypeNameContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ApexParserRULE_typeName)
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(529)
			p.Match(ApexParserLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(530)
				p.TypeArguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(533)
			p.Match(ApexParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(535)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(534)
				p.TypeArguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(537)
			p.Match(ApexParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(538)
				p.TypeArguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(541)
			p.Id()
		}
		p.SetState(543)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(542)
				p.TypeArguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	TypeList() ITypeListContext
	GT() antlr.TerminalNode

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeArguments
	return p
}

func InitEmptyTypeArgumentsContext(p *TypeArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeArguments
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *TypeArgumentsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ApexParserRULE_typeArguments)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(547)
		p.Match(ApexParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(548)
		p.TypeList()
	}
	{
		p.SetState(549)
		p.Match(ApexParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameters
	return p
}

func InitEmptyFormalParametersContext(p *FormalParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameters
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *FormalParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFormalParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FormalParameters() (localctx IFormalParametersContext) {
	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ApexParserRULE_formalParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5333881493184498) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562937068519423) != 0) || _la == ApexParserATSIGN || _la == ApexParserIdentifier {
		{
			p.SetState(552)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(555)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameter() []IFormalParameterContext
	FormalParameter(i int) IFormalParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ApexParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		p.FormalParameter()
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(558)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(559)
			p.FormalParameter()
		}

		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	Id() IIdContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameter
	return p
}

func InitEmptyFormalParameterContext(p *FormalParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameter
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *FormalParameterContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *FormalParameterContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ApexParserRULE_formalParameter)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(565)
				p.Modifier()
			}

		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(571)
		p.TypeRef()
	}
	{
		p.SetState(572)
		p.Id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId() []IIdContext
	Id(i int) IIdContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Id(i int) IIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ApexParserRULE_qualifiedName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Id()
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserDOT {
		{
			p.SetState(575)
			p.Match(ApexParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(576)
			p.Id()
		}

		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	LongLiteral() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *LiteralContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserLongLiteral, 0)
}

func (s *LiteralContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserNumberLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserBooleanLiteral, 0)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ApexParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserNULL || ((int64((_la-179)) & ^0x3f) == 0 && ((int64(1)<<(_la-179))&31) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ElementValuePairs() IElementValuePairsContext
	ElementValue() IElementValueContext

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserATSIGN, 0)
}

func (s *AnnotationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *AnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *AnnotationContext) ElementValuePairs() IElementValuePairsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *AnnotationContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ApexParserRULE_annotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(ApexParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(585)
		p.QualifiedName()
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserLPAREN {
		{
			p.SetState(586)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(587)
				p.ElementValuePairs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(588)
				p.ElementValue()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(591)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementValuePair() IElementValuePairContext
	AllDelimitedElementValuePair() []IDelimitedElementValuePairContext
	DelimitedElementValuePair(i int) IDelimitedElementValuePairContext

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePairs
	return p
}

func InitEmptyElementValuePairsContext(p *ElementValuePairsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePairs
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) ElementValuePair() IElementValuePairContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) AllDelimitedElementValuePair() []IDelimitedElementValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDelimitedElementValuePairContext); ok {
			len++
		}
	}

	tst := make([]IDelimitedElementValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDelimitedElementValuePairContext); ok {
			tst[i] = t.(IDelimitedElementValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairsContext) DelimitedElementValuePair(i int) IDelimitedElementValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelimitedElementValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelimitedElementValuePairContext)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitElementValuePairs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ApexParserRULE_elementValuePairs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.ElementValuePair()
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-114828269935591412) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562937068519423) != 0) || _la == ApexParserCOMMA || _la == ApexParserIdentifier {
		{
			p.SetState(595)
			p.DelimitedElementValuePair()
		}

		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelimitedElementValuePairContext is an interface to support dynamic dispatch.
type IDelimitedElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementValuePair() IElementValuePairContext
	COMMA() antlr.TerminalNode

	// IsDelimitedElementValuePairContext differentiates from other interfaces.
	IsDelimitedElementValuePairContext()
}

type DelimitedElementValuePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelimitedElementValuePairContext() *DelimitedElementValuePairContext {
	var p = new(DelimitedElementValuePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_delimitedElementValuePair
	return p
}

func InitEmptyDelimitedElementValuePairContext(p *DelimitedElementValuePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_delimitedElementValuePair
}

func (*DelimitedElementValuePairContext) IsDelimitedElementValuePairContext() {}

func NewDelimitedElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelimitedElementValuePairContext {
	var p = new(DelimitedElementValuePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_delimitedElementValuePair

	return p
}

func (s *DelimitedElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *DelimitedElementValuePairContext) ElementValuePair() IElementValuePairContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *DelimitedElementValuePairContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, 0)
}

func (s *DelimitedElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelimitedElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelimitedElementValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDelimitedElementValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DelimitedElementValuePair() (localctx IDelimitedElementValuePairContext) {
	localctx = NewDelimitedElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ApexParserRULE_delimitedElementValuePair)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserCOMMA {
		{
			p.SetState(601)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(604)
		p.ElementValuePair()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	ASSIGN() antlr.TerminalNode
	ElementValue() IElementValueContext

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePair
	return p
}

func InitEmptyElementValuePairContext(p *ElementValuePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePair
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitElementValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ApexParserRULE_elementValuePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Id()
	}
	{
		p.SetState(607)
		p.Match(ApexParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(608)
		p.ElementValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Annotation() IAnnotationContext
	ElementValueArrayInitializer() IElementValueArrayInitializerContext

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValue
	return p
}

func InitEmptyElementValueContext(p *ElementValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValue
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitElementValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ApexParserRULE_elementValue)
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserNEW, ApexParserNULL, ApexParserSET, ApexParserSHARING, ApexParserSUPER, ApexParserSWITCH, ApexParserTHIS, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserFindLiteral, ApexParserIntegerLiteral, ApexParserLongLiteral, ApexParserNumberLiteral, ApexParserBooleanLiteral, ApexParserStringLiteral, ApexParserLPAREN, ApexParserLBRACK, ApexParserBANG, ApexParserTILDE, ApexParserINC, ApexParserDEC, ApexParserADD, ApexParserSUB, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.expression(0)
		}

	case ApexParserATSIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.Annotation()
		}

	case ApexParserLBRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(612)
			p.ElementValueArrayInitializer()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllElementValue() []IElementValueContext
	ElementValue(i int) IElementValueContext
	TrailingComma() ITrailingCommaContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValueArrayInitializer
	return p
}

func InitEmptyElementValueArrayInitializerContext(p *ElementValueArrayInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValueArrayInitializer
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValueContext); ok {
			len++
		}
	}

	tst := make([]IElementValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValueContext); ok {
			tst[i] = t.(IElementValueContext)
			i++
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) TrailingComma() ITrailingCommaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingCommaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingCommaContext)
}

func (s *ElementValueArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ElementValueArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitElementValueArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ApexParserRULE_elementValueArrayInitializer)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&3097350630839156735) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&51539668995) != 0) {
		{
			p.SetState(616)
			p.ElementValue()
		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(617)
					p.Match(ApexParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(618)
					p.ElementValue()
				}

			}
			p.SetState(623)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserCOMMA {
		{
			p.SetState(626)
			p.TrailingComma()
		}

	}
	{
		p.SetState(629)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailingCommaContext is an interface to support dynamic dispatch.
type ITrailingCommaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode

	// IsTrailingCommaContext differentiates from other interfaces.
	IsTrailingCommaContext()
}

type TrailingCommaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailingCommaContext() *TrailingCommaContext {
	var p = new(TrailingCommaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_trailingComma
	return p
}

func InitEmptyTrailingCommaContext(p *TrailingCommaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_trailingComma
}

func (*TrailingCommaContext) IsTrailingCommaContext() {}

func NewTrailingCommaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailingCommaContext {
	var p = new(TrailingCommaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_trailingComma

	return p
}

func (s *TrailingCommaContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailingCommaContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, 0)
}

func (s *TrailingCommaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailingCommaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailingCommaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTrailingComma(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TrailingComma() (localctx ITrailingCommaContext) {
	localctx = NewTrailingCommaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ApexParserRULE_trailingComma)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(ApexParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ApexParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-562950096575586) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&3097350630839156735) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&51539668995) != 0) {
		{
			p.SetState(634)
			p.Statement()
		}

		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(640)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	SEMI() antlr.TerminalNode

	// IsLocalVariableDeclarationStatementContext differentiates from other interfaces.
	IsLocalVariableDeclarationStatementContext()
}

type LocalVariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationStatementContext() *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclarationStatement
	return p
}

func InitEmptyLocalVariableDeclarationStatementContext(p *LocalVariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclarationStatement
}

func (*LocalVariableDeclarationStatementContext) IsLocalVariableDeclarationStatementContext() {}

func NewLocalVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_localVariableDeclarationStatement

	return p
}

func (s *LocalVariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *LocalVariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLocalVariableDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) LocalVariableDeclarationStatement() (localctx ILocalVariableDeclarationStatementContext) {
	localctx = NewLocalVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ApexParserRULE_localVariableDeclarationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.LocalVariableDeclaration()
	}
	{
		p.SetState(643)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	VariableDeclarators() IVariableDeclaratorsContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclaration
	return p
}

func InitEmptyLocalVariableDeclarationContext(p *LocalVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclaration
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *LocalVariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *LocalVariableDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *LocalVariableDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLocalVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ApexParserRULE_localVariableDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(645)
				p.Modifier()
			}

		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(651)
		p.TypeRef()
	}
	{
		p.SetState(652)
		p.VariableDeclarators()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	IfStatement() IIfStatementContext
	SwitchStatement() ISwitchStatementContext
	ForStatement() IForStatementContext
	WhileStatement() IWhileStatementContext
	DoWhileStatement() IDoWhileStatementContext
	TryStatement() ITryStatementContext
	ReturnStatement() IReturnStatementContext
	ThrowStatement() IThrowStatementContext
	BreakStatement() IBreakStatementContext
	ContinueStatement() IContinueStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	UndeleteStatement() IUndeleteStatementContext
	UpsertStatement() IUpsertStatementContext
	MergeStatement() IMergeStatementContext
	RunAsStatement() IRunAsStatementContext
	LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext
	ExpressionStatement() IExpressionStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *StatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) UndeleteStatement() IUndeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUndeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUndeleteStatementContext)
}

func (s *StatementContext) UpsertStatement() IUpsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpsertStatementContext)
}

func (s *StatementContext) MergeStatement() IMergeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeStatementContext)
}

func (s *StatementContext) RunAsStatement() IRunAsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRunAsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRunAsStatementContext)
}

func (s *StatementContext) LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ApexParserRULE_statement)
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(654)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(655)
			p.IfStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(656)
			p.SwitchStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(657)
			p.ForStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(658)
			p.WhileStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(659)
			p.DoWhileStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(660)
			p.TryStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(661)
			p.ReturnStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(662)
			p.ThrowStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(663)
			p.BreakStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(664)
			p.ContinueStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(665)
			p.InsertStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(666)
			p.UpdateStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(667)
			p.DeleteStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(668)
			p.UndeleteStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(669)
			p.UpsertStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(670)
			p.MergeStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(671)
			p.RunAsStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(672)
			p.LocalVariableDeclarationStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(673)
			p.ExpressionStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	ParExpression() IParExpressionContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(ApexParserIF, 0)
}

func (s *IfStatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ApexParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(ApexParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(677)
		p.ParExpression()
	}
	{
		p.SetState(678)
		p.Statement()
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(679)
			p.Match(ApexParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(680)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllWhenControl() []IWhenControlContext
	WhenControl(i int) IWhenControlContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ApexParserSWITCH, 0)
}

func (s *SwitchStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(ApexParserON, 0)
}

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *SwitchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *SwitchStatementContext) AllWhenControl() []IWhenControlContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenControlContext); ok {
			len++
		}
	}

	tst := make([]IWhenControlContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenControlContext); ok {
			tst[i] = t.(IWhenControlContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) WhenControl(i int) IWhenControlContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenControlContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenControlContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ApexParserRULE_switchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Match(ApexParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(684)
		p.Match(ApexParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(685)
		p.expression(0)
	}
	{
		p.SetState(686)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ApexParserWHEN {
		{
			p.SetState(687)
			p.WhenControl()
		}

		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(692)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenControlContext is an interface to support dynamic dispatch.
type IWhenControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	WhenValue() IWhenValueContext
	Block() IBlockContext

	// IsWhenControlContext differentiates from other interfaces.
	IsWhenControlContext()
}

type WhenControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenControlContext() *WhenControlContext {
	var p = new(WhenControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenControl
	return p
}

func InitEmptyWhenControlContext(p *WhenControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenControl
}

func (*WhenControlContext) IsWhenControlContext() {}

func NewWhenControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenControlContext {
	var p = new(WhenControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenControl

	return p
}

func (s *WhenControlContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenControlContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *WhenControlContext) WhenValue() IWhenValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenValueContext)
}

func (s *WhenControlContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhenControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitWhenControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) WhenControl() (localctx IWhenControlContext) {
	localctx = NewWhenControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ApexParserRULE_whenControl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.Match(ApexParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(695)
		p.WhenValue()
	}
	{
		p.SetState(696)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenValueContext is an interface to support dynamic dispatch.
type IWhenValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	AllWhenLiteral() []IWhenLiteralContext
	WhenLiteral(i int) IWhenLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllId() []IIdContext
	Id(i int) IIdContext

	// IsWhenValueContext differentiates from other interfaces.
	IsWhenValueContext()
}

type WhenValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenValueContext() *WhenValueContext {
	var p = new(WhenValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenValue
	return p
}

func InitEmptyWhenValueContext(p *WhenValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenValue
}

func (*WhenValueContext) IsWhenValueContext() {}

func NewWhenValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenValueContext {
	var p = new(WhenValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenValue

	return p
}

func (s *WhenValueContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenValueContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *WhenValueContext) AllWhenLiteral() []IWhenLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenLiteralContext); ok {
			len++
		}
	}

	tst := make([]IWhenLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenLiteralContext); ok {
			tst[i] = t.(IWhenLiteralContext)
			i++
		}
	}

	return tst
}

func (s *WhenValueContext) WhenLiteral(i int) IWhenLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenLiteralContext)
}

func (s *WhenValueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *WhenValueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *WhenValueContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *WhenValueContext) Id(i int) IIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *WhenValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitWhenValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) WhenValue() (localctx IWhenValueContext) {
	localctx = NewWhenValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ApexParserRULE_whenValue)
	var _la int

	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)
			p.Match(ApexParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(699)
			p.WhenLiteral()
		}
		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ApexParserCOMMA {
			{
				p.SetState(700)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(701)
				p.WhenLiteral()
			}

			p.SetState(706)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(707)
			p.Id()
		}
		{
			p.SetState(708)
			p.Id()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenLiteralContext is an interface to support dynamic dispatch.
type IWhenLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	SUB() antlr.TerminalNode
	LongLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	NULL() antlr.TerminalNode
	Id() IIdContext
	LPAREN() antlr.TerminalNode
	WhenLiteral() IWhenLiteralContext
	RPAREN() antlr.TerminalNode

	// IsWhenLiteralContext differentiates from other interfaces.
	IsWhenLiteralContext()
}

type WhenLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenLiteralContext() *WhenLiteralContext {
	var p = new(WhenLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenLiteral
	return p
}

func InitEmptyWhenLiteralContext(p *WhenLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenLiteral
}

func (*WhenLiteralContext) IsWhenLiteralContext() {}

func NewWhenLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenLiteralContext {
	var p = new(WhenLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenLiteral

	return p
}

func (s *WhenLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenLiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *WhenLiteralContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *WhenLiteralContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserLongLiteral, 0)
}

func (s *WhenLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *WhenLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *WhenLiteralContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *WhenLiteralContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *WhenLiteralContext) WhenLiteral() IWhenLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenLiteralContext)
}

func (s *WhenLiteralContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *WhenLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitWhenLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) WhenLiteral() (localctx IWhenLiteralContext) {
	localctx = NewWhenLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ApexParserRULE_whenLiteral)
	var _la int

	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserIntegerLiteral, ApexParserSUB:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserSUB {
			{
				p.SetState(712)
				p.Match(ApexParserSUB)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(715)
			p.Match(ApexParserIntegerLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLongLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(716)
			p.Match(ApexParserLongLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(717)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(718)
			p.Match(ApexParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(719)
			p.Id()
		}

	case ApexParserLPAREN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(720)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.WhenLiteral()
		}
		{
			p.SetState(722)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ForControl() IForControlContext
	RPAREN() antlr.TerminalNode
	Statement() IStatementContext
	SEMI() antlr.TerminalNode

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(ApexParserFOR, 0)
}

func (s *ForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ForStatementContext) ForControl() IForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *ForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ApexParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(ApexParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(727)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(728)
		p.ForControl()
	}
	{
		p.SetState(729)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserABSTRACT, ApexParserAFTER, ApexParserBEFORE, ApexParserBREAK, ApexParserCONTINUE, ApexParserDELETE, ApexParserDO, ApexParserFINAL, ApexParserFOR, ApexParserGET, ApexParserGLOBAL, ApexParserIF, ApexParserINHERITED, ApexParserINSERT, ApexParserINSTANCEOF, ApexParserMERGE, ApexParserNEW, ApexParserNULL, ApexParserOVERRIDE, ApexParserPRIVATE, ApexParserPROTECTED, ApexParserPUBLIC, ApexParserRETURN, ApexParserSYSTEMRUNAS, ApexParserSET, ApexParserSHARING, ApexParserSTATIC, ApexParserSUPER, ApexParserSWITCH, ApexParserTESTMETHOD, ApexParserTHIS, ApexParserTHROW, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserTRY, ApexParserUNDELETE, ApexParserUPDATE, ApexParserUPSERT, ApexParserVIRTUAL, ApexParserWEBSERVICE, ApexParserWHEN, ApexParserWHILE, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserFindLiteral, ApexParserIntegerLiteral, ApexParserLongLiteral, ApexParserNumberLiteral, ApexParserBooleanLiteral, ApexParserStringLiteral, ApexParserLPAREN, ApexParserLBRACE, ApexParserLBRACK, ApexParserBANG, ApexParserTILDE, ApexParserINC, ApexParserDEC, ApexParserADD, ApexParserSUB, ApexParserATSIGN, ApexParserIdentifier:
		{
			p.SetState(730)
			p.Statement()
		}

	case ApexParserSEMI:
		{
			p.SetState(731)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	ParExpression() IParExpressionContext
	Statement() IStatementContext
	SEMI() antlr.TerminalNode

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHILE, 0)
}

func (s *WhileStatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ApexParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Match(ApexParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(735)
		p.ParExpression()
	}
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserABSTRACT, ApexParserAFTER, ApexParserBEFORE, ApexParserBREAK, ApexParserCONTINUE, ApexParserDELETE, ApexParserDO, ApexParserFINAL, ApexParserFOR, ApexParserGET, ApexParserGLOBAL, ApexParserIF, ApexParserINHERITED, ApexParserINSERT, ApexParserINSTANCEOF, ApexParserMERGE, ApexParserNEW, ApexParserNULL, ApexParserOVERRIDE, ApexParserPRIVATE, ApexParserPROTECTED, ApexParserPUBLIC, ApexParserRETURN, ApexParserSYSTEMRUNAS, ApexParserSET, ApexParserSHARING, ApexParserSTATIC, ApexParserSUPER, ApexParserSWITCH, ApexParserTESTMETHOD, ApexParserTHIS, ApexParserTHROW, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserTRY, ApexParserUNDELETE, ApexParserUPDATE, ApexParserUPSERT, ApexParserVIRTUAL, ApexParserWEBSERVICE, ApexParserWHEN, ApexParserWHILE, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserFindLiteral, ApexParserIntegerLiteral, ApexParserLongLiteral, ApexParserNumberLiteral, ApexParserBooleanLiteral, ApexParserStringLiteral, ApexParserLPAREN, ApexParserLBRACE, ApexParserLBRACK, ApexParserBANG, ApexParserTILDE, ApexParserINC, ApexParserDEC, ApexParserADD, ApexParserSUB, ApexParserATSIGN, ApexParserIdentifier:
		{
			p.SetState(736)
			p.Statement()
		}

	case ApexParserSEMI:
		{
			p.SetState(737)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Statement() IStatementContext
	WHILE() antlr.TerminalNode
	ParExpression() IParExpressionContext
	SEMI() antlr.TerminalNode

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_doWhileStatement
	return p
}

func InitEmptyDoWhileStatementContext(p *DoWhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_doWhileStatement
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(ApexParserDO, 0)
}

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHILE, 0)
}

func (s *DoWhileStatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *DoWhileStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDoWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ApexParserRULE_doWhileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(ApexParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(741)
		p.Statement()
	}
	{
		p.SetState(742)
		p.Match(ApexParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(743)
		p.ParExpression()
	}
	{
		p.SetState(744)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Block() IBlockContext
	FinallyBlock() IFinallyBlockContext
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(ApexParserTRY, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ApexParserRULE_tryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(ApexParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(747)
		p.Block()
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserCATCH:
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ApexParserCATCH {
			{
				p.SetState(748)
				p.CatchClause()
			}

			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserFINALLY {
			{
				p.SetState(753)
				p.FinallyBlock()
			}

		}

	case ApexParserFINALLY:
		{
			p.SetState(756)
			p.FinallyBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURN, 0)
}

func (s *ReturnStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ApexParserRULE_returnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(ApexParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
		{
			p.SetState(760)
			p.expression(0)
		}

	}
	{
		p.SetState(763)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THROW() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTHROW, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ApexParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.Match(ApexParserTHROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(766)
		p.expression(0)
	}
	{
		p.SetState(767)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ApexParserBREAK, 0)
}

func (s *BreakStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ApexParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(ApexParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONTINUE, 0)
}

func (s *ContinueStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ApexParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(ApexParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserINSERT, 0)
}

func (s *InsertStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InsertStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ApexParserRULE_insertStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(ApexParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(776)
		p.expression(0)
	}
	{
		p.SetState(777)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *UpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ApexParserRULE_updateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Match(ApexParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(780)
		p.expression(0)
	}
	{
		p.SetState(781)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserDELETE, 0)
}

func (s *DeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ApexParserRULE_deleteStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Match(ApexParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(784)
		p.expression(0)
	}
	{
		p.SetState(785)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUndeleteStatementContext is an interface to support dynamic dispatch.
type IUndeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDELETE() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsUndeleteStatementContext differentiates from other interfaces.
	IsUndeleteStatementContext()
}

type UndeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUndeleteStatementContext() *UndeleteStatementContext {
	var p = new(UndeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_undeleteStatement
	return p
}

func InitEmptyUndeleteStatementContext(p *UndeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_undeleteStatement
}

func (*UndeleteStatementContext) IsUndeleteStatementContext() {}

func NewUndeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UndeleteStatementContext {
	var p = new(UndeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_undeleteStatement

	return p
}

func (s *UndeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UndeleteStatementContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserUNDELETE, 0)
}

func (s *UndeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UndeleteStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *UndeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UndeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitUndeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) UndeleteStatement() (localctx IUndeleteStatementContext) {
	localctx = NewUndeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ApexParserRULE_undeleteStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Match(ApexParserUNDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(788)
		p.expression(0)
	}
	{
		p.SetState(789)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpsertStatementContext is an interface to support dynamic dispatch.
type IUpsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPSERT() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsUpsertStatementContext differentiates from other interfaces.
	IsUpsertStatementContext()
}

type UpsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpsertStatementContext() *UpsertStatementContext {
	var p = new(UpsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_upsertStatement
	return p
}

func InitEmptyUpsertStatementContext(p *UpsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_upsertStatement
}

func (*UpsertStatementContext) IsUpsertStatementContext() {}

func NewUpsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpsertStatementContext {
	var p = new(UpsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_upsertStatement

	return p
}

func (s *UpsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpsertStatementContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserUPSERT, 0)
}

func (s *UpsertStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpsertStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *UpsertStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitUpsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) UpsertStatement() (localctx IUpsertStatementContext) {
	localctx = NewUpsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ApexParserRULE_upsertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.Match(ApexParserUPSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(792)
		p.expression(0)
	}
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-114828269935591412) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562937068519423) != 0) || _la == ApexParserIdentifier {
		{
			p.SetState(793)
			p.QualifiedName()
		}

	}
	{
		p.SetState(796)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeStatementContext is an interface to support dynamic dispatch.
type IMergeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MERGE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SEMI() antlr.TerminalNode

	// IsMergeStatementContext differentiates from other interfaces.
	IsMergeStatementContext()
}

type MergeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStatementContext() *MergeStatementContext {
	var p = new(MergeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mergeStatement
	return p
}

func InitEmptyMergeStatementContext(p *MergeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mergeStatement
}

func (*MergeStatementContext) IsMergeStatementContext() {}

func NewMergeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStatementContext {
	var p = new(MergeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_mergeStatement

	return p
}

func (s *MergeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStatementContext) MERGE() antlr.TerminalNode {
	return s.GetToken(ApexParserMERGE, 0)
}

func (s *MergeStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MergeStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *MergeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitMergeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) MergeStatement() (localctx IMergeStatementContext) {
	localctx = NewMergeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ApexParserRULE_mergeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(ApexParserMERGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(799)
		p.expression(0)
	}
	{
		p.SetState(800)
		p.expression(0)
	}
	{
		p.SetState(801)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRunAsStatementContext is an interface to support dynamic dispatch.
type IRunAsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSTEMRUNAS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	ExpressionList() IExpressionListContext

	// IsRunAsStatementContext differentiates from other interfaces.
	IsRunAsStatementContext()
}

type RunAsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRunAsStatementContext() *RunAsStatementContext {
	var p = new(RunAsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_runAsStatement
	return p
}

func InitEmptyRunAsStatementContext(p *RunAsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_runAsStatement
}

func (*RunAsStatementContext) IsRunAsStatementContext() {}

func NewRunAsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RunAsStatementContext {
	var p = new(RunAsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_runAsStatement

	return p
}

func (s *RunAsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RunAsStatementContext) SYSTEMRUNAS() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEMRUNAS, 0)
}

func (s *RunAsStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *RunAsStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *RunAsStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *RunAsStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RunAsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RunAsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RunAsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitRunAsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) RunAsStatement() (localctx IRunAsStatementContext) {
	localctx = NewRunAsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ApexParserRULE_runAsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.Match(ApexParserSYSTEMRUNAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(804)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
		{
			p.SetState(805)
			p.ExpressionList()
		}

	}
	{
		p.SetState(808)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(809)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ApexParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.expression(0)
	}
	{
		p.SetState(812)
		p.Match(ApexParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyBlockContext is an interface to support dynamic dispatch.
type IPropertyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Getter() IGetterContext
	Setter() ISetterContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsPropertyBlockContext differentiates from other interfaces.
	IsPropertyBlockContext()
}

type PropertyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyBlockContext() *PropertyBlockContext {
	var p = new(PropertyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyBlock
	return p
}

func InitEmptyPropertyBlockContext(p *PropertyBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyBlock
}

func (*PropertyBlockContext) IsPropertyBlockContext() {}

func NewPropertyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyBlockContext {
	var p = new(PropertyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_propertyBlock

	return p
}

func (s *PropertyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyBlockContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyBlockContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertyBlockContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *PropertyBlockContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *PropertyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitPropertyBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) PropertyBlock() (localctx IPropertyBlockContext) {
	localctx = NewPropertyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ApexParserRULE_propertyBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&28433993197297666) != 0) || _la == ApexParserATSIGN {
		{
			p.SetState(814)
			p.Modifier()
		}

		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserGET:
		{
			p.SetState(820)
			p.Getter()
		}

	case ApexParserSET:
		{
			p.SetState(821)
			p.Setter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Block() IBlockContext

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_getter
	return p
}

func InitEmptyGetterContext(p *GetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_getter
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) GET() antlr.TerminalNode {
	return s.GetToken(ApexParserGET, 0)
}

func (s *GetterContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *GetterContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ApexParserRULE_getter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Match(ApexParserGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserSEMI:
		{
			p.SetState(825)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLBRACE:
		{
			p.SetState(826)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Block() IBlockContext

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setter
	return p
}

func InitEmptySetterContext(p *SetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setter
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *SetterContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *SetterContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ApexParserRULE_setter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Match(ApexParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserSEMI:
		{
			p.SetState(830)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLBRACE:
		{
			p.SetState(831)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	Id() IIdContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ApexParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *CatchClauseContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CatchClauseContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *CatchClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *CatchClauseContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitCatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ApexParserRULE_catchClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(834)
		p.Match(ApexParserCATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(835)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(836)
				p.Modifier()
			}

		}
		p.SetState(841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(842)
		p.QualifiedName()
	}
	{
		p.SetState(843)
		p.Id()
	}
	{
		p.SetState(844)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(845)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_finallyBlock
	return p
}

func InitEmptyFinallyBlockContext(p *FinallyBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_finallyBlock
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ApexParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFinallyBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ApexParserRULE_finallyBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(847)
		p.Match(ApexParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(848)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnhancedForControl() IEnhancedForControlContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ForInit() IForInitContext
	Expression() IExpressionContext
	ForUpdate() IForUpdateContext

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forControl
	return p
}

func InitEmptyForControlContext(p *ForControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forControl
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(ApexParserSEMI)
}

func (s *ForControlContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, i)
}

func (s *ForControlContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForControlContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ForControl() (localctx IForControlContext) {
	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ApexParserRULE_forControl)
	var _la int

	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(850)
			p.EnhancedForControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5332644441939954) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&51539668995) != 0) {
			{
				p.SetState(851)
				p.ForInit()
			}

		}
		{
			p.SetState(854)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
			{
				p.SetState(855)
				p.expression(0)
			}

		}
		{
			p.SetState(858)
			p.Match(ApexParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
			{
				p.SetState(859)
				p.ForUpdate()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	ExpressionList() IExpressionListContext

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitForInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ApexParserRULE_forInit)
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(864)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(865)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	Id() IIdContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enhancedForControl
	return p
}

func InitEmptyEnhancedForControlContext(p *EnhancedForControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enhancedForControl
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *EnhancedForControlContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnhancedForControlContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitEnhancedForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ApexParserRULE_enhancedForControl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(868)
		p.TypeRef()
	}
	{
		p.SetState(869)
		p.Id()
	}
	{
		p.SetState(870)
		p.Match(ApexParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(871)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forUpdate
	return p
}

func InitEmptyForUpdateContext(p *ForUpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forUpdate
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitForUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ApexParserRULE_forUpdate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.ExpressionList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_parExpression
	return p
}

func InitEmptyParExpressionContext(p *ParExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_parExpression
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ParExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitParExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ParExpression() (localctx IParExpressionContext) {
	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ApexParserRULE_parExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(876)
		p.expression(0)
	}
	{
		p.SetState(877)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ApexParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.expression(0)
	}
	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(880)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(881)
			p.expression(0)
		}

		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PrimaryExpressionContext struct {
	ExpressionContext
}

func NewPrimaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type Arth1ExpressionContext struct {
	ExpressionContext
}

func NewArth1ExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Arth1ExpressionContext {
	var p = new(Arth1ExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *Arth1ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arth1ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Arth1ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Arth1ExpressionContext) MUL() antlr.TerminalNode {
	return s.GetToken(ApexParserMUL, 0)
}

func (s *Arth1ExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(ApexParserDIV, 0)
}

func (s *Arth1ExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(ApexParserMOD, 0)
}

func (s *Arth1ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitArth1Expression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DotExpressionContext struct {
	ExpressionContext
}

func NewDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DotExpressionContext {
	var p = new(DotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *DotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DotExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, 0)
}

func (s *DotExpressionContext) QUESTIONDOT() antlr.TerminalNode {
	return s.GetToken(ApexParserQUESTIONDOT, 0)
}

func (s *DotExpressionContext) DotMethodCall() IDotMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotMethodCallContext)
}

func (s *DotExpressionContext) AnyId() IAnyIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyIdContext)
}

func (s *DotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitOrExpressionContext struct {
	ExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitOrExpressionContext) BITOR() antlr.TerminalNode {
	return s.GetToken(ApexParserBITOR, 0)
}

func (s *BitOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitBitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayExpressionContext struct {
	ExpressionContext
}

func NewArrayExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *ArrayExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *ArrayExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitArrayExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignExpressionContext struct {
	ExpressionContext
}

func NewAssignExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignExpressionContext {
	var p = new(AssignExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AssignExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignExpressionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *AssignExpressionContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserADD_ASSIGN, 0)
}

func (s *AssignExpressionContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB_ASSIGN, 0)
}

func (s *AssignExpressionContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserMUL_ASSIGN, 0)
}

func (s *AssignExpressionContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserDIV_ASSIGN, 0)
}

func (s *AssignExpressionContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserAND_ASSIGN, 0)
}

func (s *AssignExpressionContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserOR_ASSIGN, 0)
}

func (s *AssignExpressionContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserXOR_ASSIGN, 0)
}

func (s *AssignExpressionContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserRSHIFT_ASSIGN, 0)
}

func (s *AssignExpressionContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserURSHIFT_ASSIGN, 0)
}

func (s *AssignExpressionContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserLSHIFT_ASSIGN, 0)
}

func (s *AssignExpressionContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserMOD_ASSIGN, 0)
}

func (s *AssignExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitAssignExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MethodCallExpressionContext struct {
	ExpressionContext
}

func NewMethodCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodCallExpressionContext {
	var p = new(MethodCallExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MethodCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallExpressionContext) MethodCall() IMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *MethodCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitMethodCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitNotExpressionContext struct {
	ExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitNotExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitNotExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(ApexParserCARET, 0)
}

func (s *BitNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitBitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewInstanceExpressionContext struct {
	ExpressionContext
}

func NewNewInstanceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewInstanceExpressionContext {
	var p = new(NewInstanceExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NewInstanceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewInstanceExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(ApexParserNEW, 0)
}

func (s *NewInstanceExpressionContext) Creator() ICreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *NewInstanceExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitNewInstanceExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type Arth2ExpressionContext struct {
	ExpressionContext
}

func NewArth2ExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Arth2ExpressionContext {
	var p = new(Arth2ExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *Arth2ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arth2ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Arth2ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Arth2ExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *Arth2ExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *Arth2ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitArth2Expression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogAndExpressionContext struct {
	ExpressionContext
}

func NewLogAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogAndExpressionContext {
	var p = new(LogAndExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogAndExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(ApexParserAND, 0)
}

func (s *LogAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLogAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExpressionContext struct {
	ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *CastExpressionContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitAndExpressionContext struct {
	ExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitAndExpressionContext) BITAND() antlr.TerminalNode {
	return s.GetToken(ApexParserBITAND, 0)
}

func (s *BitAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitBitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CmpExpressionContext struct {
	ExpressionContext
}

func NewCmpExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CmpExpressionContext {
	var p = new(CmpExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CmpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CmpExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CmpExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CmpExpressionContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *CmpExpressionContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *CmpExpressionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *CmpExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitCmpExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitExpressionContext struct {
	ExpressionContext
}

func NewBitExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionContext {
	var p = new(BitExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserLT)
}

func (s *BitExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserLT, i)
}

func (s *BitExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserGT)
}

func (s *BitExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserGT, i)
}

func (s *BitExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitBitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogOrExpressionContext struct {
	ExpressionContext
}

func NewLogOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogOrExpressionContext {
	var p = new(LogOrExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogOrExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(ApexParserOR, 0)
}

func (s *LogOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLogOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CondExpressionContext struct {
	ExpressionContext
}

func NewCondExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CondExpressionContext {
	var p = new(CondExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CondExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CondExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CondExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CondExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ApexParserQUESTION, 0)
}

func (s *CondExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}

func (s *CondExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitCondExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	ExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExpressionContext) TRIPLEEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIPLEEQUAL, 0)
}

func (s *EqualityExpressionContext) TRIPLENOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIPLENOTEQUAL, 0)
}

func (s *EqualityExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserEQUAL, 0)
}

func (s *EqualityExpressionContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserNOTEQUAL, 0)
}

func (s *EqualityExpressionContext) LESSANDGREATER() antlr.TerminalNode {
	return s.GetToken(ApexParserLESSANDGREATER, 0)
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostOpExpressionContext struct {
	ExpressionContext
}

func NewPostOpExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostOpExpressionContext {
	var p = new(PostOpExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PostOpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostOpExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostOpExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(ApexParserINC, 0)
}

func (s *PostOpExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(ApexParserDEC, 0)
}

func (s *PostOpExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitPostOpExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NegExpressionContext struct {
	ExpressionContext
}

func NewNegExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NegExpressionContext {
	var p = new(NegExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NegExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NegExpressionContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ApexParserTILDE, 0)
}

func (s *NegExpressionContext) BANG() antlr.TerminalNode {
	return s.GetToken(ApexParserBANG, 0)
}

func (s *NegExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitNegExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreOpExpressionContext struct {
	ExpressionContext
}

func NewPreOpExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreOpExpressionContext {
	var p = new(PreOpExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PreOpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreOpExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PreOpExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *PreOpExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *PreOpExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(ApexParserINC, 0)
}

func (s *PreOpExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(ApexParserDEC, 0)
}

func (s *PreOpExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitPreOpExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubExpressionContext struct {
	ExpressionContext
}

func NewSubExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubExpressionContext {
	var p = new(SubExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *SubExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SubExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *SubExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSubExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstanceOfExpressionContext struct {
	ExpressionContext
}

func NewInstanceOfExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceOfExpressionContext {
	var p = new(InstanceOfExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *InstanceOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceOfExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstanceOfExpressionContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserINSTANCEOF, 0)
}

func (s *InstanceOfExpressionContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *InstanceOfExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitInstanceOfExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *ApexParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 148
	p.EnterRecursionRule(localctx, 148, ApexParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(888)
			p.Primary()
		}

	case 2:
		localctx = NewMethodCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(889)
			p.MethodCall()
		}

	case 3:
		localctx = NewNewInstanceExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(890)
			p.Match(ApexParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(891)
			p.Creator()
		}

	case 4:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(892)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(893)
			p.TypeRef()
		}
		{
			p.SetState(894)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(895)
			p.expression(18)
		}

	case 5:
		localctx = NewSubExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(897)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(898)
			p.expression(0)
		}
		{
			p.SetState(899)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewPreOpExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(901)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-209)) & ^0x3f) == 0 && ((int64(1)<<(_la-209))&15) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(902)
			p.expression(15)
		}

	case 7:
		localctx = NewNegExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(903)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ApexParserBANG || _la == ApexParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(904)
			p.expression(14)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(973)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArth1ExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(907)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(908)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&35) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(909)
					p.expression(14)
				}

			case 2:
				localctx = NewArth2ExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(910)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(911)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserADD || _la == ApexParserSUB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(912)
					p.expression(13)
				}

			case 3:
				localctx = NewBitExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(913)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				p.SetState(921)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(914)
						p.Match(ApexParserLT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(915)
						p.Match(ApexParserLT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(916)
						p.Match(ApexParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(917)
						p.Match(ApexParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(918)
						p.Match(ApexParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 3:
					{
						p.SetState(919)
						p.Match(ApexParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(920)
						p.Match(ApexParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(923)
					p.expression(12)
				}

			case 4:
				localctx = NewCmpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(924)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(925)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserGT || _la == ApexParserLT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(927)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ApexParserASSIGN {
					{
						p.SetState(926)
						p.Match(ApexParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(929)
					p.expression(11)
				}

			case 5:
				localctx = NewEqualityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(930)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(931)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&31) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(932)
					p.expression(9)
				}

			case 6:
				localctx = NewBitAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(933)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(934)
					p.Match(ApexParserBITAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(935)
					p.expression(8)
				}

			case 7:
				localctx = NewBitNotExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(936)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(937)
					p.Match(ApexParserCARET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(938)
					p.expression(7)
				}

			case 8:
				localctx = NewBitOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(939)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(940)
					p.Match(ApexParserBITOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(941)
					p.expression(6)
				}

			case 9:
				localctx = NewLogAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(942)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(943)
					p.Match(ApexParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(944)
					p.expression(5)
				}

			case 10:
				localctx = NewLogOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(945)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(946)
					p.Match(ApexParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(947)
					p.expression(4)
				}

			case 11:
				localctx = NewCondExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(948)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(949)
					p.Match(ApexParserQUESTION)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(950)
					p.expression(0)
				}
				{
					p.SetState(951)
					p.Match(ApexParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(952)
					p.expression(2)
				}

			case 12:
				localctx = NewAssignExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(954)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(955)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&137371844609) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(956)
					p.expression(1)
				}

			case 13:
				localctx = NewDotExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(957)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(958)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserDOT || _la == ApexParserQUESTIONDOT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(961)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(959)
						p.DotMethodCall()
					}

				case 2:
					{
						p.SetState(960)
						p.AnyId()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			case 14:
				localctx = NewArrayExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(963)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(964)
					p.Match(ApexParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(965)
					p.expression(0)
				}
				{
					p.SetState(966)
					p.Match(ApexParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 15:
				localctx = NewPostOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(968)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(969)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserINC || _la == ApexParserDEC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 16:
				localctx = NewInstanceOfExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(970)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(971)
					p.Match(ApexParserINSTANCEOF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(972)
					p.TypeRef()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_primary
	return p
}

func InitEmptyPrimaryContext(p *PrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_primary
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) CopyAll(ctx *PrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ThisPrimaryContext struct {
	PrimaryContext
}

func NewThisPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisPrimaryContext {
	var p = new(ThisPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *ThisPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisPrimaryContext) THIS() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS, 0)
}

func (s *ThisPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitThisPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type SoqlPrimaryContext struct {
	PrimaryContext
}

func NewSoqlPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoqlPrimaryContext {
	var p = new(SoqlPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *SoqlPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlPrimaryContext) SoqlLiteral() ISoqlLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlLiteralContext)
}

func (s *SoqlPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoqlPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type SuperPrimaryContext struct {
	PrimaryContext
}

func NewSuperPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperPrimaryContext {
	var p = new(SuperPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *SuperPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperPrimaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ApexParserSUPER, 0)
}

func (s *SuperPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSuperPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeRefPrimaryContext struct {
	PrimaryContext
}

func NewTypeRefPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeRefPrimaryContext {
	var p = new(TypeRefPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *TypeRefPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRefPrimaryContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *TypeRefPrimaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, 0)
}

func (s *TypeRefPrimaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ApexParserCLASS, 0)
}

func (s *TypeRefPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTypeRefPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdPrimaryContext struct {
	PrimaryContext
}

func NewIdPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdPrimaryContext {
	var p = new(IdPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *IdPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdPrimaryContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *IdPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitIdPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type SoslPrimaryContext struct {
	PrimaryContext
}

func NewSoslPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoslPrimaryContext {
	var p = new(SoslPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *SoslPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslPrimaryContext) SoslLiteral() ISoslLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslLiteralContext)
}

func (s *SoslPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoslPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralPrimaryContext struct {
	PrimaryContext
}

func NewLiteralPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrimaryContext {
	var p = new(LiteralPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *LiteralPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrimaryContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLiteralPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ApexParserRULE_primary)
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		localctx = NewThisPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(978)
			p.Match(ApexParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSuperPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(979)
			p.Match(ApexParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewLiteralPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(980)
			p.Literal()
		}

	case 4:
		localctx = NewTypeRefPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(981)
			p.TypeRef()
		}
		{
			p.SetState(982)
			p.Match(ApexParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.Match(ApexParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewIdPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(985)
			p.Id()
		}

	case 6:
		localctx = NewSoqlPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(986)
			p.SoqlLiteral()
		}

	case 7:
		localctx = NewSoslPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(987)
			p.SoslLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodCallContext is an interface to support dynamic dispatch.
type IMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode

	// IsMethodCallContext differentiates from other interfaces.
	IsMethodCallContext()
}

type MethodCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallContext() *MethodCallContext {
	var p = new(MethodCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodCall
	return p
}

func InitEmptyMethodCallContext(p *MethodCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodCall
}

func (*MethodCallContext) IsMethodCallContext() {}

func NewMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallContext {
	var p = new(MethodCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_methodCall

	return p
}

func (s *MethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *MethodCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *MethodCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *MethodCallContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MethodCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS, 0)
}

func (s *MethodCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ApexParserSUPER, 0)
}

func (s *MethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitMethodCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) MethodCall() (localctx IMethodCallContext) {
	localctx = NewMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ApexParserRULE_methodCall)
	var _la int

	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(990)
			p.Id()
		}
		{
			p.SetState(991)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
			{
				p.SetState(992)
				p.ExpressionList()
			}

		}
		{
			p.SetState(995)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserTHIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(997)
			p.Match(ApexParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(998)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
			{
				p.SetState(999)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1002)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserSUPER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1003)
			p.Match(ApexParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1004)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
			{
				p.SetState(1005)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1008)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotMethodCallContext is an interface to support dynamic dispatch.
type IDotMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnyId() IAnyIdContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsDotMethodCallContext differentiates from other interfaces.
	IsDotMethodCallContext()
}

type DotMethodCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotMethodCallContext() *DotMethodCallContext {
	var p = new(DotMethodCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dotMethodCall
	return p
}

func InitEmptyDotMethodCallContext(p *DotMethodCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dotMethodCall
}

func (*DotMethodCallContext) IsDotMethodCallContext() {}

func NewDotMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotMethodCallContext {
	var p = new(DotMethodCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dotMethodCall

	return p
}

func (s *DotMethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *DotMethodCallContext) AnyId() IAnyIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyIdContext)
}

func (s *DotMethodCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *DotMethodCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *DotMethodCallContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DotMethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotMethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DotMethodCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDotMethodCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DotMethodCall() (localctx IDotMethodCallContext) {
	localctx = NewDotMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ApexParserRULE_dotMethodCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.AnyId()
	}
	{
		p.SetState(1012)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
		{
			p.SetState(1013)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1016)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreatedName() ICreatedNameContext
	NoRest() INoRestContext
	ClassCreatorRest() IClassCreatorRestContext
	ArrayCreatorRest() IArrayCreatorRestContext
	MapCreatorRest() IMapCreatorRestContext
	SetCreatorRest() ISetCreatorRestContext

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_creator
	return p
}

func InitEmptyCreatorContext(p *CreatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_creator
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatorContext {
	var p = new(CreatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_creator

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) NoRest() INoRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoRestContext)
}

func (s *CreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *CreatorContext) ArrayCreatorRest() IArrayCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreatorRestContext)
}

func (s *CreatorContext) MapCreatorRest() IMapCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapCreatorRestContext)
}

func (s *CreatorContext) SetCreatorRest() ISetCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetCreatorRestContext)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitCreator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Creator() (localctx ICreatorContext) {
	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ApexParserRULE_creator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1018)
		p.CreatedName()
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1019)
			p.NoRest()
		}

	case 2:
		{
			p.SetState(1020)
			p.ClassCreatorRest()
		}

	case 3:
		{
			p.SetState(1021)
			p.ArrayCreatorRest()
		}

	case 4:
		{
			p.SetState(1022)
			p.MapCreatorRest()
		}

	case 5:
		{
			p.SetState(1023)
			p.SetCreatorRest()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdCreatedNamePair() []IIdCreatedNamePairContext
	IdCreatedNamePair(i int) IIdCreatedNamePairContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_createdName
	return p
}

func InitEmptyCreatedNameContext(p *CreatedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_createdName
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AllIdCreatedNamePair() []IIdCreatedNamePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdCreatedNamePairContext); ok {
			len++
		}
	}

	tst := make([]IIdCreatedNamePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdCreatedNamePairContext); ok {
			tst[i] = t.(IIdCreatedNamePairContext)
			i++
		}
	}

	return tst
}

func (s *CreatedNameContext) IdCreatedNamePair(i int) IIdCreatedNamePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdCreatedNamePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdCreatedNamePairContext)
}

func (s *CreatedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *CreatedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitCreatedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) CreatedName() (localctx ICreatedNameContext) {
	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ApexParserRULE_createdName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.IdCreatedNamePair()
	}
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserDOT {
		{
			p.SetState(1027)
			p.Match(ApexParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1028)
			p.IdCreatedNamePair()
		}

		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdCreatedNamePairContext is an interface to support dynamic dispatch.
type IIdCreatedNamePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnyId() IAnyIdContext
	LT() antlr.TerminalNode
	TypeList() ITypeListContext
	GT() antlr.TerminalNode

	// IsIdCreatedNamePairContext differentiates from other interfaces.
	IsIdCreatedNamePairContext()
}

type IdCreatedNamePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdCreatedNamePairContext() *IdCreatedNamePairContext {
	var p = new(IdCreatedNamePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_idCreatedNamePair
	return p
}

func InitEmptyIdCreatedNamePairContext(p *IdCreatedNamePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_idCreatedNamePair
}

func (*IdCreatedNamePairContext) IsIdCreatedNamePairContext() {}

func NewIdCreatedNamePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdCreatedNamePairContext {
	var p = new(IdCreatedNamePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_idCreatedNamePair

	return p
}

func (s *IdCreatedNamePairContext) GetParser() antlr.Parser { return s.parser }

func (s *IdCreatedNamePairContext) AnyId() IAnyIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyIdContext)
}

func (s *IdCreatedNamePairContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *IdCreatedNamePairContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *IdCreatedNamePairContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *IdCreatedNamePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdCreatedNamePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdCreatedNamePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitIdCreatedNamePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) IdCreatedNamePair() (localctx IIdCreatedNamePairContext) {
	localctx = NewIdCreatedNamePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ApexParserRULE_idCreatedNamePair)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.AnyId()
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserLT {
		{
			p.SetState(1035)
			p.Match(ApexParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1036)
			p.TypeList()
		}
		{
			p.SetState(1037)
			p.Match(ApexParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoRestContext is an interface to support dynamic dispatch.
type INoRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode

	// IsNoRestContext differentiates from other interfaces.
	IsNoRestContext()
}

type NoRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoRestContext() *NoRestContext {
	var p = new(NoRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_noRest
	return p
}

func InitEmptyNoRestContext(p *NoRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_noRest
}

func (*NoRestContext) IsNoRestContext() {}

func NewNoRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoRestContext {
	var p = new(NoRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_noRest

	return p
}

func (s *NoRestContext) GetParser() antlr.Parser { return s.parser }

func (s *NoRestContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *NoRestContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *NoRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitNoRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) NoRest() (localctx INoRestContext) {
	localctx = NewNoRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ApexParserRULE_noRest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1042)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassCreatorRestContext is an interface to support dynamic dispatch.
type IClassCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Arguments() IArgumentsContext

	// IsClassCreatorRestContext differentiates from other interfaces.
	IsClassCreatorRestContext()
}

type ClassCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassCreatorRestContext() *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classCreatorRest
	return p
}

func InitEmptyClassCreatorRestContext(p *ClassCreatorRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classCreatorRest
}

func (*ClassCreatorRestContext) IsClassCreatorRestContext() {}

func NewClassCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classCreatorRest

	return p
}

func (s *ClassCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassCreatorRestContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ClassCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitClassCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ClassCreatorRest() (localctx IClassCreatorRestContext) {
	localctx = NewClassCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ApexParserRULE_classCreatorRest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.Arguments()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayCreatorRestContext is an interface to support dynamic dispatch.
type IArrayCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	ArrayInitializer() IArrayInitializerContext

	// IsArrayCreatorRestContext differentiates from other interfaces.
	IsArrayCreatorRestContext()
}

type ArrayCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreatorRestContext() *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayCreatorRest
	return p
}

func InitEmptyArrayCreatorRestContext(p *ArrayCreatorRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayCreatorRest
}

func (*ArrayCreatorRestContext) IsArrayCreatorRestContext() {}

func NewArrayCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arrayCreatorRest

	return p
}

func (s *ArrayCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreatorRestContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *ArrayCreatorRestContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreatorRestContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *ArrayCreatorRestContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *ArrayCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitArrayCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ArrayCreatorRest() (localctx IArrayCreatorRestContext) {
	localctx = NewArrayCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ApexParserRULE_arrayCreatorRest)
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1046)
			p.Match(ApexParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1047)
			p.expression(0)
		}
		{
			p.SetState(1048)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1050)
			p.Match(ApexParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1051)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1052)
				p.ArrayInitializer()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapCreatorRestContext is an interface to support dynamic dispatch.
type IMapCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllMapCreatorRestPair() []IMapCreatorRestPairContext
	MapCreatorRestPair(i int) IMapCreatorRestPairContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapCreatorRestContext differentiates from other interfaces.
	IsMapCreatorRestContext()
}

type MapCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapCreatorRestContext() *MapCreatorRestContext {
	var p = new(MapCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRest
	return p
}

func InitEmptyMapCreatorRestContext(p *MapCreatorRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRest
}

func (*MapCreatorRestContext) IsMapCreatorRestContext() {}

func NewMapCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapCreatorRestContext {
	var p = new(MapCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_mapCreatorRest

	return p
}

func (s *MapCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *MapCreatorRestContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *MapCreatorRestContext) AllMapCreatorRestPair() []IMapCreatorRestPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapCreatorRestPairContext); ok {
			len++
		}
	}

	tst := make([]IMapCreatorRestPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapCreatorRestPairContext); ok {
			tst[i] = t.(IMapCreatorRestPairContext)
			i++
		}
	}

	return tst
}

func (s *MapCreatorRestContext) MapCreatorRestPair(i int) IMapCreatorRestPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapCreatorRestPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapCreatorRestPairContext)
}

func (s *MapCreatorRestContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *MapCreatorRestContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *MapCreatorRestContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *MapCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitMapCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) MapCreatorRest() (localctx IMapCreatorRestContext) {
	localctx = NewMapCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ApexParserRULE_mapCreatorRest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1058)
		p.MapCreatorRestPair()
	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1059)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1060)
			p.MapCreatorRestPair()
		}

		p.SetState(1065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1066)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapCreatorRestPairContext is an interface to support dynamic dispatch.
type IMapCreatorRestPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	MAPTO() antlr.TerminalNode

	// IsMapCreatorRestPairContext differentiates from other interfaces.
	IsMapCreatorRestPairContext()
}

type MapCreatorRestPairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapCreatorRestPairContext() *MapCreatorRestPairContext {
	var p = new(MapCreatorRestPairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRestPair
	return p
}

func InitEmptyMapCreatorRestPairContext(p *MapCreatorRestPairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRestPair
}

func (*MapCreatorRestPairContext) IsMapCreatorRestPairContext() {}

func NewMapCreatorRestPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapCreatorRestPairContext {
	var p = new(MapCreatorRestPairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_mapCreatorRestPair

	return p
}

func (s *MapCreatorRestPairContext) GetParser() antlr.Parser { return s.parser }

func (s *MapCreatorRestPairContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapCreatorRestPairContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapCreatorRestPairContext) MAPTO() antlr.TerminalNode {
	return s.GetToken(ApexParserMAPTO, 0)
}

func (s *MapCreatorRestPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapCreatorRestPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapCreatorRestPairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitMapCreatorRestPair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) MapCreatorRestPair() (localctx IMapCreatorRestPairContext) {
	localctx = NewMapCreatorRestPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ApexParserRULE_mapCreatorRestPair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1068)
		p.expression(0)
	}
	{
		p.SetState(1069)
		p.Match(ApexParserMAPTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1070)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetCreatorRestContext is an interface to support dynamic dispatch.
type ISetCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetCreatorRestContext differentiates from other interfaces.
	IsSetCreatorRestContext()
}

type SetCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetCreatorRestContext() *SetCreatorRestContext {
	var p = new(SetCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setCreatorRest
	return p
}

func InitEmptySetCreatorRestContext(p *SetCreatorRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setCreatorRest
}

func (*SetCreatorRestContext) IsSetCreatorRestContext() {}

func NewSetCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetCreatorRestContext {
	var p = new(SetCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_setCreatorRest

	return p
}

func (s *SetCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *SetCreatorRestContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *SetCreatorRestContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetCreatorRestContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetCreatorRestContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *SetCreatorRestContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *SetCreatorRestContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *SetCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSetCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SetCreatorRest() (localctx ISetCreatorRestContext) {
	localctx = NewSetCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ApexParserRULE_setCreatorRest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1072)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1073)
		p.expression(0)
	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1074)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(1075)
			p.expression(0)
		}

		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1081)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ApexParserRULE_arguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6740641827454964) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&2520889878535733247) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&34359799811) != 0) {
		{
			p.SetState(1084)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1087)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoqlLiteralContext is an interface to support dynamic dispatch.
type ISoqlLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	Query() IQueryContext
	RBRACK() antlr.TerminalNode

	// IsSoqlLiteralContext differentiates from other interfaces.
	IsSoqlLiteralContext()
}

type SoqlLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlLiteralContext() *SoqlLiteralContext {
	var p = new(SoqlLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlLiteral
	return p
}

func InitEmptySoqlLiteralContext(p *SoqlLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlLiteral
}

func (*SoqlLiteralContext) IsSoqlLiteralContext() {}

func NewSoqlLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlLiteralContext {
	var p = new(SoqlLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlLiteral

	return p
}

func (s *SoqlLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlLiteralContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *SoqlLiteralContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SoqlLiteralContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *SoqlLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoqlLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoqlLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoqlLiteral() (localctx ISoqlLiteralContext) {
	localctx = NewSoqlLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ApexParserRULE_soqlLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1089)
		p.Match(ApexParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1090)
		p.Query()
	}
	{
		p.SetState(1091)
		p.Match(ApexParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectList() ISelectListContext
	FROM() antlr.TerminalNode
	FromNameList() IFromNameListContext
	ForClauses() IForClausesContext
	UsingScope() IUsingScopeContext
	WhereClause() IWhereClauseContext
	WithClause() IWithClauseContext
	GroupByClause() IGroupByClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	OffsetClause() IOffsetClauseContext
	AllRowsClause() IAllRowsClauseContext
	UPDATE() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *QueryContext) SelectList() ISelectListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectListContext)
}

func (s *QueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *QueryContext) FromNameList() IFromNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromNameListContext)
}

func (s *QueryContext) ForClauses() IForClausesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForClausesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForClausesContext)
}

func (s *QueryContext) UsingScope() IUsingScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingScopeContext)
}

func (s *QueryContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QueryContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QueryContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QueryContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryContext) OffsetClause() IOffsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetClauseContext)
}

func (s *QueryContext) AllRowsClause() IAllRowsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllRowsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllRowsClauseContext)
}

func (s *QueryContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *QueryContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ApexParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Match(ApexParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1094)
		p.SelectList()
	}
	{
		p.SetState(1095)
		p.Match(ApexParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1096)
		p.FromNameList()
	}
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserUSING {
		{
			p.SetState(1097)
			p.UsingScope()
		}

	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserWHERE {
		{
			p.SetState(1100)
			p.WhereClause()
		}

	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserWITH {
		{
			p.SetState(1103)
			p.WithClause()
		}

	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserGROUP {
		{
			p.SetState(1106)
			p.GroupByClause()
		}

	}
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserORDER {
		{
			p.SetState(1109)
			p.OrderByClause()
		}

	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserLIMIT {
		{
			p.SetState(1112)
			p.LimitClause()
		}

	}
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserOFFSET {
		{
			p.SetState(1115)
			p.OffsetClause()
		}

	}
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserALL {
		{
			p.SetState(1118)
			p.AllRowsClause()
		}

	}
	{
		p.SetState(1121)
		p.ForClauses()
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserUPDATE {
		{
			p.SetState(1122)
			p.Match(ApexParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1123)
			p.UpdateList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubQueryContext is an interface to support dynamic dispatch.
type ISubQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SubFieldList() ISubFieldListContext
	FROM() antlr.TerminalNode
	FromNameList() IFromNameListContext
	ForClauses() IForClausesContext
	WhereClause() IWhereClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	UPDATE() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsSubQueryContext differentiates from other interfaces.
	IsSubQueryContext()
}

type SubQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubQueryContext() *SubQueryContext {
	var p = new(SubQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subQuery
	return p
}

func InitEmptySubQueryContext(p *SubQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subQuery
}

func (*SubQueryContext) IsSubQueryContext() {}

func NewSubQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubQueryContext {
	var p = new(SubQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_subQuery

	return p
}

func (s *SubQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubQueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *SubQueryContext) SubFieldList() ISubFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubFieldListContext)
}

func (s *SubQueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *SubQueryContext) FromNameList() IFromNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromNameListContext)
}

func (s *SubQueryContext) ForClauses() IForClausesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForClausesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForClausesContext)
}

func (s *SubQueryContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SubQueryContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SubQueryContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SubQueryContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *SubQueryContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *SubQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSubQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SubQuery() (localctx ISubQueryContext) {
	localctx = NewSubQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ApexParserRULE_subQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1126)
		p.Match(ApexParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1127)
		p.SubFieldList()
	}
	{
		p.SetState(1128)
		p.Match(ApexParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1129)
		p.FromNameList()
	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserWHERE {
		{
			p.SetState(1130)
			p.WhereClause()
		}

	}
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserORDER {
		{
			p.SetState(1133)
			p.OrderByClause()
		}

	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserLIMIT {
		{
			p.SetState(1136)
			p.LimitClause()
		}

	}
	{
		p.SetState(1139)
		p.ForClauses()
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserUPDATE {
		{
			p.SetState(1140)
			p.Match(ApexParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1141)
			p.UpdateList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectListContext is an interface to support dynamic dispatch.
type ISelectListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectEntry() []ISelectEntryContext
	SelectEntry(i int) ISelectEntryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectListContext differentiates from other interfaces.
	IsSelectListContext()
}

type SelectListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectListContext() *SelectListContext {
	var p = new(SelectListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectList
	return p
}

func InitEmptySelectListContext(p *SelectListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectList
}

func (*SelectListContext) IsSelectListContext() {}

func NewSelectListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectListContext {
	var p = new(SelectListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_selectList

	return p
}

func (s *SelectListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectListContext) AllSelectEntry() []ISelectEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectEntryContext); ok {
			len++
		}
	}

	tst := make([]ISelectEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectEntryContext); ok {
			tst[i] = t.(ISelectEntryContext)
			i++
		}
	}

	return tst
}

func (s *SelectListContext) SelectEntry(i int) ISelectEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectEntryContext)
}

func (s *SelectListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *SelectListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *SelectListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSelectList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SelectList() (localctx ISelectListContext) {
	localctx = NewSelectListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ApexParserRULE_selectList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		p.SelectEntry()
	}
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1145)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1146)
			p.SelectEntry()
		}

		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectEntryContext is an interface to support dynamic dispatch.
type ISelectEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	SoqlId() ISoqlIdContext
	SoqlFunction() ISoqlFunctionContext
	LPAREN() antlr.TerminalNode
	SubQuery() ISubQueryContext
	RPAREN() antlr.TerminalNode
	TypeOf() ITypeOfContext

	// IsSelectEntryContext differentiates from other interfaces.
	IsSelectEntryContext()
}

type SelectEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectEntryContext() *SelectEntryContext {
	var p = new(SelectEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectEntry
	return p
}

func InitEmptySelectEntryContext(p *SelectEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectEntry
}

func (*SelectEntryContext) IsSelectEntryContext() {}

func NewSelectEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectEntryContext {
	var p = new(SelectEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_selectEntry

	return p
}

func (s *SelectEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectEntryContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SelectEntryContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *SelectEntryContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *SelectEntryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SelectEntryContext) SubQuery() ISubQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryContext)
}

func (s *SelectEntryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *SelectEntryContext) TypeOf() ITypeOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeOfContext)
}

func (s *SelectEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSelectEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SelectEntry() (localctx ISelectEntryContext) {
	localctx = NewSelectEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ApexParserRULE_selectEntry)
	p.SetState(1167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1152)
			p.FieldName()
		}
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1153)
				p.SoqlId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1156)
			p.SoqlFunction()
		}
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1157)
				p.SoqlId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1160)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1161)
			p.SubQuery()
		}
		{
			p.SetState(1162)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1164)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1163)
				p.SoqlId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1166)
			p.TypeOf()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldNameContext is an interface to support dynamic dispatch.
type IFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSoqlId() []ISoqlIdContext
	SoqlId(i int) ISoqlIdContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsFieldNameContext differentiates from other interfaces.
	IsFieldNameContext()
}

type FieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameContext() *FieldNameContext {
	var p = new(FieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldName
	return p
}

func InitEmptyFieldNameContext(p *FieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldName
}

func (*FieldNameContext) IsFieldNameContext() {}

func NewFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameContext {
	var p = new(FieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldName

	return p
}

func (s *FieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameContext) AllSoqlId() []ISoqlIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoqlIdContext); ok {
			len++
		}
	}

	tst := make([]ISoqlIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoqlIdContext); ok {
			tst[i] = t.(ISoqlIdContext)
			i++
		}
	}

	return tst
}

func (s *FieldNameContext) SoqlId(i int) ISoqlIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *FieldNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *FieldNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *FieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldName() (localctx IFieldNameContext) {
	localctx = NewFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ApexParserRULE_fieldName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1169)
		p.SoqlId()
	}
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserDOT {
		{
			p.SetState(1170)
			p.Match(ApexParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1171)
			p.SoqlId()
		}

		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromNameListContext is an interface to support dynamic dispatch.
type IFromNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldNameAlias() []IFieldNameAliasContext
	FieldNameAlias(i int) IFieldNameAliasContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFromNameListContext differentiates from other interfaces.
	IsFromNameListContext()
}

type FromNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromNameListContext() *FromNameListContext {
	var p = new(FromNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fromNameList
	return p
}

func InitEmptyFromNameListContext(p *FromNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fromNameList
}

func (*FromNameListContext) IsFromNameListContext() {}

func NewFromNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromNameListContext {
	var p = new(FromNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fromNameList

	return p
}

func (s *FromNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FromNameListContext) AllFieldNameAlias() []IFieldNameAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameAliasContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameAliasContext); ok {
			tst[i] = t.(IFieldNameAliasContext)
			i++
		}
	}

	return tst
}

func (s *FromNameListContext) FieldNameAlias(i int) IFieldNameAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameAliasContext)
}

func (s *FromNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FromNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FromNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFromNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FromNameList() (localctx IFromNameListContext) {
	localctx = NewFromNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ApexParserRULE_fromNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1177)
		p.FieldNameAlias()
	}
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1178)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1179)
			p.FieldNameAlias()
		}

		p.SetState(1184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldNameAliasContext is an interface to support dynamic dispatch.
type IFieldNameAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	SoqlId() ISoqlIdContext

	// IsFieldNameAliasContext differentiates from other interfaces.
	IsFieldNameAliasContext()
}

type FieldNameAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameAliasContext() *FieldNameAliasContext {
	var p = new(FieldNameAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldNameAlias
	return p
}

func InitEmptyFieldNameAliasContext(p *FieldNameAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldNameAlias
}

func (*FieldNameAliasContext) IsFieldNameAliasContext() {}

func NewFieldNameAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameAliasContext {
	var p = new(FieldNameAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldNameAlias

	return p
}

func (s *FieldNameAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameAliasContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldNameAliasContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *FieldNameAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldNameAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldNameAlias() (localctx IFieldNameAliasContext) {
	localctx = NewFieldNameAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ApexParserRULE_fieldNameAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1185)
		p.FieldName()
	}
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1186)
			p.SoqlId()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubFieldListContext is an interface to support dynamic dispatch.
type ISubFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubFieldEntry() []ISubFieldEntryContext
	SubFieldEntry(i int) ISubFieldEntryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSubFieldListContext differentiates from other interfaces.
	IsSubFieldListContext()
}

type SubFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubFieldListContext() *SubFieldListContext {
	var p = new(SubFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldList
	return p
}

func InitEmptySubFieldListContext(p *SubFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldList
}

func (*SubFieldListContext) IsSubFieldListContext() {}

func NewSubFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubFieldListContext {
	var p = new(SubFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_subFieldList

	return p
}

func (s *SubFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *SubFieldListContext) AllSubFieldEntry() []ISubFieldEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubFieldEntryContext); ok {
			len++
		}
	}

	tst := make([]ISubFieldEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubFieldEntryContext); ok {
			tst[i] = t.(ISubFieldEntryContext)
			i++
		}
	}

	return tst
}

func (s *SubFieldListContext) SubFieldEntry(i int) ISubFieldEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubFieldEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubFieldEntryContext)
}

func (s *SubFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *SubFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *SubFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSubFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SubFieldList() (localctx ISubFieldListContext) {
	localctx = NewSubFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ApexParserRULE_subFieldList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1189)
		p.SubFieldEntry()
	}
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1190)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1191)
			p.SubFieldEntry()
		}

		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubFieldEntryContext is an interface to support dynamic dispatch.
type ISubFieldEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	SoqlId() ISoqlIdContext
	SoqlFunction() ISoqlFunctionContext
	TypeOf() ITypeOfContext

	// IsSubFieldEntryContext differentiates from other interfaces.
	IsSubFieldEntryContext()
}

type SubFieldEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubFieldEntryContext() *SubFieldEntryContext {
	var p = new(SubFieldEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldEntry
	return p
}

func InitEmptySubFieldEntryContext(p *SubFieldEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldEntry
}

func (*SubFieldEntryContext) IsSubFieldEntryContext() {}

func NewSubFieldEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubFieldEntryContext {
	var p = new(SubFieldEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_subFieldEntry

	return p
}

func (s *SubFieldEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubFieldEntryContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SubFieldEntryContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *SubFieldEntryContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *SubFieldEntryContext) TypeOf() ITypeOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeOfContext)
}

func (s *SubFieldEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubFieldEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubFieldEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSubFieldEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SubFieldEntry() (localctx ISubFieldEntryContext) {
	localctx = NewSubFieldEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ApexParserRULE_subFieldEntry)
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1197)
			p.FieldName()
		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1198)
				p.SoqlId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1201)
			p.SoqlFunction()
		}
		p.SetState(1203)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1202)
				p.SoqlId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1205)
			p.TypeOf()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoqlFieldsParameterContext is an interface to support dynamic dispatch.
type ISoqlFieldsParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	CUSTOM() antlr.TerminalNode
	STANDARD() antlr.TerminalNode

	// IsSoqlFieldsParameterContext differentiates from other interfaces.
	IsSoqlFieldsParameterContext()
}

type SoqlFieldsParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlFieldsParameterContext() *SoqlFieldsParameterContext {
	var p = new(SoqlFieldsParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFieldsParameter
	return p
}

func InitEmptySoqlFieldsParameterContext(p *SoqlFieldsParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFieldsParameter
}

func (*SoqlFieldsParameterContext) IsSoqlFieldsParameterContext() {}

func NewSoqlFieldsParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlFieldsParameterContext {
	var p = new(SoqlFieldsParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlFieldsParameter

	return p
}

func (s *SoqlFieldsParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlFieldsParameterContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *SoqlFieldsParameterContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(ApexParserCUSTOM, 0)
}

func (s *SoqlFieldsParameterContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(ApexParserSTANDARD, 0)
}

func (s *SoqlFieldsParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFieldsParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoqlFieldsParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoqlFieldsParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoqlFieldsParameter() (localctx ISoqlFieldsParameterContext) {
	localctx = NewSoqlFieldsParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ApexParserRULE_soqlFieldsParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&1572865) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoqlFunctionContext is an interface to support dynamic dispatch.
type ISoqlFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AVG() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	FieldName() IFieldNameContext
	RPAREN() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	COUNT_DISTINCT() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MAX() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TOLABEL() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	CALENDAR_MONTH() antlr.TerminalNode
	DateFieldName() IDateFieldNameContext
	CALENDAR_QUARTER() antlr.TerminalNode
	CALENDAR_YEAR() antlr.TerminalNode
	DAY_IN_MONTH() antlr.TerminalNode
	DAY_IN_WEEK() antlr.TerminalNode
	DAY_IN_YEAR() antlr.TerminalNode
	DAY_ONLY() antlr.TerminalNode
	FISCAL_MONTH() antlr.TerminalNode
	FISCAL_QUARTER() antlr.TerminalNode
	FISCAL_YEAR() antlr.TerminalNode
	HOUR_IN_DAY() antlr.TerminalNode
	WEEK_IN_MONTH() antlr.TerminalNode
	WEEK_IN_YEAR() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	SoqlFieldsParameter() ISoqlFieldsParameterContext

	// IsSoqlFunctionContext differentiates from other interfaces.
	IsSoqlFunctionContext()
}

type SoqlFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlFunctionContext() *SoqlFunctionContext {
	var p = new(SoqlFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFunction
	return p
}

func InitEmptySoqlFunctionContext(p *SoqlFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFunction
}

func (*SoqlFunctionContext) IsSoqlFunctionContext() {}

func NewSoqlFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlFunctionContext {
	var p = new(SoqlFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlFunction

	return p
}

func (s *SoqlFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(ApexParserAVG, 0)
}

func (s *SoqlFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SoqlFunctionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SoqlFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *SoqlFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT, 0)
}

func (s *SoqlFunctionContext) COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT_DISTINCT, 0)
}

func (s *SoqlFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(ApexParserMIN, 0)
}

func (s *SoqlFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(ApexParserMAX, 0)
}

func (s *SoqlFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(ApexParserSUM, 0)
}

func (s *SoqlFunctionContext) TOLABEL() antlr.TerminalNode {
	return s.GetToken(ApexParserTOLABEL, 0)
}

func (s *SoqlFunctionContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ApexParserFORMAT, 0)
}

func (s *SoqlFunctionContext) CALENDAR_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_MONTH, 0)
}

func (s *SoqlFunctionContext) DateFieldName() IDateFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateFieldNameContext)
}

func (s *SoqlFunctionContext) CALENDAR_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_QUARTER, 0)
}

func (s *SoqlFunctionContext) CALENDAR_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_YEAR, 0)
}

func (s *SoqlFunctionContext) DAY_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_MONTH, 0)
}

func (s *SoqlFunctionContext) DAY_IN_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_WEEK, 0)
}

func (s *SoqlFunctionContext) DAY_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_YEAR, 0)
}

func (s *SoqlFunctionContext) DAY_ONLY() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_ONLY, 0)
}

func (s *SoqlFunctionContext) FISCAL_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_MONTH, 0)
}

func (s *SoqlFunctionContext) FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_QUARTER, 0)
}

func (s *SoqlFunctionContext) FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_YEAR, 0)
}

func (s *SoqlFunctionContext) HOUR_IN_DAY() antlr.TerminalNode {
	return s.GetToken(ApexParserHOUR_IN_DAY, 0)
}

func (s *SoqlFunctionContext) WEEK_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_MONTH, 0)
}

func (s *SoqlFunctionContext) WEEK_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_YEAR, 0)
}

func (s *SoqlFunctionContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *SoqlFunctionContext) SoqlFieldsParameter() ISoqlFieldsParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFieldsParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFieldsParameterContext)
}

func (s *SoqlFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoqlFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoqlFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoqlFunction() (localctx ISoqlFunctionContext) {
	localctx = NewSoqlFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ApexParserRULE_soqlFunction)
	p.SetState(1323)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1210)
			p.Match(ApexParserAVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1211)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1212)
			p.FieldName()
		}
		{
			p.SetState(1213)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1215)
			p.Match(ApexParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1216)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1217)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1218)
			p.Match(ApexParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1219)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1220)
			p.FieldName()
		}
		{
			p.SetState(1221)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1223)
			p.Match(ApexParserCOUNT_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1224)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1225)
			p.FieldName()
		}
		{
			p.SetState(1226)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1228)
			p.Match(ApexParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1229)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1230)
			p.FieldName()
		}
		{
			p.SetState(1231)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1233)
			p.Match(ApexParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1234)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1235)
			p.FieldName()
		}
		{
			p.SetState(1236)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1238)
			p.Match(ApexParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1239)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1240)
			p.FieldName()
		}
		{
			p.SetState(1241)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1243)
			p.Match(ApexParserTOLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1244)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1245)
			p.FieldName()
		}
		{
			p.SetState(1246)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1248)
			p.Match(ApexParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1249)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1250)
			p.FieldName()
		}
		{
			p.SetState(1251)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1253)
			p.Match(ApexParserCALENDAR_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1254)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1255)
			p.DateFieldName()
		}
		{
			p.SetState(1256)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1258)
			p.Match(ApexParserCALENDAR_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1259)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1260)
			p.DateFieldName()
		}
		{
			p.SetState(1261)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1263)
			p.Match(ApexParserCALENDAR_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1264)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1265)
			p.DateFieldName()
		}
		{
			p.SetState(1266)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1268)
			p.Match(ApexParserDAY_IN_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1269)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1270)
			p.DateFieldName()
		}
		{
			p.SetState(1271)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1273)
			p.Match(ApexParserDAY_IN_WEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1274)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1275)
			p.DateFieldName()
		}
		{
			p.SetState(1276)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1278)
			p.Match(ApexParserDAY_IN_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1279)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1280)
			p.DateFieldName()
		}
		{
			p.SetState(1281)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1283)
			p.Match(ApexParserDAY_ONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1284)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1285)
			p.DateFieldName()
		}
		{
			p.SetState(1286)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1288)
			p.Match(ApexParserFISCAL_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1289)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1290)
			p.DateFieldName()
		}
		{
			p.SetState(1291)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1293)
			p.Match(ApexParserFISCAL_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1294)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1295)
			p.DateFieldName()
		}
		{
			p.SetState(1296)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1298)
			p.Match(ApexParserFISCAL_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1299)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1300)
			p.DateFieldName()
		}
		{
			p.SetState(1301)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1303)
			p.Match(ApexParserHOUR_IN_DAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1304)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1305)
			p.DateFieldName()
		}
		{
			p.SetState(1306)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1308)
			p.Match(ApexParserWEEK_IN_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1309)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1310)
			p.DateFieldName()
		}
		{
			p.SetState(1311)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1313)
			p.Match(ApexParserWEEK_IN_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1315)
			p.DateFieldName()
		}
		{
			p.SetState(1316)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1318)
			p.Match(ApexParserFIELDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1319)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1320)
			p.SoqlFieldsParameter()
		}
		{
			p.SetState(1321)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateFieldNameContext is an interface to support dynamic dispatch.
type IDateFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONVERT_TIMEZONE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	FieldName() IFieldNameContext
	RPAREN() antlr.TerminalNode

	// IsDateFieldNameContext differentiates from other interfaces.
	IsDateFieldNameContext()
}

type DateFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateFieldNameContext() *DateFieldNameContext {
	var p = new(DateFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFieldName
	return p
}

func InitEmptyDateFieldNameContext(p *DateFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFieldName
}

func (*DateFieldNameContext) IsDateFieldNameContext() {}

func NewDateFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateFieldNameContext {
	var p = new(DateFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dateFieldName

	return p
}

func (s *DateFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DateFieldNameContext) CONVERT_TIMEZONE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_TIMEZONE, 0)
}

func (s *DateFieldNameContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *DateFieldNameContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *DateFieldNameContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *DateFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDateFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DateFieldName() (localctx IDateFieldNameContext) {
	localctx = NewDateFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ApexParserRULE_dateFieldName)
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1325)
			p.Match(ApexParserCONVERT_TIMEZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1327)
			p.FieldName()
		}
		{
			p.SetState(1328)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1330)
			p.FieldName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeOfContext is an interface to support dynamic dispatch.
type ITypeOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPEOF() antlr.TerminalNode
	FieldName() IFieldNameContext
	END() antlr.TerminalNode
	AllWhenClause() []IWhenClauseContext
	WhenClause(i int) IWhenClauseContext
	ElseClause() IElseClauseContext

	// IsTypeOfContext differentiates from other interfaces.
	IsTypeOfContext()
}

type TypeOfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeOfContext() *TypeOfContext {
	var p = new(TypeOfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeOf
	return p
}

func InitEmptyTypeOfContext(p *TypeOfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeOf
}

func (*TypeOfContext) IsTypeOfContext() {}

func NewTypeOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeOfContext {
	var p = new(TypeOfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeOf

	return p
}

func (s *TypeOfContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeOfContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserTYPEOF, 0)
}

func (s *TypeOfContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *TypeOfContext) END() antlr.TerminalNode {
	return s.GetToken(ApexParserEND, 0)
}

func (s *TypeOfContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *TypeOfContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *TypeOfContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *TypeOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeOfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitTypeOf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) TypeOf() (localctx ITypeOfContext) {
	localctx = NewTypeOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ApexParserRULE_typeOf)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1333)
		p.Match(ApexParserTYPEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1334)
		p.FieldName()
	}
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ApexParserWHEN {
		{
			p.SetState(1335)
			p.WhenClause()
		}

		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserELSE {
		{
			p.SetState(1340)
			p.ElseClause()
		}

	}
	{
		p.SetState(1343)
		p.Match(ApexParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	FieldName() IFieldNameContext
	THEN() antlr.TerminalNode
	FieldNameList() IFieldNameListContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *WhenClauseContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(ApexParserTHEN, 0)
}

func (s *WhenClauseContext) FieldNameList() IFieldNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameListContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ApexParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1345)
		p.Match(ApexParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1346)
		p.FieldName()
	}
	{
		p.SetState(1347)
		p.Match(ApexParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1348)
		p.FieldNameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseClauseContext is an interface to support dynamic dispatch.
type IElseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	FieldNameList() IFieldNameListContext

	// IsElseClauseContext differentiates from other interfaces.
	IsElseClauseContext()
}

type ElseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseClauseContext() *ElseClauseContext {
	var p = new(ElseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elseClause
	return p
}

func InitEmptyElseClauseContext(p *ElseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elseClause
}

func (*ElseClauseContext) IsElseClauseContext() {}

func NewElseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseClauseContext {
	var p = new(ElseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elseClause

	return p
}

func (s *ElseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseClauseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *ElseClauseContext) FieldNameList() IFieldNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameListContext)
}

func (s *ElseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitElseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ElseClause() (localctx IElseClauseContext) {
	localctx = NewElseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ApexParserRULE_elseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1350)
		p.Match(ApexParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1351)
		p.FieldNameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldNameListContext is an interface to support dynamic dispatch.
type IFieldNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldNameListContext differentiates from other interfaces.
	IsFieldNameListContext()
}

type FieldNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameListContext() *FieldNameListContext {
	var p = new(FieldNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldNameList
	return p
}

func InitEmptyFieldNameListContext(p *FieldNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldNameList
}

func (*FieldNameListContext) IsFieldNameListContext() {}

func NewFieldNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameListContext {
	var p = new(FieldNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldNameList

	return p
}

func (s *FieldNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameListContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *FieldNameListContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldNameList() (localctx IFieldNameListContext) {
	localctx = NewFieldNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ApexParserRULE_fieldNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1353)
		p.FieldName()
	}
	p.SetState(1358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1354)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1355)
			p.FieldName()
		}

		p.SetState(1360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingScopeContext is an interface to support dynamic dispatch.
type IUsingScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	SCOPE() antlr.TerminalNode
	SoqlId() ISoqlIdContext

	// IsUsingScopeContext differentiates from other interfaces.
	IsUsingScopeContext()
}

type UsingScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingScopeContext() *UsingScopeContext {
	var p = new(UsingScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_usingScope
	return p
}

func InitEmptyUsingScopeContext(p *UsingScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_usingScope
}

func (*UsingScopeContext) IsUsingScopeContext() {}

func NewUsingScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingScopeContext {
	var p = new(UsingScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_usingScope

	return p
}

func (s *UsingScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingScopeContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *UsingScopeContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(ApexParserSCOPE, 0)
}

func (s *UsingScopeContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *UsingScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingScopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitUsingScope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) UsingScope() (localctx IUsingScopeContext) {
	localctx = NewUsingScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ApexParserRULE_usingScope)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1361)
		p.Match(ApexParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1362)
		p.Match(ApexParserSCOPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1363)
		p.SoqlId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *WhereClauseContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ApexParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1365)
		p.Match(ApexParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1366)
		p.LogicalExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalExpressionContext is an interface to support dynamic dispatch.
type ILogicalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConditionalExpression() []IConditionalExpressionContext
	ConditionalExpression(i int) IConditionalExpressionContext
	AllSOQLAND() []antlr.TerminalNode
	SOQLAND(i int) antlr.TerminalNode
	AllSOQLOR() []antlr.TerminalNode
	SOQLOR(i int) antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsLogicalExpressionContext differentiates from other interfaces.
	IsLogicalExpressionContext()
}

type LogicalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalExpressionContext() *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_logicalExpression
	return p
}

func InitEmptyLogicalExpressionContext(p *LogicalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_logicalExpression
}

func (*LogicalExpressionContext) IsLogicalExpressionContext() {}

func NewLogicalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_logicalExpression

	return p
}

func (s *LogicalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalExpressionContext) AllConditionalExpression() []IConditionalExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			len++
		}
	}

	tst := make([]IConditionalExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionalExpressionContext); ok {
			tst[i] = t.(IConditionalExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) ConditionalExpression(i int) IConditionalExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *LogicalExpressionContext) AllSOQLAND() []antlr.TerminalNode {
	return s.GetTokens(ApexParserSOQLAND)
}

func (s *LogicalExpressionContext) SOQLAND(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLAND, i)
}

func (s *LogicalExpressionContext) AllSOQLOR() []antlr.TerminalNode {
	return s.GetTokens(ApexParserSOQLOR)
}

func (s *LogicalExpressionContext) SOQLOR(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLOR, i)
}

func (s *LogicalExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) LogicalExpression() (localctx ILogicalExpressionContext) {
	localctx = NewLogicalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ApexParserRULE_logicalExpression)
	var _la int

	p.SetState(1386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1368)
			p.ConditionalExpression()
		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ApexParserSOQLAND {
			{
				p.SetState(1369)
				p.Match(ApexParserSOQLAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1370)
				p.ConditionalExpression()
			}

			p.SetState(1375)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1376)
			p.ConditionalExpression()
		}
		p.SetState(1381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ApexParserSOQLOR {
			{
				p.SetState(1377)
				p.Match(ApexParserSOQLOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1378)
				p.ConditionalExpression()
			}

			p.SetState(1383)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1384)
			p.Match(ApexParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1385)
			p.ConditionalExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext
	RPAREN() antlr.TerminalNode
	FieldExpression() IFieldExpressionContext

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_conditionalExpression
	return p
}

func InitEmptyConditionalExpressionContext(p *ConditionalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_conditionalExpression
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ConditionalExpressionContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *ConditionalExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ConditionalExpressionContext) FieldExpression() IFieldExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldExpressionContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitConditionalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ApexParserRULE_conditionalExpression)
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1388)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1389)
			p.LogicalExpression()
		}
		{
			p.SetState(1390)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1392)
			p.FieldExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldExpressionContext is an interface to support dynamic dispatch.
type IFieldExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	ComparisonOperator() IComparisonOperatorContext
	Value() IValueContext
	SoqlFunction() ISoqlFunctionContext

	// IsFieldExpressionContext differentiates from other interfaces.
	IsFieldExpressionContext()
}

type FieldExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldExpressionContext() *FieldExpressionContext {
	var p = new(FieldExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldExpression
	return p
}

func InitEmptyFieldExpressionContext(p *FieldExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldExpression
}

func (*FieldExpressionContext) IsFieldExpressionContext() {}

func NewFieldExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldExpressionContext {
	var p = new(FieldExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldExpression

	return p
}

func (s *FieldExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldExpressionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldExpressionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *FieldExpressionContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *FieldExpressionContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *FieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldExpression() (localctx IFieldExpressionContext) {
	localctx = NewFieldExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ApexParserRULE_fieldExpression)
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1395)
			p.FieldName()
		}
		{
			p.SetState(1396)
			p.ComparisonOperator()
		}
		{
			p.SetState(1397)
			p.Value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1399)
			p.SoqlFunction()
		}
		{
			p.SetState(1400)
			p.ComparisonOperator()
		}
		{
			p.SetState(1401)
			p.Value()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	NOTEQUAL() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LESSANDGREATER() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	NOT() antlr.TerminalNode
	INCLUDES() antlr.TerminalNode
	EXCLUDES() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *ComparisonOperatorContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserNOTEQUAL, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *ComparisonOperatorContext) LESSANDGREATER() antlr.TerminalNode {
	return s.GetToken(ApexParserLESSANDGREATER, 0)
}

func (s *ComparisonOperatorContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ApexParserLIKE, 0)
}

func (s *ComparisonOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *ComparisonOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *ComparisonOperatorContext) INCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserINCLUDES, 0)
}

func (s *ComparisonOperatorContext) EXCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserEXCLUDES, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ApexParserRULE_comparisonOperator)
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1405)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1406)
			p.Match(ApexParserNOTEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1407)
			p.Match(ApexParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1408)
			p.Match(ApexParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1409)
			p.Match(ApexParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1410)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1411)
			p.Match(ApexParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1413)
			p.Match(ApexParserLESSANDGREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1414)
			p.Match(ApexParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1415)
			p.Match(ApexParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1416)
			p.Match(ApexParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1417)
			p.Match(ApexParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1418)
			p.Match(ApexParserINCLUDES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1419)
			p.Match(ApexParserEXCLUDES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	SignedNumber() ISignedNumberContext
	StringLiteral() antlr.TerminalNode
	DateLiteral() antlr.TerminalNode
	DateTimeLiteral() antlr.TerminalNode
	DateFormula() IDateFormulaContext
	IntegralCurrencyLiteral() antlr.TerminalNode
	DOT() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	SubQuery() ISubQueryContext
	RPAREN() antlr.TerminalNode
	ValueList() IValueListContext
	BoundExpression() IBoundExpressionContext

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *ValueContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserBooleanLiteral, 0)
}

func (s *ValueContext) SignedNumber() ISignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *ValueContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *ValueContext) DateLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserDateLiteral, 0)
}

func (s *ValueContext) DateTimeLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserDateTimeLiteral, 0)
}

func (s *ValueContext) DateFormula() IDateFormulaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateFormulaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateFormulaContext)
}

func (s *ValueContext) IntegralCurrencyLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegralCurrencyLiteral, 0)
}

func (s *ValueContext) DOT() antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, 0)
}

func (s *ValueContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *ValueContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ValueContext) SubQuery() ISubQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryContext)
}

func (s *ValueContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ValueContext) ValueList() IValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueListContext)
}

func (s *ValueContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ApexParserRULE_value)
	var _la int

	p.SetState(1442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1422)
			p.Match(ApexParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1423)
			p.Match(ApexParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1424)
			p.SignedNumber()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1425)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1426)
			p.Match(ApexParserDateLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1427)
			p.Match(ApexParserDateTimeLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1428)
			p.DateFormula()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1429)
			p.Match(ApexParserIntegralCurrencyLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserDOT {
			{
				p.SetState(1430)
				p.Match(ApexParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1432)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ApexParserIntegerLiteral {
				{
					p.SetState(1431)
					p.Match(ApexParserIntegerLiteral)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1436)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1437)
			p.SubQuery()
		}
		{
			p.SetState(1438)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1440)
			p.ValueList()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1441)
			p.BoundExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueListContext is an interface to support dynamic dispatch.
type IValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllValue() []IValueContext
	Value(i int) IValueContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValueListContext differentiates from other interfaces.
	IsValueListContext()
}

type ValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueListContext() *ValueListContext {
	var p = new(ValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_valueList
	return p
}

func InitEmptyValueListContext(p *ValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_valueList
}

func (*ValueListContext) IsValueListContext() {}

func NewValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueListContext {
	var p = new(ValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_valueList

	return p
}

func (s *ValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ValueListContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ValueListContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ValueList() (localctx IValueListContext) {
	localctx = NewValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ApexParserRULE_valueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1444)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1445)
		p.Value()
	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1446)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1447)
			p.Value()
		}

		p.SetState(1452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1453)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedNumberContext is an interface to support dynamic dispatch.
type ISignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsSignedNumberContext differentiates from other interfaces.
	IsSignedNumberContext()
}

type SignedNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedNumberContext() *SignedNumberContext {
	var p = new(SignedNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedNumber
	return p
}

func InitEmptySignedNumberContext(p *SignedNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedNumber
}

func (*SignedNumberContext) IsSignedNumberContext() {}

func NewSignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedNumberContext {
	var p = new(SignedNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_signedNumber

	return p
}

func (s *SignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedNumberContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *SignedNumberContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserNumberLiteral, 0)
}

func (s *SignedNumberContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *SignedNumberContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *SignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SignedNumber() (localctx ISignedNumberContext) {
	localctx = NewSignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ApexParserRULE_signedNumber)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserADD || _la == ApexParserSUB {
		{
			p.SetState(1455)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ApexParserADD || _la == ApexParserSUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1458)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserIntegerLiteral || _la == ApexParserNumberLiteral) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	FilteringExpression() IFilteringExpressionContext
	SECURITY_ENFORCED() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *WithClauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *WithClauseContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *WithClauseContext) FilteringExpression() IFilteringExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilteringExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilteringExpressionContext)
}

func (s *WithClauseContext) SECURITY_ENFORCED() antlr.TerminalNode {
	return s.GetToken(ApexParserSECURITY_ENFORCED, 0)
}

func (s *WithClauseContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ApexParserRULE_withClause)
	p.SetState(1468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1460)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1461)
			p.Match(ApexParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1462)
			p.Match(ApexParserCATEGORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1463)
			p.FilteringExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1464)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1465)
			p.Match(ApexParserSECURITY_ENFORCED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1466)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1467)
			p.LogicalExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilteringExpressionContext is an interface to support dynamic dispatch.
type IFilteringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataCategorySelection() []IDataCategorySelectionContext
	DataCategorySelection(i int) IDataCategorySelectionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsFilteringExpressionContext differentiates from other interfaces.
	IsFilteringExpressionContext()
}

type FilteringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilteringExpressionContext() *FilteringExpressionContext {
	var p = new(FilteringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringExpression
	return p
}

func InitEmptyFilteringExpressionContext(p *FilteringExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringExpression
}

func (*FilteringExpressionContext) IsFilteringExpressionContext() {}

func NewFilteringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilteringExpressionContext {
	var p = new(FilteringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_filteringExpression

	return p
}

func (s *FilteringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilteringExpressionContext) AllDataCategorySelection() []IDataCategorySelectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataCategorySelectionContext); ok {
			len++
		}
	}

	tst := make([]IDataCategorySelectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataCategorySelectionContext); ok {
			tst[i] = t.(IDataCategorySelectionContext)
			i++
		}
	}

	return tst
}

func (s *FilteringExpressionContext) DataCategorySelection(i int) IDataCategorySelectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCategorySelectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCategorySelectionContext)
}

func (s *FilteringExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(ApexParserAND)
}

func (s *FilteringExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserAND, i)
}

func (s *FilteringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilteringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilteringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFilteringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FilteringExpression() (localctx IFilteringExpressionContext) {
	localctx = NewFilteringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ApexParserRULE_filteringExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1470)
		p.DataCategorySelection()
	}
	p.SetState(1475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserAND {
		{
			p.SetState(1471)
			p.Match(ApexParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1472)
			p.DataCategorySelection()
		}

		p.SetState(1477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCategorySelectionContext is an interface to support dynamic dispatch.
type IDataCategorySelectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SoqlId() ISoqlIdContext
	FilteringSelector() IFilteringSelectorContext
	DataCategoryName() IDataCategoryNameContext

	// IsDataCategorySelectionContext differentiates from other interfaces.
	IsDataCategorySelectionContext()
}

type DataCategorySelectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCategorySelectionContext() *DataCategorySelectionContext {
	var p = new(DataCategorySelectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategorySelection
	return p
}

func InitEmptyDataCategorySelectionContext(p *DataCategorySelectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategorySelection
}

func (*DataCategorySelectionContext) IsDataCategorySelectionContext() {}

func NewDataCategorySelectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCategorySelectionContext {
	var p = new(DataCategorySelectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dataCategorySelection

	return p
}

func (s *DataCategorySelectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCategorySelectionContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *DataCategorySelectionContext) FilteringSelector() IFilteringSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilteringSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilteringSelectorContext)
}

func (s *DataCategorySelectionContext) DataCategoryName() IDataCategoryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCategoryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCategoryNameContext)
}

func (s *DataCategorySelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCategorySelectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCategorySelectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDataCategorySelection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DataCategorySelection() (localctx IDataCategorySelectionContext) {
	localctx = NewDataCategorySelectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ApexParserRULE_dataCategorySelection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1478)
		p.SoqlId()
	}
	{
		p.SetState(1479)
		p.FilteringSelector()
	}
	{
		p.SetState(1480)
		p.DataCategoryName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCategoryNameContext is an interface to support dynamic dispatch.
type IDataCategoryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSoqlId() []ISoqlIdContext
	SoqlId(i int) ISoqlIdContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDataCategoryNameContext differentiates from other interfaces.
	IsDataCategoryNameContext()
}

type DataCategoryNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCategoryNameContext() *DataCategoryNameContext {
	var p = new(DataCategoryNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategoryName
	return p
}

func InitEmptyDataCategoryNameContext(p *DataCategoryNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategoryName
}

func (*DataCategoryNameContext) IsDataCategoryNameContext() {}

func NewDataCategoryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCategoryNameContext {
	var p = new(DataCategoryNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dataCategoryName

	return p
}

func (s *DataCategoryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCategoryNameContext) AllSoqlId() []ISoqlIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoqlIdContext); ok {
			len++
		}
	}

	tst := make([]ISoqlIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoqlIdContext); ok {
			tst[i] = t.(ISoqlIdContext)
			i++
		}
	}

	return tst
}

func (s *DataCategoryNameContext) SoqlId(i int) ISoqlIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *DataCategoryNameContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ApexParserLPAREN)
}

func (s *DataCategoryNameContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, i)
}

func (s *DataCategoryNameContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *DataCategoryNameContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *DataCategoryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCategoryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCategoryNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDataCategoryName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DataCategoryName() (localctx IDataCategoryNameContext) {
	localctx = NewDataCategoryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ApexParserRULE_dataCategoryName)
	var _la int

	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1482)
			p.SoqlId()
		}

	case ApexParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1483)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.SoqlId()
		}
		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ApexParserCOMMA {
			{
				p.SetState(1485)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1486)
				p.SoqlId()
			}

			p.SetState(1491)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1492)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilteringSelectorContext is an interface to support dynamic dispatch.
type IFilteringSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	ABOVE() antlr.TerminalNode
	BELOW() antlr.TerminalNode
	ABOVE_OR_BELOW() antlr.TerminalNode

	// IsFilteringSelectorContext differentiates from other interfaces.
	IsFilteringSelectorContext()
}

type FilteringSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilteringSelectorContext() *FilteringSelectorContext {
	var p = new(FilteringSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringSelector
	return p
}

func InitEmptyFilteringSelectorContext(p *FilteringSelectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringSelector
}

func (*FilteringSelectorContext) IsFilteringSelectorContext() {}

func NewFilteringSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilteringSelectorContext {
	var p = new(FilteringSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_filteringSelector

	return p
}

func (s *FilteringSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *FilteringSelectorContext) AT() antlr.TerminalNode {
	return s.GetToken(ApexParserAT, 0)
}

func (s *FilteringSelectorContext) ABOVE() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE, 0)
}

func (s *FilteringSelectorContext) BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserBELOW, 0)
}

func (s *FilteringSelectorContext) ABOVE_OR_BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE_OR_BELOW, 0)
}

func (s *FilteringSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilteringSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilteringSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFilteringSelector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FilteringSelector() (localctx IFilteringSelectorContext) {
	localctx = NewFilteringSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ApexParserRULE_filteringSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1496)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	SelectList() ISelectListContext
	HAVING() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext
	ROLLUP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CUBE() antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *GroupByClauseContext) SelectList() ISelectListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectListContext)
}

func (s *GroupByClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ApexParserHAVING, 0)
}

func (s *GroupByClauseContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ApexParserROLLUP, 0)
}

func (s *GroupByClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *GroupByClauseContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *GroupByClauseContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *GroupByClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *GroupByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *GroupByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *GroupByClauseContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ApexParserCUBE, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ApexParserRULE_groupByClause)
	var _la int

	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1498)
			p.Match(ApexParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1499)
			p.Match(ApexParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)
			p.SelectList()
		}
		p.SetState(1503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserHAVING {
			{
				p.SetState(1501)
				p.Match(ApexParserHAVING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1502)
				p.LogicalExpression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1505)
			p.Match(ApexParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1506)
			p.Match(ApexParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1507)
			p.Match(ApexParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1508)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1509)
			p.FieldName()
		}
		p.SetState(1514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ApexParserCOMMA {
			{
				p.SetState(1510)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1511)
				p.FieldName()
			}

			p.SetState(1516)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1517)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1519)
			p.Match(ApexParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1520)
			p.Match(ApexParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1521)
			p.Match(ApexParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1522)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)
			p.FieldName()
		}
		p.SetState(1528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ApexParserCOMMA {
			{
				p.SetState(1524)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1525)
				p.FieldName()
			}

			p.SetState(1530)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1531)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldOrderList() IFieldOrderListContext

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *OrderByClauseContext) FieldOrderList() IFieldOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrderListContext)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ApexParserRULE_orderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1535)
		p.Match(ApexParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1536)
		p.Match(ApexParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1537)
		p.FieldOrderList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldOrderListContext is an interface to support dynamic dispatch.
type IFieldOrderListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldOrder() []IFieldOrderContext
	FieldOrder(i int) IFieldOrderContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldOrderListContext differentiates from other interfaces.
	IsFieldOrderListContext()
}

type FieldOrderListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOrderListContext() *FieldOrderListContext {
	var p = new(FieldOrderListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrderList
	return p
}

func InitEmptyFieldOrderListContext(p *FieldOrderListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrderList
}

func (*FieldOrderListContext) IsFieldOrderListContext() {}

func NewFieldOrderListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOrderListContext {
	var p = new(FieldOrderListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldOrderList

	return p
}

func (s *FieldOrderListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOrderListContext) AllFieldOrder() []IFieldOrderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldOrderContext); ok {
			len++
		}
	}

	tst := make([]IFieldOrderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldOrderContext); ok {
			tst[i] = t.(IFieldOrderContext)
			i++
		}
	}

	return tst
}

func (s *FieldOrderListContext) FieldOrder(i int) IFieldOrderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrderContext)
}

func (s *FieldOrderListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldOrderListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldOrderListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOrderListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldOrderListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldOrderList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldOrderList() (localctx IFieldOrderListContext) {
	localctx = NewFieldOrderListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ApexParserRULE_fieldOrderList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1539)
		p.FieldOrder()
	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserCOMMA {
		{
			p.SetState(1540)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1541)
			p.FieldOrder()
		}

		p.SetState(1546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldOrderContext is an interface to support dynamic dispatch.
type IFieldOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	SoqlFunction() ISoqlFunctionContext

	// IsFieldOrderContext differentiates from other interfaces.
	IsFieldOrderContext()
}

type FieldOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOrderContext() *FieldOrderContext {
	var p = new(FieldOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrder
	return p
}

func InitEmptyFieldOrderContext(p *FieldOrderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrder
}

func (*FieldOrderContext) IsFieldOrderContext() {}

func NewFieldOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOrderContext {
	var p = new(FieldOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldOrder

	return p
}

func (s *FieldOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOrderContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldOrderContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ApexParserNULLS, 0)
}

func (s *FieldOrderContext) ASC() antlr.TerminalNode {
	return s.GetToken(ApexParserASC, 0)
}

func (s *FieldOrderContext) DESC() antlr.TerminalNode {
	return s.GetToken(ApexParserDESC, 0)
}

func (s *FieldOrderContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ApexParserFIRST, 0)
}

func (s *FieldOrderContext) LAST() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST, 0)
}

func (s *FieldOrderContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *FieldOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldOrderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldOrder(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldOrder() (localctx IFieldOrderContext) {
	localctx = NewFieldOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ApexParserRULE_fieldOrder)
	var _la int

	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1547)
			p.FieldName()
		}
		p.SetState(1549)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserASC || _la == ApexParserDESC {
			{
				p.SetState(1548)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserASC || _la == ApexParserDESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserNULLS {
			{
				p.SetState(1551)
				p.Match(ApexParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1552)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserFIRST || _la == ApexParserLAST) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1555)
			p.SoqlFunction()
		}
		p.SetState(1557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserASC || _la == ApexParserDESC {
			{
				p.SetState(1556)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserASC || _la == ApexParserDESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserNULLS {
			{
				p.SetState(1559)
				p.Match(ApexParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1560)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserFIRST || _la == ApexParserLAST) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	BoundExpression() IBoundExpressionContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ApexParserLIMIT, 0)
}

func (s *LimitClauseContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *LimitClauseContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ApexParserRULE_limitClause)
	p.SetState(1569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1565)
			p.Match(ApexParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1566)
			p.Match(ApexParserIntegerLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1567)
			p.Match(ApexParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1568)
			p.BoundExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOffsetClauseContext is an interface to support dynamic dispatch.
type IOffsetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OFFSET() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	BoundExpression() IBoundExpressionContext

	// IsOffsetClauseContext differentiates from other interfaces.
	IsOffsetClauseContext()
}

type OffsetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetClauseContext() *OffsetClauseContext {
	var p = new(OffsetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_offsetClause
	return p
}

func InitEmptyOffsetClauseContext(p *OffsetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_offsetClause
}

func (*OffsetClauseContext) IsOffsetClauseContext() {}

func NewOffsetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetClauseContext {
	var p = new(OffsetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_offsetClause

	return p
}

func (s *OffsetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OffsetClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ApexParserOFFSET, 0)
}

func (s *OffsetClauseContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *OffsetClauseContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *OffsetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OffsetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitOffsetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) OffsetClause() (localctx IOffsetClauseContext) {
	localctx = NewOffsetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, ApexParserRULE_offsetClause)
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1571)
			p.Match(ApexParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1572)
			p.Match(ApexParserIntegerLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1573)
			p.Match(ApexParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1574)
			p.BoundExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllRowsClauseContext is an interface to support dynamic dispatch.
type IAllRowsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsAllRowsClauseContext differentiates from other interfaces.
	IsAllRowsClauseContext()
}

type AllRowsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllRowsClauseContext() *AllRowsClauseContext {
	var p = new(AllRowsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_allRowsClause
	return p
}

func InitEmptyAllRowsClauseContext(p *AllRowsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_allRowsClause
}

func (*AllRowsClauseContext) IsAllRowsClauseContext() {}

func NewAllRowsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllRowsClauseContext {
	var p = new(AllRowsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_allRowsClause

	return p
}

func (s *AllRowsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AllRowsClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *AllRowsClauseContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ApexParserROWS, 0)
}

func (s *AllRowsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllRowsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllRowsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitAllRowsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) AllRowsClause() (localctx IAllRowsClauseContext) {
	localctx = NewAllRowsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, ApexParserRULE_allRowsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		p.Match(ApexParserALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1578)
		p.Match(ApexParserROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForClausesContext is an interface to support dynamic dispatch.
type IForClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFOR() []antlr.TerminalNode
	FOR(i int) antlr.TerminalNode
	AllVIEW() []antlr.TerminalNode
	VIEW(i int) antlr.TerminalNode
	AllUPDATE() []antlr.TerminalNode
	UPDATE(i int) antlr.TerminalNode
	AllREFERENCE() []antlr.TerminalNode
	REFERENCE(i int) antlr.TerminalNode

	// IsForClausesContext differentiates from other interfaces.
	IsForClausesContext()
}

type ForClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForClausesContext() *ForClausesContext {
	var p = new(ForClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forClauses
	return p
}

func InitEmptyForClausesContext(p *ForClausesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forClauses
}

func (*ForClausesContext) IsForClausesContext() {}

func NewForClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForClausesContext {
	var p = new(ForClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forClauses

	return p
}

func (s *ForClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *ForClausesContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(ApexParserFOR)
}

func (s *ForClausesContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserFOR, i)
}

func (s *ForClausesContext) AllVIEW() []antlr.TerminalNode {
	return s.GetTokens(ApexParserVIEW)
}

func (s *ForClausesContext) VIEW(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserVIEW, i)
}

func (s *ForClausesContext) AllUPDATE() []antlr.TerminalNode {
	return s.GetTokens(ApexParserUPDATE)
}

func (s *ForClausesContext) UPDATE(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, i)
}

func (s *ForClausesContext) AllREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(ApexParserREFERENCE)
}

func (s *ForClausesContext) REFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserREFERENCE, i)
}

func (s *ForClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitForClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) ForClauses() (localctx IForClausesContext) {
	localctx = NewForClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, ApexParserRULE_forClauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ApexParserFOR {
		{
			p.SetState(1580)
			p.Match(ApexParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1581)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-46)) & ^0x3f) == 0 && ((int64(1)<<(_la-46))&72075186223972353) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(1586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoundExpressionContext is an interface to support dynamic dispatch.
type IBoundExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsBoundExpressionContext differentiates from other interfaces.
	IsBoundExpressionContext()
}

type BoundExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoundExpressionContext() *BoundExpressionContext {
	var p = new(BoundExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_boundExpression
	return p
}

func InitEmptyBoundExpressionContext(p *BoundExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_boundExpression
}

func (*BoundExpressionContext) IsBoundExpressionContext() {}

func NewBoundExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoundExpressionContext {
	var p = new(BoundExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_boundExpression

	return p
}

func (s *BoundExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BoundExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}

func (s *BoundExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoundExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitBoundExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) BoundExpression() (localctx IBoundExpressionContext) {
	localctx = NewBoundExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, ApexParserRULE_boundExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1587)
		p.Match(ApexParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1588)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateFormulaContext is an interface to support dynamic dispatch.
type IDateFormulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YESTERDAY() antlr.TerminalNode
	TODAY() antlr.TerminalNode
	TOMORROW() antlr.TerminalNode
	LAST_WEEK() antlr.TerminalNode
	THIS_WEEK() antlr.TerminalNode
	NEXT_WEEK() antlr.TerminalNode
	LAST_MONTH() antlr.TerminalNode
	THIS_MONTH() antlr.TerminalNode
	NEXT_MONTH() antlr.TerminalNode
	LAST_90_DAYS() antlr.TerminalNode
	NEXT_90_DAYS() antlr.TerminalNode
	LAST_N_DAYS_N() antlr.TerminalNode
	COLON() antlr.TerminalNode
	SignedInteger() ISignedIntegerContext
	NEXT_N_DAYS_N() antlr.TerminalNode
	NEXT_N_WEEKS_N() antlr.TerminalNode
	LAST_N_WEEKS_N() antlr.TerminalNode
	NEXT_N_MONTHS_N() antlr.TerminalNode
	LAST_N_MONTHS_N() antlr.TerminalNode
	THIS_QUARTER() antlr.TerminalNode
	LAST_QUARTER() antlr.TerminalNode
	NEXT_QUARTER() antlr.TerminalNode
	NEXT_N_QUARTERS_N() antlr.TerminalNode
	LAST_N_QUARTERS_N() antlr.TerminalNode
	THIS_YEAR() antlr.TerminalNode
	LAST_YEAR() antlr.TerminalNode
	NEXT_YEAR() antlr.TerminalNode
	NEXT_N_YEARS_N() antlr.TerminalNode
	LAST_N_YEARS_N() antlr.TerminalNode
	THIS_FISCAL_QUARTER() antlr.TerminalNode
	LAST_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	THIS_FISCAL_YEAR() antlr.TerminalNode
	LAST_FISCAL_YEAR() antlr.TerminalNode
	NEXT_FISCAL_YEAR() antlr.TerminalNode
	NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode
	LAST_N_FISCAL_YEARS_N() antlr.TerminalNode

	// IsDateFormulaContext differentiates from other interfaces.
	IsDateFormulaContext()
}

type DateFormulaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateFormulaContext() *DateFormulaContext {
	var p = new(DateFormulaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFormula
	return p
}

func InitEmptyDateFormulaContext(p *DateFormulaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFormula
}

func (*DateFormulaContext) IsDateFormulaContext() {}

func NewDateFormulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateFormulaContext {
	var p = new(DateFormulaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dateFormula

	return p
}

func (s *DateFormulaContext) GetParser() antlr.Parser { return s.parser }

func (s *DateFormulaContext) YESTERDAY() antlr.TerminalNode {
	return s.GetToken(ApexParserYESTERDAY, 0)
}

func (s *DateFormulaContext) TODAY() antlr.TerminalNode {
	return s.GetToken(ApexParserTODAY, 0)
}

func (s *DateFormulaContext) TOMORROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTOMORROW, 0)
}

func (s *DateFormulaContext) LAST_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_WEEK, 0)
}

func (s *DateFormulaContext) THIS_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_WEEK, 0)
}

func (s *DateFormulaContext) NEXT_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_WEEK, 0)
}

func (s *DateFormulaContext) LAST_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_MONTH, 0)
}

func (s *DateFormulaContext) THIS_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_MONTH, 0)
}

func (s *DateFormulaContext) NEXT_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_MONTH, 0)
}

func (s *DateFormulaContext) LAST_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_90_DAYS, 0)
}

func (s *DateFormulaContext) NEXT_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_90_DAYS, 0)
}

func (s *DateFormulaContext) LAST_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_DAYS_N, 0)
}

func (s *DateFormulaContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}

func (s *DateFormulaContext) SignedInteger() ISignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedIntegerContext)
}

func (s *DateFormulaContext) NEXT_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_DAYS_N, 0)
}

func (s *DateFormulaContext) NEXT_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_WEEKS_N, 0)
}

func (s *DateFormulaContext) LAST_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_WEEKS_N, 0)
}

func (s *DateFormulaContext) NEXT_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_MONTHS_N, 0)
}

func (s *DateFormulaContext) LAST_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_MONTHS_N, 0)
}

func (s *DateFormulaContext) THIS_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_QUARTER, 0)
}

func (s *DateFormulaContext) LAST_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_QUARTERS_N, 0)
}

func (s *DateFormulaContext) LAST_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_QUARTERS_N, 0)
}

func (s *DateFormulaContext) THIS_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_YEAR, 0)
}

func (s *DateFormulaContext) LAST_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_YEARS_N, 0)
}

func (s *DateFormulaContext) LAST_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_YEARS_N, 0)
}

func (s *DateFormulaContext) THIS_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_QUARTER, 0)
}

func (s *DateFormulaContext) LAST_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_QUARTERS_N, 0)
}

func (s *DateFormulaContext) LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_QUARTERS_N, 0)
}

func (s *DateFormulaContext) THIS_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_YEAR, 0)
}

func (s *DateFormulaContext) LAST_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_YEARS_N, 0)
}

func (s *DateFormulaContext) LAST_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_YEARS_N, 0)
}

func (s *DateFormulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateFormulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateFormulaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitDateFormula(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) DateFormula() (localctx IDateFormulaContext) {
	localctx = NewDateFormulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, ApexParserRULE_dateFormula)
	p.SetState(1655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserYESTERDAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1590)
			p.Match(ApexParserYESTERDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserTODAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1591)
			p.Match(ApexParserTODAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserTOMORROW:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1592)
			p.Match(ApexParserTOMORROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_WEEK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1593)
			p.Match(ApexParserLAST_WEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserTHIS_WEEK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1594)
			p.Match(ApexParserTHIS_WEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_WEEK:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1595)
			p.Match(ApexParserNEXT_WEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_MONTH:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1596)
			p.Match(ApexParserLAST_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserTHIS_MONTH:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1597)
			p.Match(ApexParserTHIS_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_MONTH:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1598)
			p.Match(ApexParserNEXT_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_90_DAYS:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1599)
			p.Match(ApexParserLAST_90_DAYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_90_DAYS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1600)
			p.Match(ApexParserNEXT_90_DAYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_N_DAYS_N:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1601)
			p.Match(ApexParserLAST_N_DAYS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1602)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1603)
			p.SignedInteger()
		}

	case ApexParserNEXT_N_DAYS_N:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1604)
			p.Match(ApexParserNEXT_N_DAYS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1605)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1606)
			p.SignedInteger()
		}

	case ApexParserNEXT_N_WEEKS_N:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1607)
			p.Match(ApexParserNEXT_N_WEEKS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1608)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1609)
			p.SignedInteger()
		}

	case ApexParserLAST_N_WEEKS_N:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1610)
			p.Match(ApexParserLAST_N_WEEKS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1611)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1612)
			p.SignedInteger()
		}

	case ApexParserNEXT_N_MONTHS_N:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1613)
			p.Match(ApexParserNEXT_N_MONTHS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1614)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.SignedInteger()
		}

	case ApexParserLAST_N_MONTHS_N:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1616)
			p.Match(ApexParserLAST_N_MONTHS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1617)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1618)
			p.SignedInteger()
		}

	case ApexParserTHIS_QUARTER:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1619)
			p.Match(ApexParserTHIS_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_QUARTER:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1620)
			p.Match(ApexParserLAST_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_QUARTER:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1621)
			p.Match(ApexParserNEXT_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_N_QUARTERS_N:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1622)
			p.Match(ApexParserNEXT_N_QUARTERS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1623)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.SignedInteger()
		}

	case ApexParserLAST_N_QUARTERS_N:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1625)
			p.Match(ApexParserLAST_N_QUARTERS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1626)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1627)
			p.SignedInteger()
		}

	case ApexParserTHIS_YEAR:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1628)
			p.Match(ApexParserTHIS_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_YEAR:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1629)
			p.Match(ApexParserLAST_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_YEAR:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1630)
			p.Match(ApexParserNEXT_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_N_YEARS_N:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1631)
			p.Match(ApexParserNEXT_N_YEARS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1633)
			p.SignedInteger()
		}

	case ApexParserLAST_N_YEARS_N:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1634)
			p.Match(ApexParserLAST_N_YEARS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1636)
			p.SignedInteger()
		}

	case ApexParserTHIS_FISCAL_QUARTER:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1637)
			p.Match(ApexParserTHIS_FISCAL_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_FISCAL_QUARTER:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1638)
			p.Match(ApexParserLAST_FISCAL_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_FISCAL_QUARTER:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1639)
			p.Match(ApexParserNEXT_FISCAL_QUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_N_FISCAL_QUARTERS_N:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1640)
			p.Match(ApexParserNEXT_N_FISCAL_QUARTERS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1642)
			p.SignedInteger()
		}

	case ApexParserLAST_N_FISCAL_QUARTERS_N:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1643)
			p.Match(ApexParserLAST_N_FISCAL_QUARTERS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1644)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1645)
			p.SignedInteger()
		}

	case ApexParserTHIS_FISCAL_YEAR:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1646)
			p.Match(ApexParserTHIS_FISCAL_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLAST_FISCAL_YEAR:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1647)
			p.Match(ApexParserLAST_FISCAL_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_FISCAL_YEAR:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1648)
			p.Match(ApexParserNEXT_FISCAL_YEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserNEXT_N_FISCAL_YEARS_N:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1649)
			p.Match(ApexParserNEXT_N_FISCAL_YEARS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1651)
			p.SignedInteger()
		}

	case ApexParserLAST_N_FISCAL_YEARS_N:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1652)
			p.Match(ApexParserLAST_N_FISCAL_YEARS_N)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1653)
			p.Match(ApexParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1654)
			p.SignedInteger()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedIntegerContext is an interface to support dynamic dispatch.
type ISignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsSignedIntegerContext differentiates from other interfaces.
	IsSignedIntegerContext()
}

type SignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedIntegerContext() *SignedIntegerContext {
	var p = new(SignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedInteger
	return p
}

func InitEmptySignedIntegerContext(p *SignedIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedInteger
}

func (*SignedIntegerContext) IsSignedIntegerContext() {}

func NewSignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedIntegerContext {
	var p = new(SignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_signedInteger

	return p
}

func (s *SignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedIntegerContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *SignedIntegerContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *SignedIntegerContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *SignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSignedInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SignedInteger() (localctx ISignedIntegerContext) {
	localctx = NewSignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, ApexParserRULE_signedInteger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserADD || _la == ApexParserSUB {
		{
			p.SetState(1657)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ApexParserADD || _la == ApexParserSUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1660)
		p.Match(ApexParserIntegerLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoqlIdContext is an interface to support dynamic dispatch.
type ISoqlIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext

	// IsSoqlIdContext differentiates from other interfaces.
	IsSoqlIdContext()
}

type SoqlIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlIdContext() *SoqlIdContext {
	var p = new(SoqlIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlId
	return p
}

func InitEmptySoqlIdContext(p *SoqlIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlId
}

func (*SoqlIdContext) IsSoqlIdContext() {}

func NewSoqlIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlIdContext {
	var p = new(SoqlIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlId

	return p
}

func (s *SoqlIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlIdContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *SoqlIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoqlIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoqlId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoqlId() (localctx ISoqlIdContext) {
	localctx = NewSoqlIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, ApexParserRULE_soqlId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1662)
		p.Id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoslLiteralContext is an interface to support dynamic dispatch.
type ISoslLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FindLiteral() antlr.TerminalNode
	SoslClauses() ISoslClausesContext
	RBRACK() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	FIND() antlr.TerminalNode
	BoundExpression() IBoundExpressionContext

	// IsSoslLiteralContext differentiates from other interfaces.
	IsSoslLiteralContext()
}

type SoslLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslLiteralContext() *SoslLiteralContext {
	var p = new(SoslLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteral
	return p
}

func InitEmptySoslLiteralContext(p *SoslLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteral
}

func (*SoslLiteralContext) IsSoslLiteralContext() {}

func NewSoslLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslLiteralContext {
	var p = new(SoslLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslLiteral

	return p
}

func (s *SoslLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslLiteralContext) FindLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserFindLiteral, 0)
}

func (s *SoslLiteralContext) SoslClauses() ISoslClausesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslClausesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslClausesContext)
}

func (s *SoslLiteralContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *SoslLiteralContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *SoslLiteralContext) FIND() antlr.TerminalNode {
	return s.GetToken(ApexParserFIND, 0)
}

func (s *SoslLiteralContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *SoslLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoslLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoslLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoslLiteral() (localctx ISoslLiteralContext) {
	localctx = NewSoslLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, ApexParserRULE_soslLiteral)
	p.SetState(1674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserFindLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1664)
			p.Match(ApexParserFindLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1665)
			p.SoslClauses()
		}
		{
			p.SetState(1666)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ApexParserLBRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1668)
			p.Match(ApexParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1669)
			p.Match(ApexParserFIND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1670)
			p.BoundExpression()
		}
		{
			p.SetState(1671)
			p.SoslClauses()
		}
		{
			p.SetState(1672)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoslLiteralAltContext is an interface to support dynamic dispatch.
type ISoslLiteralAltContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FindLiteralAlt() antlr.TerminalNode
	SoslClauses() ISoslClausesContext
	RBRACK() antlr.TerminalNode

	// IsSoslLiteralAltContext differentiates from other interfaces.
	IsSoslLiteralAltContext()
}

type SoslLiteralAltContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslLiteralAltContext() *SoslLiteralAltContext {
	var p = new(SoslLiteralAltContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteralAlt
	return p
}

func InitEmptySoslLiteralAltContext(p *SoslLiteralAltContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteralAlt
}

func (*SoslLiteralAltContext) IsSoslLiteralAltContext() {}

func NewSoslLiteralAltContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslLiteralAltContext {
	var p = new(SoslLiteralAltContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslLiteralAlt

	return p
}

func (s *SoslLiteralAltContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslLiteralAltContext) FindLiteralAlt() antlr.TerminalNode {
	return s.GetToken(ApexParserFindLiteralAlt, 0)
}

func (s *SoslLiteralAltContext) SoslClauses() ISoslClausesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslClausesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslClausesContext)
}

func (s *SoslLiteralAltContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *SoslLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslLiteralAltContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoslLiteralAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoslLiteralAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoslLiteralAlt() (localctx ISoslLiteralAltContext) {
	localctx = NewSoslLiteralAltContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, ApexParserRULE_soslLiteralAlt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1676)
		p.Match(ApexParserFindLiteralAlt)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1677)
		p.SoslClauses()
	}
	{
		p.SetState(1678)
		p.Match(ApexParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoslClausesContext is an interface to support dynamic dispatch.
type ISoslClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	SearchGroup() ISearchGroupContext
	RETURNING() antlr.TerminalNode
	FieldSpecList() IFieldSpecListContext
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	DIVISION() antlr.TerminalNode
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	FilteringExpression() IFilteringExpressionContext
	SNIPPET() antlr.TerminalNode
	AllNETWORK() []antlr.TerminalNode
	NETWORK(i int) antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	NetworkList() INetworkListContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	PRICEBOOKID() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	LimitClause() ILimitClauseContext
	UPDATE() antlr.TerminalNode
	UpdateList() IUpdateListContext
	TARGET_LENGTH() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode

	// IsSoslClausesContext differentiates from other interfaces.
	IsSoslClausesContext()
}

type SoslClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslClausesContext() *SoslClausesContext {
	var p = new(SoslClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslClauses
	return p
}

func InitEmptySoslClausesContext(p *SoslClausesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslClauses
}

func (*SoslClausesContext) IsSoslClausesContext() {}

func NewSoslClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslClausesContext {
	var p = new(SoslClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslClauses

	return p
}

func (s *SoslClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslClausesContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(ApexParserIN)
}

func (s *SoslClausesContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserIN, i)
}

func (s *SoslClausesContext) SearchGroup() ISearchGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchGroupContext)
}

func (s *SoslClausesContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURNING, 0)
}

func (s *SoslClausesContext) FieldSpecList() IFieldSpecListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldSpecListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldSpecListContext)
}

func (s *SoslClausesContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(ApexParserWITH)
}

func (s *SoslClausesContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, i)
}

func (s *SoslClausesContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(ApexParserDIVISION, 0)
}

func (s *SoslClausesContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(ApexParserASSIGN)
}

func (s *SoslClausesContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, i)
}

func (s *SoslClausesContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(ApexParserStringLiteral)
}

func (s *SoslClausesContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, i)
}

func (s *SoslClausesContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *SoslClausesContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *SoslClausesContext) FilteringExpression() IFilteringExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilteringExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilteringExpressionContext)
}

func (s *SoslClausesContext) SNIPPET() antlr.TerminalNode {
	return s.GetToken(ApexParserSNIPPET, 0)
}

func (s *SoslClausesContext) AllNETWORK() []antlr.TerminalNode {
	return s.GetTokens(ApexParserNETWORK)
}

func (s *SoslClausesContext) NETWORK(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserNETWORK, i)
}

func (s *SoslClausesContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ApexParserLPAREN)
}

func (s *SoslClausesContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, i)
}

func (s *SoslClausesContext) NetworkList() INetworkListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INetworkListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INetworkListContext)
}

func (s *SoslClausesContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ApexParserRPAREN)
}

func (s *SoslClausesContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, i)
}

func (s *SoslClausesContext) PRICEBOOKID() antlr.TerminalNode {
	return s.GetToken(ApexParserPRICEBOOKID, 0)
}

func (s *SoslClausesContext) METADATA() antlr.TerminalNode {
	return s.GetToken(ApexParserMETADATA, 0)
}

func (s *SoslClausesContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SoslClausesContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *SoslClausesContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *SoslClausesContext) TARGET_LENGTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTARGET_LENGTH, 0)
}

func (s *SoslClausesContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *SoslClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoslClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoslClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoslClauses() (localctx ISoslClausesContext) {
	localctx = NewSoslClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, ApexParserRULE_soslClauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserIN {
		{
			p.SetState(1680)
			p.Match(ApexParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1681)
			p.SearchGroup()
		}

	}
	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserRETURNING {
		{
			p.SetState(1684)
			p.Match(ApexParserRETURNING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1685)
			p.FieldSpecList()
		}

	}
	p.SetState(1692)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1688)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1689)
			p.Match(ApexParserDIVISION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1690)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1694)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Match(ApexParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1696)
			p.Match(ApexParserCATEGORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1697)
			p.FilteringExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1709)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1700)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1701)
			p.Match(ApexParserSNIPPET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserLPAREN {
			{
				p.SetState(1702)
				p.Match(ApexParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1703)
				p.Match(ApexParserTARGET_LENGTH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1704)
				p.Match(ApexParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1705)
				p.Match(ApexParserIntegerLiteral)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1706)
				p.Match(ApexParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1718)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1711)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1712)
			p.Match(ApexParserNETWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1713)
			p.Match(ApexParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1714)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1715)
			p.NetworkList()
		}
		{
			p.SetState(1716)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1724)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1720)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1721)
			p.Match(ApexParserNETWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1722)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1723)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1726)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1727)
			p.Match(ApexParserPRICEBOOKID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1728)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1729)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserWITH {
		{
			p.SetState(1732)
			p.Match(ApexParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Match(ApexParserMETADATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1734)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1735)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserLIMIT {
		{
			p.SetState(1738)
			p.LimitClause()
		}

	}
	p.SetState(1743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserUPDATE {
		{
			p.SetState(1741)
			p.Match(ApexParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1742)
			p.UpdateList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchGroupContext is an interface to support dynamic dispatch.
type ISearchGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIELDS() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EMAIL() antlr.TerminalNode
	NAME() antlr.TerminalNode
	PHONE() antlr.TerminalNode
	SIDEBAR() antlr.TerminalNode

	// IsSearchGroupContext differentiates from other interfaces.
	IsSearchGroupContext()
}

type SearchGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchGroupContext() *SearchGroupContext {
	var p = new(SearchGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_searchGroup
	return p
}

func InitEmptySearchGroupContext(p *SearchGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_searchGroup
}

func (*SearchGroupContext) IsSearchGroupContext() {}

func NewSearchGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchGroupContext {
	var p = new(SearchGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_searchGroup

	return p
}

func (s *SearchGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchGroupContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *SearchGroupContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *SearchGroupContext) EMAIL() antlr.TerminalNode {
	return s.GetToken(ApexParserEMAIL, 0)
}

func (s *SearchGroupContext) NAME() antlr.TerminalNode {
	return s.GetToken(ApexParserNAME, 0)
}

func (s *SearchGroupContext) PHONE() antlr.TerminalNode {
	return s.GetToken(ApexParserPHONE, 0)
}

func (s *SearchGroupContext) SIDEBAR() antlr.TerminalNode {
	return s.GetToken(ApexParserSIDEBAR, 0)
}

func (s *SearchGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSearchGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SearchGroup() (localctx ISearchGroupContext) {
	localctx = NewSearchGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, ApexParserRULE_searchGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1745)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserALL || ((int64((_la-164)) & ^0x3f) == 0 && ((int64(1)<<(_la-164))&15) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1746)
		p.Match(ApexParserFIELDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldSpecListContext is an interface to support dynamic dispatch.
type IFieldSpecListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldSpec() IFieldSpecContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllFieldSpecList() []IFieldSpecListContext
	FieldSpecList(i int) IFieldSpecListContext

	// IsFieldSpecListContext differentiates from other interfaces.
	IsFieldSpecListContext()
}

type FieldSpecListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldSpecListContext() *FieldSpecListContext {
	var p = new(FieldSpecListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpecList
	return p
}

func InitEmptyFieldSpecListContext(p *FieldSpecListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpecList
}

func (*FieldSpecListContext) IsFieldSpecListContext() {}

func NewFieldSpecListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldSpecListContext {
	var p = new(FieldSpecListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldSpecList

	return p
}

func (s *FieldSpecListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldSpecListContext) FieldSpec() IFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldSpecContext)
}

func (s *FieldSpecListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldSpecListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldSpecListContext) AllFieldSpecList() []IFieldSpecListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldSpecListContext); ok {
			len++
		}
	}

	tst := make([]IFieldSpecListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldSpecListContext); ok {
			tst[i] = t.(IFieldSpecListContext)
			i++
		}
	}

	return tst
}

func (s *FieldSpecListContext) FieldSpecList(i int) IFieldSpecListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldSpecListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldSpecListContext)
}

func (s *FieldSpecListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldSpecListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldSpecListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldSpecList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldSpecList() (localctx IFieldSpecListContext) {
	localctx = NewFieldSpecListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, ApexParserRULE_fieldSpecList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1748)
		p.FieldSpec()
	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1749)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1750)
				p.FieldSpecList()
			}

		}
		p.SetState(1755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldSpecContext is an interface to support dynamic dispatch.
type IFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSoslId() []ISoslIdContext
	SoslId(i int) ISoslIdContext
	LPAREN() antlr.TerminalNode
	FieldList() IFieldListContext
	RPAREN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext
	USING() antlr.TerminalNode
	LISTVIEW() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldOrderList() IFieldOrderListContext
	LimitClause() ILimitClauseContext
	OffsetClause() IOffsetClauseContext

	// IsFieldSpecContext differentiates from other interfaces.
	IsFieldSpecContext()
}

type FieldSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldSpecContext() *FieldSpecContext {
	var p = new(FieldSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpec
	return p
}

func InitEmptyFieldSpecContext(p *FieldSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpec
}

func (*FieldSpecContext) IsFieldSpecContext() {}

func NewFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldSpecContext {
	var p = new(FieldSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldSpec

	return p
}

func (s *FieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldSpecContext) AllSoslId() []ISoslIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoslIdContext); ok {
			len++
		}
	}

	tst := make([]ISoslIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoslIdContext); ok {
			tst[i] = t.(ISoslIdContext)
			i++
		}
	}

	return tst
}

func (s *FieldSpecContext) SoslId(i int) ISoslIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslIdContext)
}

func (s *FieldSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *FieldSpecContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *FieldSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *FieldSpecContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *FieldSpecContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *FieldSpecContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *FieldSpecContext) LISTVIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserLISTVIEW, 0)
}

func (s *FieldSpecContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *FieldSpecContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *FieldSpecContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *FieldSpecContext) FieldOrderList() IFieldOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrderListContext)
}

func (s *FieldSpecContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *FieldSpecContext) OffsetClause() IOffsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetClauseContext)
}

func (s *FieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldSpec() (localctx IFieldSpecContext) {
	localctx = NewFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, ApexParserRULE_fieldSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1756)
		p.SoslId()
	}
	p.SetState(1782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserLPAREN {
		{
			p.SetState(1757)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1758)
			p.FieldList()
		}
		p.SetState(1761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserWHERE {
			{
				p.SetState(1759)
				p.Match(ApexParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1760)
				p.LogicalExpression()
			}

		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserUSING {
			{
				p.SetState(1763)
				p.Match(ApexParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1764)
				p.Match(ApexParserLISTVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1765)
				p.Match(ApexParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1766)
				p.SoslId()
			}

		}
		p.SetState(1772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserORDER {
			{
				p.SetState(1769)
				p.Match(ApexParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1770)
				p.Match(ApexParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1771)
				p.FieldOrderList()
			}

		}
		p.SetState(1775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserLIMIT {
			{
				p.SetState(1774)
				p.LimitClause()
			}

		}
		p.SetState(1778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ApexParserOFFSET {
			{
				p.SetState(1777)
				p.OffsetClause()
			}

		}
		{
			p.SetState(1780)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SoslId() ISoslIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllFieldList() []IFieldListContext
	FieldList(i int) IFieldListContext

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) SoslId() ISoslIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslIdContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldListContext) AllFieldList() []IFieldListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldListContext); ok {
			len++
		}
	}

	tst := make([]IFieldListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldListContext); ok {
			tst[i] = t.(IFieldListContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldList(i int) IFieldListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, ApexParserRULE_fieldList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1784)
		p.SoslId()
	}
	p.SetState(1789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1785)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1786)
				p.FieldList()
			}

		}
		p.SetState(1791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateListContext is an interface to support dynamic dispatch.
type IUpdateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UpdateType() IUpdateTypeContext
	COMMA() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsUpdateListContext differentiates from other interfaces.
	IsUpdateListContext()
}

type UpdateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateListContext() *UpdateListContext {
	var p = new(UpdateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateList
	return p
}

func InitEmptyUpdateListContext(p *UpdateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateList
}

func (*UpdateListContext) IsUpdateListContext() {}

func NewUpdateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateListContext {
	var p = new(UpdateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_updateList

	return p
}

func (s *UpdateListContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateListContext) UpdateType() IUpdateTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateTypeContext)
}

func (s *UpdateListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, 0)
}

func (s *UpdateListContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *UpdateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitUpdateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) UpdateList() (localctx IUpdateListContext) {
	localctx = NewUpdateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, ApexParserRULE_updateList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1792)
		p.UpdateType()
	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserCOMMA {
		{
			p.SetState(1793)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1794)
			p.UpdateList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateTypeContext is an interface to support dynamic dispatch.
type IUpdateTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRACKING() antlr.TerminalNode
	VIEWSTAT() antlr.TerminalNode

	// IsUpdateTypeContext differentiates from other interfaces.
	IsUpdateTypeContext()
}

type UpdateTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateTypeContext() *UpdateTypeContext {
	var p = new(UpdateTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateType
	return p
}

func InitEmptyUpdateTypeContext(p *UpdateTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateType
}

func (*UpdateTypeContext) IsUpdateTypeContext() {}

func NewUpdateTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateTypeContext {
	var p = new(UpdateTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_updateType

	return p
}

func (s *UpdateTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateTypeContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(ApexParserTRACKING, 0)
}

func (s *UpdateTypeContext) VIEWSTAT() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEWSTAT, 0)
}

func (s *UpdateTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitUpdateType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) UpdateType() (localctx IUpdateTypeContext) {
	localctx = NewUpdateTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, ApexParserRULE_updateType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1797)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserTRACKING || _la == ApexParserVIEWSTAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INetworkListContext is an interface to support dynamic dispatch.
type INetworkListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	NetworkList() INetworkListContext

	// IsNetworkListContext differentiates from other interfaces.
	IsNetworkListContext()
}

type NetworkListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNetworkListContext() *NetworkListContext {
	var p = new(NetworkListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_networkList
	return p
}

func InitEmptyNetworkListContext(p *NetworkListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_networkList
}

func (*NetworkListContext) IsNetworkListContext() {}

func NewNetworkListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NetworkListContext {
	var p = new(NetworkListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_networkList

	return p
}

func (s *NetworkListContext) GetParser() antlr.Parser { return s.parser }

func (s *NetworkListContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *NetworkListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, 0)
}

func (s *NetworkListContext) NetworkList() INetworkListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INetworkListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INetworkListContext)
}

func (s *NetworkListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NetworkListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NetworkListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitNetworkList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) NetworkList() (localctx INetworkListContext) {
	localctx = NewNetworkListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, ApexParserRULE_networkList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1799)
		p.Match(ApexParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ApexParserCOMMA {
		{
			p.SetState(1800)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1801)
			p.NetworkList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISoslIdContext is an interface to support dynamic dispatch.
type ISoslIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllSoslId() []ISoslIdContext
	SoslId(i int) ISoslIdContext

	// IsSoslIdContext differentiates from other interfaces.
	IsSoslIdContext()
}

type SoslIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslIdContext() *SoslIdContext {
	var p = new(SoslIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslId
	return p
}

func InitEmptySoslIdContext(p *SoslIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslId
}

func (*SoslIdContext) IsSoslIdContext() {}

func NewSoslIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslIdContext {
	var p = new(SoslIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslId

	return p
}

func (s *SoslIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslIdContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *SoslIdContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *SoslIdContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *SoslIdContext) AllSoslId() []ISoslIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoslIdContext); ok {
			len++
		}
	}

	tst := make([]ISoslIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoslIdContext); ok {
			tst[i] = t.(ISoslIdContext)
			i++
		}
	}

	return tst
}

func (s *SoslIdContext) SoslId(i int) ISoslIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslIdContext)
}

func (s *SoslIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoslIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitSoslId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) SoslId() (localctx ISoslIdContext) {
	localctx = NewSoslIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, ApexParserRULE_soslId)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1804)
		p.Id()
	}
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1805)
				p.Match(ApexParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1806)
				p.SoslId()
			}

		}
		p.SetState(1811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdContext is an interface to support dynamic dispatch.
type IIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	GET() antlr.TerminalNode
	INHERITED() antlr.TerminalNode
	INSTANCEOF() antlr.TerminalNode
	SET() antlr.TerminalNode
	SHARING() antlr.TerminalNode
	SWITCH() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	IntegralCurrencyLiteral() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AS() antlr.TerminalNode
	USING() antlr.TerminalNode
	SCOPE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	SOQLAND() antlr.TerminalNode
	SOQLOR() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	COUNT_DISTINCT() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MAX() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TYPEOF() antlr.TerminalNode
	END() antlr.TerminalNode
	THEN() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCLUDES() antlr.TerminalNode
	EXCLUDES() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	TOLABEL() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	AT() antlr.TerminalNode
	ABOVE() antlr.TerminalNode
	BELOW() antlr.TerminalNode
	ABOVE_OR_BELOW() antlr.TerminalNode
	SECURITY_ENFORCED() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRACKING() antlr.TerminalNode
	VIEWSTAT() antlr.TerminalNode
	STANDARD() antlr.TerminalNode
	CUSTOM() antlr.TerminalNode
	CALENDAR_MONTH() antlr.TerminalNode
	CALENDAR_QUARTER() antlr.TerminalNode
	CALENDAR_YEAR() antlr.TerminalNode
	DAY_IN_MONTH() antlr.TerminalNode
	DAY_IN_WEEK() antlr.TerminalNode
	DAY_IN_YEAR() antlr.TerminalNode
	DAY_ONLY() antlr.TerminalNode
	FISCAL_MONTH() antlr.TerminalNode
	FISCAL_QUARTER() antlr.TerminalNode
	FISCAL_YEAR() antlr.TerminalNode
	HOUR_IN_DAY() antlr.TerminalNode
	WEEK_IN_MONTH() antlr.TerminalNode
	WEEK_IN_YEAR() antlr.TerminalNode
	CONVERT_TIMEZONE() antlr.TerminalNode
	YESTERDAY() antlr.TerminalNode
	TODAY() antlr.TerminalNode
	TOMORROW() antlr.TerminalNode
	LAST_WEEK() antlr.TerminalNode
	THIS_WEEK() antlr.TerminalNode
	NEXT_WEEK() antlr.TerminalNode
	LAST_MONTH() antlr.TerminalNode
	THIS_MONTH() antlr.TerminalNode
	NEXT_MONTH() antlr.TerminalNode
	LAST_90_DAYS() antlr.TerminalNode
	NEXT_90_DAYS() antlr.TerminalNode
	LAST_N_DAYS_N() antlr.TerminalNode
	NEXT_N_DAYS_N() antlr.TerminalNode
	NEXT_N_WEEKS_N() antlr.TerminalNode
	LAST_N_WEEKS_N() antlr.TerminalNode
	NEXT_N_MONTHS_N() antlr.TerminalNode
	LAST_N_MONTHS_N() antlr.TerminalNode
	THIS_QUARTER() antlr.TerminalNode
	LAST_QUARTER() antlr.TerminalNode
	NEXT_QUARTER() antlr.TerminalNode
	NEXT_N_QUARTERS_N() antlr.TerminalNode
	LAST_N_QUARTERS_N() antlr.TerminalNode
	THIS_YEAR() antlr.TerminalNode
	LAST_YEAR() antlr.TerminalNode
	NEXT_YEAR() antlr.TerminalNode
	NEXT_N_YEARS_N() antlr.TerminalNode
	LAST_N_YEARS_N() antlr.TerminalNode
	THIS_FISCAL_QUARTER() antlr.TerminalNode
	LAST_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	THIS_FISCAL_YEAR() antlr.TerminalNode
	LAST_FISCAL_YEAR() antlr.TerminalNode
	NEXT_FISCAL_YEAR() antlr.TerminalNode
	NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode
	LAST_N_FISCAL_YEARS_N() antlr.TerminalNode
	FIND() antlr.TerminalNode
	EMAIL() antlr.TerminalNode
	NAME() antlr.TerminalNode
	PHONE() antlr.TerminalNode
	SIDEBAR() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	PRICEBOOKID() antlr.TerminalNode
	NETWORK() antlr.TerminalNode
	SNIPPET() antlr.TerminalNode
	TARGET_LENGTH() antlr.TerminalNode
	DIVISION() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	LISTVIEW() antlr.TerminalNode

	// IsIdContext differentiates from other interfaces.
	IsIdContext()
}

type IdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdContext() *IdContext {
	var p = new(IdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_id
	return p
}

func InitEmptyIdContext(p *IdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_id
}

func (*IdContext) IsIdContext() {}

func NewIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdContext {
	var p = new(IdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_id

	return p
}

func (s *IdContext) GetParser() antlr.Parser { return s.parser }

func (s *IdContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ApexParserIdentifier, 0)
}

func (s *IdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ApexParserAFTER, 0)
}

func (s *IdContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(ApexParserBEFORE, 0)
}

func (s *IdContext) GET() antlr.TerminalNode {
	return s.GetToken(ApexParserGET, 0)
}

func (s *IdContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(ApexParserINHERITED, 0)
}

func (s *IdContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserINSTANCEOF, 0)
}

func (s *IdContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *IdContext) SHARING() antlr.TerminalNode {
	return s.GetToken(ApexParserSHARING, 0)
}

func (s *IdContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ApexParserSWITCH, 0)
}

func (s *IdContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(ApexParserTRANSIENT, 0)
}

func (s *IdContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIGGER, 0)
}

func (s *IdContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *IdContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *IdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(ApexParserWITHOUT, 0)
}

func (s *IdContext) IntegralCurrencyLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegralCurrencyLiteral, 0)
}

func (s *IdContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *IdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT, 0)
}

func (s *IdContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *IdContext) AS() antlr.TerminalNode {
	return s.GetToken(ApexParserAS, 0)
}

func (s *IdContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *IdContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(ApexParserSCOPE, 0)
}

func (s *IdContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *IdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *IdContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *IdContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ApexParserLIMIT, 0)
}

func (s *IdContext) SOQLAND() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLAND, 0)
}

func (s *IdContext) SOQLOR() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLOR, 0)
}

func (s *IdContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *IdContext) AVG() antlr.TerminalNode {
	return s.GetToken(ApexParserAVG, 0)
}

func (s *IdContext) COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT_DISTINCT, 0)
}

func (s *IdContext) MIN() antlr.TerminalNode {
	return s.GetToken(ApexParserMIN, 0)
}

func (s *IdContext) MAX() antlr.TerminalNode {
	return s.GetToken(ApexParserMAX, 0)
}

func (s *IdContext) SUM() antlr.TerminalNode {
	return s.GetToken(ApexParserSUM, 0)
}

func (s *IdContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserTYPEOF, 0)
}

func (s *IdContext) END() antlr.TerminalNode {
	return s.GetToken(ApexParserEND, 0)
}

func (s *IdContext) THEN() antlr.TerminalNode {
	return s.GetToken(ApexParserTHEN, 0)
}

func (s *IdContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ApexParserLIKE, 0)
}

func (s *IdContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *IdContext) INCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserINCLUDES, 0)
}

func (s *IdContext) EXCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserEXCLUDES, 0)
}

func (s *IdContext) ASC() antlr.TerminalNode {
	return s.GetToken(ApexParserASC, 0)
}

func (s *IdContext) DESC() antlr.TerminalNode {
	return s.GetToken(ApexParserDESC, 0)
}

func (s *IdContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ApexParserNULLS, 0)
}

func (s *IdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ApexParserFIRST, 0)
}

func (s *IdContext) LAST() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST, 0)
}

func (s *IdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUP, 0)
}

func (s *IdContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *IdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ApexParserROWS, 0)
}

func (s *IdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEW, 0)
}

func (s *IdContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ApexParserHAVING, 0)
}

func (s *IdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ApexParserROLLUP, 0)
}

func (s *IdContext) TOLABEL() antlr.TerminalNode {
	return s.GetToken(ApexParserTOLABEL, 0)
}

func (s *IdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ApexParserOFFSET, 0)
}

func (s *IdContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *IdContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *IdContext) AT() antlr.TerminalNode {
	return s.GetToken(ApexParserAT, 0)
}

func (s *IdContext) ABOVE() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE, 0)
}

func (s *IdContext) BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserBELOW, 0)
}

func (s *IdContext) ABOVE_OR_BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE_OR_BELOW, 0)
}

func (s *IdContext) SECURITY_ENFORCED() antlr.TerminalNode {
	return s.GetToken(ApexParserSECURITY_ENFORCED, 0)
}

func (s *IdContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(ApexParserREFERENCE, 0)
}

func (s *IdContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ApexParserCUBE, 0)
}

func (s *IdContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ApexParserFORMAT, 0)
}

func (s *IdContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(ApexParserTRACKING, 0)
}

func (s *IdContext) VIEWSTAT() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEWSTAT, 0)
}

func (s *IdContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(ApexParserSTANDARD, 0)
}

func (s *IdContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(ApexParserCUSTOM, 0)
}

func (s *IdContext) CALENDAR_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_MONTH, 0)
}

func (s *IdContext) CALENDAR_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_QUARTER, 0)
}

func (s *IdContext) CALENDAR_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_YEAR, 0)
}

func (s *IdContext) DAY_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_MONTH, 0)
}

func (s *IdContext) DAY_IN_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_WEEK, 0)
}

func (s *IdContext) DAY_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_YEAR, 0)
}

func (s *IdContext) DAY_ONLY() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_ONLY, 0)
}

func (s *IdContext) FISCAL_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_MONTH, 0)
}

func (s *IdContext) FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_QUARTER, 0)
}

func (s *IdContext) FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_YEAR, 0)
}

func (s *IdContext) HOUR_IN_DAY() antlr.TerminalNode {
	return s.GetToken(ApexParserHOUR_IN_DAY, 0)
}

func (s *IdContext) WEEK_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_MONTH, 0)
}

func (s *IdContext) WEEK_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_YEAR, 0)
}

func (s *IdContext) CONVERT_TIMEZONE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_TIMEZONE, 0)
}

func (s *IdContext) YESTERDAY() antlr.TerminalNode {
	return s.GetToken(ApexParserYESTERDAY, 0)
}

func (s *IdContext) TODAY() antlr.TerminalNode {
	return s.GetToken(ApexParserTODAY, 0)
}

func (s *IdContext) TOMORROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTOMORROW, 0)
}

func (s *IdContext) LAST_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_WEEK, 0)
}

func (s *IdContext) THIS_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_WEEK, 0)
}

func (s *IdContext) NEXT_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_WEEK, 0)
}

func (s *IdContext) LAST_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_MONTH, 0)
}

func (s *IdContext) THIS_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_MONTH, 0)
}

func (s *IdContext) NEXT_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_MONTH, 0)
}

func (s *IdContext) LAST_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_90_DAYS, 0)
}

func (s *IdContext) NEXT_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_90_DAYS, 0)
}

func (s *IdContext) LAST_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_DAYS_N, 0)
}

func (s *IdContext) NEXT_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_DAYS_N, 0)
}

func (s *IdContext) NEXT_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_WEEKS_N, 0)
}

func (s *IdContext) LAST_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_WEEKS_N, 0)
}

func (s *IdContext) NEXT_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_MONTHS_N, 0)
}

func (s *IdContext) LAST_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_MONTHS_N, 0)
}

func (s *IdContext) THIS_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_QUARTER, 0)
}

func (s *IdContext) LAST_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_QUARTER, 0)
}

func (s *IdContext) NEXT_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_QUARTER, 0)
}

func (s *IdContext) NEXT_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_QUARTERS_N, 0)
}

func (s *IdContext) LAST_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_QUARTERS_N, 0)
}

func (s *IdContext) THIS_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_YEAR, 0)
}

func (s *IdContext) LAST_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_YEAR, 0)
}

func (s *IdContext) NEXT_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_YEAR, 0)
}

func (s *IdContext) NEXT_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_YEARS_N, 0)
}

func (s *IdContext) LAST_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_YEARS_N, 0)
}

func (s *IdContext) THIS_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_QUARTER, 0)
}

func (s *IdContext) LAST_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_QUARTER, 0)
}

func (s *IdContext) NEXT_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_QUARTER, 0)
}

func (s *IdContext) NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_QUARTERS_N, 0)
}

func (s *IdContext) LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_QUARTERS_N, 0)
}

func (s *IdContext) THIS_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_YEAR, 0)
}

func (s *IdContext) LAST_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_YEAR, 0)
}

func (s *IdContext) NEXT_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_YEAR, 0)
}

func (s *IdContext) NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_YEARS_N, 0)
}

func (s *IdContext) LAST_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_YEARS_N, 0)
}

func (s *IdContext) FIND() antlr.TerminalNode {
	return s.GetToken(ApexParserFIND, 0)
}

func (s *IdContext) EMAIL() antlr.TerminalNode {
	return s.GetToken(ApexParserEMAIL, 0)
}

func (s *IdContext) NAME() antlr.TerminalNode {
	return s.GetToken(ApexParserNAME, 0)
}

func (s *IdContext) PHONE() antlr.TerminalNode {
	return s.GetToken(ApexParserPHONE, 0)
}

func (s *IdContext) SIDEBAR() antlr.TerminalNode {
	return s.GetToken(ApexParserSIDEBAR, 0)
}

func (s *IdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *IdContext) METADATA() antlr.TerminalNode {
	return s.GetToken(ApexParserMETADATA, 0)
}

func (s *IdContext) PRICEBOOKID() antlr.TerminalNode {
	return s.GetToken(ApexParserPRICEBOOKID, 0)
}

func (s *IdContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(ApexParserNETWORK, 0)
}

func (s *IdContext) SNIPPET() antlr.TerminalNode {
	return s.GetToken(ApexParserSNIPPET, 0)
}

func (s *IdContext) TARGET_LENGTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTARGET_LENGTH, 0)
}

func (s *IdContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(ApexParserDIVISION, 0)
}

func (s *IdContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURNING, 0)
}

func (s *IdContext) LISTVIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserLISTVIEW, 0)
}

func (s *IdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) Id() (localctx IIdContext) {
	localctx = NewIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, ApexParserRULE_id)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1812)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-114828269935591412) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562937068519423) != 0) || _la == ApexParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyIdContext is an interface to support dynamic dispatch.
type IAnyIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	CATCH() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DO() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	FINALLY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	GET() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	INHERITED() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INSTANCEOF() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	NEW() antlr.TerminalNode
	NULL() antlr.TerminalNode
	ON() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	SET() antlr.TerminalNode
	SHARING() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	SWITCH() antlr.TerminalNode
	TESTMETHOD() antlr.TerminalNode
	THIS() antlr.TerminalNode
	THROW() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	TRY() antlr.TerminalNode
	UNDELETE() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WEBSERVICE() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	IntegralCurrencyLiteral() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AS() antlr.TerminalNode
	USING() antlr.TerminalNode
	SCOPE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	SOQLAND() antlr.TerminalNode
	SOQLOR() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	COUNT_DISTINCT() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MAX() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TYPEOF() antlr.TerminalNode
	END() antlr.TerminalNode
	THEN() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCLUDES() antlr.TerminalNode
	EXCLUDES() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	TOLABEL() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	AT() antlr.TerminalNode
	ABOVE() antlr.TerminalNode
	BELOW() antlr.TerminalNode
	ABOVE_OR_BELOW() antlr.TerminalNode
	SECURITY_ENFORCED() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRACKING() antlr.TerminalNode
	VIEWSTAT() antlr.TerminalNode
	STANDARD() antlr.TerminalNode
	CUSTOM() antlr.TerminalNode
	CALENDAR_MONTH() antlr.TerminalNode
	CALENDAR_QUARTER() antlr.TerminalNode
	CALENDAR_YEAR() antlr.TerminalNode
	DAY_IN_MONTH() antlr.TerminalNode
	DAY_IN_WEEK() antlr.TerminalNode
	DAY_IN_YEAR() antlr.TerminalNode
	DAY_ONLY() antlr.TerminalNode
	FISCAL_MONTH() antlr.TerminalNode
	FISCAL_QUARTER() antlr.TerminalNode
	FISCAL_YEAR() antlr.TerminalNode
	HOUR_IN_DAY() antlr.TerminalNode
	WEEK_IN_MONTH() antlr.TerminalNode
	WEEK_IN_YEAR() antlr.TerminalNode
	CONVERT_TIMEZONE() antlr.TerminalNode
	YESTERDAY() antlr.TerminalNode
	TODAY() antlr.TerminalNode
	TOMORROW() antlr.TerminalNode
	LAST_WEEK() antlr.TerminalNode
	THIS_WEEK() antlr.TerminalNode
	NEXT_WEEK() antlr.TerminalNode
	LAST_MONTH() antlr.TerminalNode
	THIS_MONTH() antlr.TerminalNode
	NEXT_MONTH() antlr.TerminalNode
	LAST_90_DAYS() antlr.TerminalNode
	NEXT_90_DAYS() antlr.TerminalNode
	LAST_N_DAYS_N() antlr.TerminalNode
	NEXT_N_DAYS_N() antlr.TerminalNode
	NEXT_N_WEEKS_N() antlr.TerminalNode
	LAST_N_WEEKS_N() antlr.TerminalNode
	NEXT_N_MONTHS_N() antlr.TerminalNode
	LAST_N_MONTHS_N() antlr.TerminalNode
	THIS_QUARTER() antlr.TerminalNode
	LAST_QUARTER() antlr.TerminalNode
	NEXT_QUARTER() antlr.TerminalNode
	NEXT_N_QUARTERS_N() antlr.TerminalNode
	LAST_N_QUARTERS_N() antlr.TerminalNode
	THIS_YEAR() antlr.TerminalNode
	LAST_YEAR() antlr.TerminalNode
	NEXT_YEAR() antlr.TerminalNode
	NEXT_N_YEARS_N() antlr.TerminalNode
	LAST_N_YEARS_N() antlr.TerminalNode
	THIS_FISCAL_QUARTER() antlr.TerminalNode
	LAST_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	THIS_FISCAL_YEAR() antlr.TerminalNode
	LAST_FISCAL_YEAR() antlr.TerminalNode
	NEXT_FISCAL_YEAR() antlr.TerminalNode
	NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode
	LAST_N_FISCAL_YEARS_N() antlr.TerminalNode
	FIND() antlr.TerminalNode
	EMAIL() antlr.TerminalNode
	NAME() antlr.TerminalNode
	PHONE() antlr.TerminalNode
	SIDEBAR() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	PRICEBOOKID() antlr.TerminalNode
	NETWORK() antlr.TerminalNode
	SNIPPET() antlr.TerminalNode
	TARGET_LENGTH() antlr.TerminalNode
	DIVISION() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	LISTVIEW() antlr.TerminalNode

	// IsAnyIdContext differentiates from other interfaces.
	IsAnyIdContext()
}

type AnyIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyIdContext() *AnyIdContext {
	var p = new(AnyIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_anyId
	return p
}

func InitEmptyAnyIdContext(p *AnyIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_anyId
}

func (*AnyIdContext) IsAnyIdContext() {}

func NewAnyIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyIdContext {
	var p = new(AnyIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_anyId

	return p
}

func (s *AnyIdContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyIdContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ApexParserIdentifier, 0)
}

func (s *AnyIdContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(ApexParserABSTRACT, 0)
}

func (s *AnyIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ApexParserAFTER, 0)
}

func (s *AnyIdContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(ApexParserBEFORE, 0)
}

func (s *AnyIdContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ApexParserBREAK, 0)
}

func (s *AnyIdContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ApexParserCATCH, 0)
}

func (s *AnyIdContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ApexParserCLASS, 0)
}

func (s *AnyIdContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONTINUE, 0)
}

func (s *AnyIdContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserDELETE, 0)
}

func (s *AnyIdContext) DO() antlr.TerminalNode {
	return s.GetToken(ApexParserDO, 0)
}

func (s *AnyIdContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *AnyIdContext) ENUM() antlr.TerminalNode {
	return s.GetToken(ApexParserENUM, 0)
}

func (s *AnyIdContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ApexParserEXTENDS, 0)
}

func (s *AnyIdContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ApexParserFINAL, 0)
}

func (s *AnyIdContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ApexParserFINALLY, 0)
}

func (s *AnyIdContext) FOR() antlr.TerminalNode {
	return s.GetToken(ApexParserFOR, 0)
}

func (s *AnyIdContext) GET() antlr.TerminalNode {
	return s.GetToken(ApexParserGET, 0)
}

func (s *AnyIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ApexParserGLOBAL, 0)
}

func (s *AnyIdContext) IF() antlr.TerminalNode {
	return s.GetToken(ApexParserIF, 0)
}

func (s *AnyIdContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(ApexParserIMPLEMENTS, 0)
}

func (s *AnyIdContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(ApexParserINHERITED, 0)
}

func (s *AnyIdContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserINSERT, 0)
}

func (s *AnyIdContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserINSTANCEOF, 0)
}

func (s *AnyIdContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ApexParserINTERFACE, 0)
}

func (s *AnyIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(ApexParserLIST, 0)
}

func (s *AnyIdContext) MAP() antlr.TerminalNode {
	return s.GetToken(ApexParserMAP, 0)
}

func (s *AnyIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(ApexParserMERGE, 0)
}

func (s *AnyIdContext) NEW() antlr.TerminalNode {
	return s.GetToken(ApexParserNEW, 0)
}

func (s *AnyIdContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *AnyIdContext) ON() antlr.TerminalNode {
	return s.GetToken(ApexParserON, 0)
}

func (s *AnyIdContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(ApexParserOVERRIDE, 0)
}

func (s *AnyIdContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(ApexParserPRIVATE, 0)
}

func (s *AnyIdContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(ApexParserPROTECTED, 0)
}

func (s *AnyIdContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(ApexParserPUBLIC, 0)
}

func (s *AnyIdContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURN, 0)
}

func (s *AnyIdContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *AnyIdContext) SHARING() antlr.TerminalNode {
	return s.GetToken(ApexParserSHARING, 0)
}

func (s *AnyIdContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ApexParserSTATIC, 0)
}

func (s *AnyIdContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ApexParserSUPER, 0)
}

func (s *AnyIdContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ApexParserSWITCH, 0)
}

func (s *AnyIdContext) TESTMETHOD() antlr.TerminalNode {
	return s.GetToken(ApexParserTESTMETHOD, 0)
}

func (s *AnyIdContext) THIS() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS, 0)
}

func (s *AnyIdContext) THROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTHROW, 0)
}

func (s *AnyIdContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(ApexParserTRANSIENT, 0)
}

func (s *AnyIdContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIGGER, 0)
}

func (s *AnyIdContext) TRY() antlr.TerminalNode {
	return s.GetToken(ApexParserTRY, 0)
}

func (s *AnyIdContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserUNDELETE, 0)
}

func (s *AnyIdContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *AnyIdContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserUPSERT, 0)
}

func (s *AnyIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserVIRTUAL, 0)
}

func (s *AnyIdContext) WEBSERVICE() antlr.TerminalNode {
	return s.GetToken(ApexParserWEBSERVICE, 0)
}

func (s *AnyIdContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *AnyIdContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHILE, 0)
}

func (s *AnyIdContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *AnyIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(ApexParserWITHOUT, 0)
}

func (s *AnyIdContext) IntegralCurrencyLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegralCurrencyLiteral, 0)
}

func (s *AnyIdContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *AnyIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT, 0)
}

func (s *AnyIdContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *AnyIdContext) AS() antlr.TerminalNode {
	return s.GetToken(ApexParserAS, 0)
}

func (s *AnyIdContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *AnyIdContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(ApexParserSCOPE, 0)
}

func (s *AnyIdContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *AnyIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *AnyIdContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *AnyIdContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ApexParserLIMIT, 0)
}

func (s *AnyIdContext) SOQLAND() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLAND, 0)
}

func (s *AnyIdContext) SOQLOR() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLOR, 0)
}

func (s *AnyIdContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *AnyIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(ApexParserAVG, 0)
}

func (s *AnyIdContext) COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT_DISTINCT, 0)
}

func (s *AnyIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(ApexParserMIN, 0)
}

func (s *AnyIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(ApexParserMAX, 0)
}

func (s *AnyIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(ApexParserSUM, 0)
}

func (s *AnyIdContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserTYPEOF, 0)
}

func (s *AnyIdContext) END() antlr.TerminalNode {
	return s.GetToken(ApexParserEND, 0)
}

func (s *AnyIdContext) THEN() antlr.TerminalNode {
	return s.GetToken(ApexParserTHEN, 0)
}

func (s *AnyIdContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ApexParserLIKE, 0)
}

func (s *AnyIdContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *AnyIdContext) INCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserINCLUDES, 0)
}

func (s *AnyIdContext) EXCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserEXCLUDES, 0)
}

func (s *AnyIdContext) ASC() antlr.TerminalNode {
	return s.GetToken(ApexParserASC, 0)
}

func (s *AnyIdContext) DESC() antlr.TerminalNode {
	return s.GetToken(ApexParserDESC, 0)
}

func (s *AnyIdContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ApexParserNULLS, 0)
}

func (s *AnyIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ApexParserFIRST, 0)
}

func (s *AnyIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST, 0)
}

func (s *AnyIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUP, 0)
}

func (s *AnyIdContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *AnyIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ApexParserROWS, 0)
}

func (s *AnyIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEW, 0)
}

func (s *AnyIdContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ApexParserHAVING, 0)
}

func (s *AnyIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ApexParserROLLUP, 0)
}

func (s *AnyIdContext) TOLABEL() antlr.TerminalNode {
	return s.GetToken(ApexParserTOLABEL, 0)
}

func (s *AnyIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ApexParserOFFSET, 0)
}

func (s *AnyIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *AnyIdContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *AnyIdContext) AT() antlr.TerminalNode {
	return s.GetToken(ApexParserAT, 0)
}

func (s *AnyIdContext) ABOVE() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE, 0)
}

func (s *AnyIdContext) BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserBELOW, 0)
}

func (s *AnyIdContext) ABOVE_OR_BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE_OR_BELOW, 0)
}

func (s *AnyIdContext) SECURITY_ENFORCED() antlr.TerminalNode {
	return s.GetToken(ApexParserSECURITY_ENFORCED, 0)
}

func (s *AnyIdContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(ApexParserREFERENCE, 0)
}

func (s *AnyIdContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ApexParserCUBE, 0)
}

func (s *AnyIdContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ApexParserFORMAT, 0)
}

func (s *AnyIdContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(ApexParserTRACKING, 0)
}

func (s *AnyIdContext) VIEWSTAT() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEWSTAT, 0)
}

func (s *AnyIdContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(ApexParserSTANDARD, 0)
}

func (s *AnyIdContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(ApexParserCUSTOM, 0)
}

func (s *AnyIdContext) CALENDAR_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_MONTH, 0)
}

func (s *AnyIdContext) CALENDAR_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_QUARTER, 0)
}

func (s *AnyIdContext) CALENDAR_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_YEAR, 0)
}

func (s *AnyIdContext) DAY_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_MONTH, 0)
}

func (s *AnyIdContext) DAY_IN_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_WEEK, 0)
}

func (s *AnyIdContext) DAY_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_YEAR, 0)
}

func (s *AnyIdContext) DAY_ONLY() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_ONLY, 0)
}

func (s *AnyIdContext) FISCAL_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_MONTH, 0)
}

func (s *AnyIdContext) FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_QUARTER, 0)
}

func (s *AnyIdContext) FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_YEAR, 0)
}

func (s *AnyIdContext) HOUR_IN_DAY() antlr.TerminalNode {
	return s.GetToken(ApexParserHOUR_IN_DAY, 0)
}

func (s *AnyIdContext) WEEK_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_MONTH, 0)
}

func (s *AnyIdContext) WEEK_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_YEAR, 0)
}

func (s *AnyIdContext) CONVERT_TIMEZONE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_TIMEZONE, 0)
}

func (s *AnyIdContext) YESTERDAY() antlr.TerminalNode {
	return s.GetToken(ApexParserYESTERDAY, 0)
}

func (s *AnyIdContext) TODAY() antlr.TerminalNode {
	return s.GetToken(ApexParserTODAY, 0)
}

func (s *AnyIdContext) TOMORROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTOMORROW, 0)
}

func (s *AnyIdContext) LAST_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_WEEK, 0)
}

func (s *AnyIdContext) THIS_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_WEEK, 0)
}

func (s *AnyIdContext) NEXT_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_WEEK, 0)
}

func (s *AnyIdContext) LAST_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_MONTH, 0)
}

func (s *AnyIdContext) THIS_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_MONTH, 0)
}

func (s *AnyIdContext) NEXT_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_MONTH, 0)
}

func (s *AnyIdContext) LAST_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_90_DAYS, 0)
}

func (s *AnyIdContext) NEXT_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_90_DAYS, 0)
}

func (s *AnyIdContext) LAST_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_DAYS_N, 0)
}

func (s *AnyIdContext) NEXT_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_DAYS_N, 0)
}

func (s *AnyIdContext) NEXT_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_WEEKS_N, 0)
}

func (s *AnyIdContext) LAST_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_WEEKS_N, 0)
}

func (s *AnyIdContext) NEXT_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_MONTHS_N, 0)
}

func (s *AnyIdContext) LAST_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_MONTHS_N, 0)
}

func (s *AnyIdContext) THIS_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_QUARTER, 0)
}

func (s *AnyIdContext) LAST_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_QUARTERS_N, 0)
}

func (s *AnyIdContext) LAST_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_QUARTERS_N, 0)
}

func (s *AnyIdContext) THIS_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_YEAR, 0)
}

func (s *AnyIdContext) LAST_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_YEAR, 0)
}

func (s *AnyIdContext) NEXT_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_YEAR, 0)
}

func (s *AnyIdContext) NEXT_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_YEARS_N, 0)
}

func (s *AnyIdContext) LAST_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_YEARS_N, 0)
}

func (s *AnyIdContext) THIS_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_QUARTER, 0)
}

func (s *AnyIdContext) LAST_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_QUARTERS_N, 0)
}

func (s *AnyIdContext) LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_QUARTERS_N, 0)
}

func (s *AnyIdContext) THIS_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_YEAR, 0)
}

func (s *AnyIdContext) LAST_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_YEAR, 0)
}

func (s *AnyIdContext) NEXT_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_YEAR, 0)
}

func (s *AnyIdContext) NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_YEARS_N, 0)
}

func (s *AnyIdContext) LAST_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_YEARS_N, 0)
}

func (s *AnyIdContext) FIND() antlr.TerminalNode {
	return s.GetToken(ApexParserFIND, 0)
}

func (s *AnyIdContext) EMAIL() antlr.TerminalNode {
	return s.GetToken(ApexParserEMAIL, 0)
}

func (s *AnyIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(ApexParserNAME, 0)
}

func (s *AnyIdContext) PHONE() antlr.TerminalNode {
	return s.GetToken(ApexParserPHONE, 0)
}

func (s *AnyIdContext) SIDEBAR() antlr.TerminalNode {
	return s.GetToken(ApexParserSIDEBAR, 0)
}

func (s *AnyIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *AnyIdContext) METADATA() antlr.TerminalNode {
	return s.GetToken(ApexParserMETADATA, 0)
}

func (s *AnyIdContext) PRICEBOOKID() antlr.TerminalNode {
	return s.GetToken(ApexParserPRICEBOOKID, 0)
}

func (s *AnyIdContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(ApexParserNETWORK, 0)
}

func (s *AnyIdContext) SNIPPET() antlr.TerminalNode {
	return s.GetToken(ApexParserSNIPPET, 0)
}

func (s *AnyIdContext) TARGET_LENGTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTARGET_LENGTH, 0)
}

func (s *AnyIdContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(ApexParserDIVISION, 0)
}

func (s *AnyIdContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURNING, 0)
}

func (s *AnyIdContext) LISTVIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserLISTVIEW, 0)
}

func (s *AnyIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ApexParserVisitor:
		return t.VisitAnyId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ApexParser) AnyId() (localctx IAnyIdContext) {
	localctx = NewAnyIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, ApexParserRULE_anyId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1814)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-562958543355906) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562937068519423) != 0) || _la == ApexParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *ApexParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 74:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ApexParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
